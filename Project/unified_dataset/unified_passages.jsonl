{"id": 1, "contributed_by": "group 1", "title": "", "section": "", "text": "In order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants hired by a client to investigate the association between advertising and sales of a particular product. The Advertising data set consists of the sales of that product in 200 different markets, along with advertising budgets for the product in each of those markets for three different media: TV, radio, and newspaper. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets."}
{"id": 2, "contributed_by": "group 1", "title": "", "section": "", "text": "The input variables can go by different names such as: Predictors, Independent variables, Features, Sometimes simply referred to as variables.The output variable is often referred to as: Response, Dependent variable."}
{"id": 3, "contributed_by": "group 1", "title": "", "section": "", "text": "Here f is some fixed but unknown function of X1,\u2026,Xp, and \u03f5 is a random error term, which is independent of X and has mean zero. In this formulation, f represents the systematic information that X provides about Y. The error term \u03f5 captures the variability in Y that cannot be explained or predicted by X. This is because Y is also a function of \u03f5, which, by definition, cannot be predicted using X. Therefore, variability associated with \u03f5 also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f, we cannot reduce the error introduced by \u03f5."}
{"id": 4, "contributed_by": "group 1", "title": "", "section": "", "text": "The accuracy of Y^ as a prediction for Y depends on two quantities, which we will call the reducible error and the irreducible error. In general, f^\u200b will not be a perfect estimate for f, and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracy of f^ by using the most appropriate statistical learning f, so that our estimated response took the form Y^ =f(X), our prediction would still have some error in it! This is because Y is also a function of \u03f5, which, by definition, cannot be predicted using X. Therefore, variability associated with \u03f5 also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f, we cannot reduce the error introduced by \u03f5."}
{"id": 5, "contributed_by": "group 1", "title": "", "section": "", "text": "Why is the irreducible error larger than zero? The quantity \u03f5 may contain unmeasured variables that are useful in predicting Y: since we don\u2019t measure them, \u03f5 will incorporate these unmeasured variables, and we cannot use them for predicting Y. The variability associated with these unmeasured variables results in the irreducible error. Even if we had a perfect model that perfectly captured the relationship between the predictors and the response, there would still be variability in the response that we cannot predict, due to these unmeasured factors."}
{"id": 6, "contributed_by": "group 1", "title": "", "section": "", "text": "One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very flexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inference, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between Y and X1, X2, . . . , Xp. In contrast, very flexible approaches, such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can lead to such complicated estimates of f that it is difficult to understand how any individual predictor is associated with the response."}
{"id": 7, "contributed_by": "group 1", "title": "", "section": "", "text": "Consider a given estimate \u02c6f and a set of predictors X, which yields the prediction \u02c6Y = \u02c6f(X). Assume for a moment that both \u02c6f and X are fixed, so that the only variability comes from \u03f5. Then, it is easy to show that E(Y \u2212 \u02c6Y )^2 = [f(X) \u2212 \u02c6f(X)]^2 (Reducible) + Var(\u03f5) (Irreducible), where E(Y \u2212 \u02c6Y )^2 represents the average, or expected value, of the squared difference between the predicted and actual value of Y, and Var(\u03f5) represents the variance associated with the error term \u03f5. The focus of this book is on techniques for estimating f with the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y. This bound is almost always unknown in practice."}
{"id": 8, "contributed_by": "group 1", "title": "", "section": "", "text": "When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f. When we overfit the training data, the test MSE will be very large because the supposed patterns that the method found in the training data simply don\u2019t exist in the test data. Note that regardless of whether or not overfitting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the training MSE. Overfitting refers specifically to the case in which a less flexible model would have yielded a smaller test MSE."}
{"id": 9, "contributed_by": "group 1", "title": "", "section": "", "text": "The lasso, discussed in Chapter 6, relies upon a linear model but uses an alternative fitting procedure for estimating the coefficients \u03b20, \u03b21, . . . , \u03b2p. The new procedure is more restrictive in estimating the coefficients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less flexible approach than linear regression. It is also more interpretable than linear regression, because in the final model the response variable will only be related to a small subset of the predictors\u2014namely, those with nonzero coefficient estimates."}
{"id": 10, "contributed_by": "group 1", "title": "", "section": "", "text": "We have established that when inference is the goal, there are clear advantages to using simple and relatively inflexible statistical learning methods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately\u2014interpretability is not a concern. In this setting, we might expect that it will be best to use the most flexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less flexible method. This phenomenon, which may seem counterintuitive at first glance, has to do with the potential for overfitting in highly flexible methods."}
{"id": 11, "contributed_by": "group 1", "title": "", "section": "", "text": "Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f. For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4. Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6, are considerably more flexible because they can generate a much wider range of possible shapes to estimate f."}
{"id": 12, "contributed_by": "group 1", "title": "", "section": "", "text": "We tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems. However, the distinction is not always that crisp. Least squares linear regression (Chapter 3) is used with a quantitative response, whereas logistic regression (Chapter 4) is typically used with a qualitative (two-class, or binary) response. Thus, despite its name, logistic regression is a classification method."}
{"id": 13, "contributed_by": "group 1", "title": "", "section": "", "text": "For each observation of the predictor measurement(s) xi, i = 1, . . . , n there is an associated response measurement yi. We wish to fit a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the response and the predictors (inference)."}
{"id": 14, "contributed_by": "group 1", "title": "", "section": "", "text": "One statistical learning tool that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis is to ascertain, on the basis of x1, . . . , xn, whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into different groups, such as big spenders versus low spenders. If the information about each customer\u2019s spending patterns were available, then a supervised analysis would be possible. However, this information is not available\u2014that is, we do not know whether each potential customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify distinct groups."}
{"id": 15, "contributed_by": "group 1", "title": "", "section": "", "text": "In the examples shown in Figure 2.8, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter datasets that contain many more than two variables. In this case, we cannot easily plot the observations. For instance, if there are p variables in our dataset, then p(p \u2212 1)/2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are important."}
{"id": 16, "contributed_by": "group 1", "title": "", "section": "", "text": "Quantitative variables take on numerical values. Examples include a person\u2019s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes, or categories. Examples of qualitative variables include a person\u2019s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia)."}
{"id": 17, "contributed_by": "group 1", "title": "", "section": "", "text": "Variables can be characterized as either quantitative or qualitative (also known as categorical). Quantitative variables take on numerical values. Examples include a person\u2019s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes, or categories. Examples of qualitative variables include a person\u2019s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems."}
{"id": 18, "contributed_by": "group 1", "title": "", "section": "", "text": "The MSE in (2.5) is computed using the training data that was used to fit the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method works on the training data. Rather, we are interested in the accuracy of the predictions that we obtain when we apply our method to previously unseen test data. [...] In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements."}
{"id": 19, "contributed_by": "group 1", "title": "", "section": "", "text": "In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usually no test data are available. [...] This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger."}
{"id": 20, "contributed_by": "group 1", "title": "", "section": "", "text": "The degrees of freedom is a quantity that summarizes the flexibility of a curve; it is discussed more fully in Chapter 7. The orange, blue, and green squares indicate the MSEs associated with the corresponding curves in the left-hand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve\u2014note that in Figure 2.9, linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as flexibility increases."}
{"id": 21, "contributed_by": "group 1", "title": "", "section": "", "text": "In practice, one can usually compute the training MSE with relative ease, but estimating the test MSE is considerably more difficult because usually no test data are available. As the previous three examples illustrate, the flexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a variety of approaches that can be used in practice to estimate this minimum point. One important method is cross-validation (Chapter 5), which is a method for estimating the test MSE using the training data. Cross-validation is important because it provides a mechanism to assess how well a statistical learning method is likely to perform on unseen data. By partitioning the training data into subsets, cross-validation allows for the evaluation of the model's performance on one subset (validation set) while being trained on the other subsets. This process helps in identifying the model's ability to generalize to new data, thereby aiding in the selection of the most appropriate model and preventing overfitting."}
{"id": 22, "contributed_by": "group 1", "title": "", "section": "", "text": "Variables can be characterized as either quantitative or qualitative (also known as categorical). Quantitative variables take on numerical values. Examples include a person\u2019s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes, or categories. Examples of qualitative variables include a person\u2019s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems."}
{"id": 23, "contributed_by": "group 1", "title": "", "section": "", "text": "The U-shape observed in the test MSE curves turns out to be the result of two competing properties of statistical learning methods."}
{"id": 24, "contributed_by": "group 1", "title": "", "section": "", "text": "What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which \u02c6f would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different \u02c6f. But ideally the estimate for f should not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in \u02c6f. In general, more flexible statistical methods have higher variance."}
{"id": 25, "contributed_by": "group 1", "title": "", "section": "", "text": "In a real-life situation in which f is unobserved, it is generally not possible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one should always keep the bias-variance trade-off in mind."}
{"id": 26, "contributed_by": "group 1", "title": "", "section": "", "text": "We just saw that we can modify an element of an array. Can we also modify a tuple? It turns out that we cannot \u2014 and trying to do so introduces an exception, or error. [...] An array\u2019s shape attribute contains its dimension; this is always a tuple."}
{"id": 27, "contributed_by": "group 1", "title": "", "section": "", "text": "As another example, the reshape() method returns a new array with the same elements as x, but a different shape."}
{"id": 28, "contributed_by": "group 1", "title": "", "section": "", "text": "In Python, textual data is handled using strings. For instance, \"hello\" and 'hello' are strings. We can concatenate them using the addition + symbol."}
{"id": 29, "contributed_by": "group 1", "title": "", "section": "", "text": "Data sets often contain different types of data, and may have names associated with the rows or columns. For these reasons, they typically are best accommodated using a data frame. We can think of a data frame as a sequence of arrays of identical length; these are the columns. Entries in the different arrays can be combined to form a row. The pandas library can be used to create and work with data frame objects."}
{"id": 30, "contributed_by": "group 1", "title": "", "section": "", "text": "The first step of most analyses involves importing a data set into Python. Before attempting to load a data set, we must make sure that Python knows where to find the file containing it. If the file is in the same location as this notebook file, then we are all set. Otherwise, the command os.chdir() can be used to change directory. (You will need to call import os before calling os.chdir())."}
{"id": 31, "contributed_by": "group 1", "title": "", "section": "", "text": "We see that the dtype of this column is object. It turns out that all values of the horsepower column were interpreted as strings when reading in the data."}
{"id": 32, "contributed_by": "group 1", "title": "", "section": "", "text": "To fix the problem, we must provide pd.read_csv() with an argument called na_values. Now, each instance of ? in the file is replaced with the value np.nan."}
{"id": 33, "contributed_by": "group 1", "title": "", "section": "", "text": "There are various ways to deal with missing data. In this case, since only five of the rows contain missing observations, we choose to use the Auto.dropna() method to simply remove these rows."}
{"id": 34, "contributed_by": "group 1", "title": "", "section": "", "text": "In summary, a powerful set of operations is available to index the rows and columns of data frames. For integer based queries, use the iloc[] method. For string and Boolean selections, use the loc[] method. For functional queries that filter rows, use the loc[] method with a function (typically a lambda) in the rows argument."}
{"id": 35, "contributed_by": "group 1", "title": "", "section": "", "text": "In the realm of data manipulation and querying, particularly when working with DataFrames in programming languages like Python, the use of lambda functions has become increasingly prevalent. A lambda function, in this context, is an anonymous, inline function defined with the lambda keyword. Its purpose is to facilitate concise and functional queries, enabling users to filter rows based on specific conditions without the need for defining a separate, named function. This approach not only makes the code more readable but also enhances its efficiency, as lambda functions can be used directly within the selection or filtering methods applied to the DataFrame. For instance, when using the pandas library in Python, one can employ lambda functions in conjunction with methods like 'filter', 'apply', or 'query' to perform complex data manipulations and extractions. By doing so, users can achieve a high level of precision in their data selection criteria, ensuring that the resulting subset of the DataFrame meets the exact requirements of their analysis or processing task. In summary, the integration of lambda functions in DataFrame selection serves as a powerful tool, streamlining the process of data querying and manipulation, and ultimately contributing to more efficient and effective data analysis workflows."}
{"id": 36, "contributed_by": "group 1", "title": "", "section": "", "text": "Linear regression is a statistical method that is widely used in various fields for predicting a quantitative response. It establishes a linear relationship between a dependent variable and one or more independent variables. The primary purpose of linear regression is to model the expected value of a dependent variable based on the values of the independent variables. This is achieved by fitting a linear equation to the observed data. The steps to perform linear regression include determining the slope and intercept of the line that best fits the data, which minimizes the sum of the squared differences between the observed and predicted values. By doing so, linear regression provides a clear and concise way to quantify and analyze the relationships between variables, making it an essential tool for data analysis, forecasting, and decision-making. Despite its simplicity, linear regression can provide valuable insights, particularly when the relationships between variables are approximately linear. However, it is important to note that linear regression may not be suitable for all types of data, especially when the relationships between variables are complex or nonlinear. In such cases, more complex models such as neural networks might be more appropriate. Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single \u2018hidden layer\u2019) can be shown to learn any function."}
{"id": 37, "contributed_by": "group 1", "title": "", "section": "", "text": "The least squares approach in linear regression is a fundamental method utilized to determine the most accurate fitting line through a set of data points. By minimizing the sum of the squared differences between the observed values and the values predicted by the linear model, this method strives to find the line that best represents the underlying trend in the data. The differences between the observed values and the predicted values are referred to as residuals, and the least squares approach aims to minimize the sum of the squares of these residuals. This minimization process results in a line that reduces the overall error, providing a more reliable and accurate model for predicting future values. The least squares method is widely used in statistical modeling and machine learning for its efficiency and effectiveness in fitting linear models to data. It serves as a foundational technique, setting the stage for more complex models and methods in data analysis and prediction."}
{"id": 38, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression, the Residual Sum of Squares (RSS) plays a crucial role in evaluating the performance and accuracy of the model. Essentially, RSS measures the sum of the squared differences between the observed values and the values predicted by the model. This is done by taking each observed value, subtracting the corresponding predicted value, squaring the result, and then summing all these squared differences together. The primary purpose of this calculation is to quantify the model\u2019s goodness of fit, providing a numerical representation of how well the model\u2019s predictions align with the actual data. A lower RSS value indicates that the differences between the observed and predicted values are small, suggesting that the model provides a good fit to the data. Conversely, a higher RSS value points to larger discrepancies between the observed and predicted values, indicating a poorer fit. It is important to note that while a lower RSS is indicative of a better model fit, it is not the sole criterion for model evaluation, and it should be considered in conjunction with other metrics and considerations to ensure a comprehensive assessment of the model\u2019s performance."}
{"id": 39, "contributed_by": "group 1", "title": "", "section": "", "text": "The Residual Standard Error (RSE) in linear regression is a measure used to quantify how well a regression model is able to capture the underlying relationship between the variables. It calculates the average amount by which the actual response values deviate from the predictions made by the model. In simpler terms, it helps in understanding the extent of the error that is present in the model\u2019s predictions. The RSE is interpreted as the average distance that the observed values fall from the regression line. A lower RSE indicates that the model\u2019s predictions are very close to the actual values, suggesting a good fit of the model to the data. On the other hand, a higher RSE indicates a larger spread of the observed values around the predicted values, suggesting a poor fit. It is important to note that the RSE should be used in conjunction with other metrics and visualizations to get a comprehensive understanding of the model\u2019s performance. Additionally, the RSE is sensitive to outliers, and a few extreme values can significantly increase the RSE, potentially leading to a misleading interpretation of the model\u2019s fit. Therefore, it is crucial to carefully analyze the data and consider the context in which the model is being used to make accurate and reliable interpretations of the RSE."}
{"id": 40, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression, the F-statistic plays a crucial role in assessing the overall significance of the regression model. It operates by comparing the variance explained by the model to the variance that remains unexplained. Essentially, this statistic helps in determining whether the independent variables in the model collectively have a statistically significant impact on the dependent variable. When the F-statistic is large, it indicates that the variation explained by the model is significantly greater than the unexplained variation, leading to the rejection of the null hypothesis that states that the model with no independent variables fits the data as well as your model. On the other hand, a small F-statistic suggests that there might not be a linear relationship between the dependent and independent variables, implying that the model might not be a good fit for the data. In summary, the F-statistic serves as a vital tool in regression analysis, aiding researchers and statisticians in evaluating the overall fit of their linear regression model and in making informed decisions based on the statistical significance of the model."}
{"id": 41, "contributed_by": "group 1", "title": "", "section": "", "text": "The R2 statistic, also known as the coefficient of determination, plays a crucial role in linear regression, providing insight into the goodness of fit of the model. It is calculated using the formula 1 - (RSS/TSS), where RSS stands for the residual sum of squares and TSS represents the total sum of squares. The RSS is the sum of the squares of the differences between the observed and predicted values, reflecting the variance that is not explained by the model. On the other hand, TSS is the sum of the squares of the differences between the observed values and the mean of the observed values, representing the total variance in the data. By taking the ratio of RSS to TSS, we obtain a value that indicates the proportion of variance unexplained by the model. Subtracting this ratio from 1 gives us the R2 statistic, which represents the proportion of the variance in the response variable that is predictable from the predictor variable. In simpler terms, R2 provides a measure of how well the predictor variable is able to predict the response variable. A higher R2 value, closer to 1, indicates a better fit of the model, meaning that a larger proportion of the variance in the response variable is explained by the predictor variable. Conversely, a lower R2 value suggests a poorer fit. Understanding the R2 statistic is vital for evaluating the performance of a linear regression model, as it provides a quantitative measure of the model\u2019s predictive power."}
{"id": 42, "contributed_by": "group 1", "title": "", "section": "", "text": "Hypothesis testing in linear regression plays a crucial role in understanding and validating the relationships between variables. It is employed to assess whether the predictor variable, or variables, exhibit a statistically significant association with the response variable. This process is fundamental as it aids in determining the validity and strength of the predictor variables within the model, ensuring that the relationships observed are not occurring merely by chance. By conducting hypothesis tests, specifically t-tests for the coefficients of the predictor variables, we can ascertain if there is enough evidence to reject the null hypothesis, which states that there is no relationship between the predictor and response variables. A rejection of the null hypothesis implies that there is a significant linear relationship, and the predictor variable contributes meaningfully to the model. This not only helps in confirming the importance of the variables in the model but also aids in model selection and refinement, ensuring that the final model is robust and reliable. In essence, hypothesis testing in linear regression is a critical step towards building a model that accurately represents the underlying data, providing confidence in the predictions and insights derived from the model."}
{"id": 43, "contributed_by": "group 1", "title": "", "section": "", "text": "In linear regression, a confidence interval plays a crucial role in estimating the precision and reliability of the model coefficients. A confidence interval is a range of values, derived from a data sample, that is used to estimate an unknown population parameter. Specifically, in the context of linear regression, it provides a range within which the true value of a coefficient is likely to fall, given a certain level of confidence. This is essential for making inferences about the population parameters based on the sample data. The width of the confidence interval gives us an idea about how uncertain we are about the unknown parameter; a wider interval may indicate more uncertainty, and a narrower interval indicates less uncertainty. To compute the confidence interval for a regression coefficient, one typically uses the standard error of the coefficient, the sample size, and the t-distribution. The relationship between the confidence interval and the coefficients is direct; as the confidence interval provides a range of plausible values for the coefficient, helping in understanding the stability and reliability of the model. By analyzing the confidence intervals of the coefficients, one can make informed decisions and interpretations about the relationships between the variables in the linear regression model."}
{"id": 44, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression, the p-value plays a crucial role in hypothesis testing, particularly in determining the significance of predictor variables. The p-value is calculated based on the t-statistic, which is derived from the estimated coefficient and its standard error. It indicates the probability of observing a t-statistic as extreme as the one calculated, assuming that the null hypothesis is true. The null hypothesis typically posits that there is no effect or no relationship, meaning that the coefficient of the predictor variable in question is equal to zero. A small p-value, usually less than a threshold like 0.05, suggests that the evidence against the null hypothesis is strong, leading to the conclusion that the predictor variable is likely to be significant. In simpler terms, it implies that there is a statistically significant relationship between the predictor variable and the response variable. This process of using the p-value to determine significance is integral to hypothesis testing in linear regression, aiding in the identification of variables that have a meaningful impact on the model and helping to guide the selection of an appropriate model for predictive analysis."}
{"id": 45, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression, correlation plays a crucial role in understanding the strength and direction of the linear relationship between two variables. Specifically, correlation measures how changes in one variable are associated with changes in another, providing insights into the potential effectiveness of a linear regression model. A high correlation between the predictor and response variables suggests that there is a strong linear relationship, which is conducive for linear regression modeling. This is because linear regression assumes that there is a linear relationship between the input (predictor) and output (response) variables. The correlation coefficient, ranging from -1 to 1, quantifies this relationship, with values close to 1 or -1 indicating a strong linear relationship, and values close to 0 indicating a weak or no linear relationship. Additionally, the correlation coefficient is related to the R-squared (R2) value in linear regression, which represents the proportion of variance in the response variable that can be explained by the predictor variable. A high R2 value, close to 1, indicates that a large proportion of the variance in the response variable is accounted for by the linear regression model, suggesting a good fit. Therefore, understanding the correlation between variables is fundamental in assessing the appropriateness and effectiveness of a linear regression model."}
{"id": 46, "contributed_by": "group 1", "title": "", "section": "", "text": "Multiple linear regression is a statistical method that models the relationship between a dependent variable and two or more independent variables. By doing so, it helps in understanding how changes in the independent variables are associated with changes in the dependent variable. This technique is an extension of simple linear regression, which involves only one independent variable. In multiple linear regression, the independent variables can be continuous or categorical, and the model estimates the coefficients that best fit the observed data. The purpose of this method is to predict the dependent variable based on the values of the independent variables, and to assess the strength and character of the relationships between the variables. It is widely used in various fields such as economics, biology, engineering, and social sciences for making predictions, assessing relationships, and informing decision-making processes. The model takes into account the variability and potential interactions between the independent variables, providing a more comprehensive understanding of the factors that influence the dependent variable. By doing so, multiple linear regression contributes to the development of more accurate and reliable predictive models, aiding in the interpretation of complex relationships between variables."}
{"id": 47, "contributed_by": "group 1", "title": "", "section": "", "text": "Simple linear regression and multiple linear regression are both statistical methods used to model the relationship between a dependent variable and one or more independent variables. The main difference between the two lies in the number of predictor variables that they involve. Simple linear regression uses only one predictor variable to predict the value of the dependent variable, establishing a linear relationship between the two. On the other hand, multiple linear regression involves two or more predictor variables to predict the dependent variable, considering the linear relationship between each predictor variable and the dependent variable while controlling for the other predictor variables. This allows for a more comprehensive analysis as it takes into account the combined effect of all predictor variables on the dependent variable. Both methods require the assumption of a linear relationship, and they use similar methods to estimate the parameters of the regression equation and assess the fit of the model. However, multiple linear regression requires more complex calculations and considerations of multicollinearity, the situation where two or more predictor variables are highly correlated, which can affect the stability and interpretability of the model. Despite these differences, both simple and multiple linear regression are valuable tools in statistical analysis, providing insights into the relationships between variables and helping to make predictions."}
{"id": 48, "contributed_by": "group 1", "title": "", "section": "", "text": "Running separate simple linear regressions for each predictor can be problematic in some cases, primarily due to the issues that arise when predictors are correlated. When predictors have a correlation, it means that there is a relationship between them, and they are not operating independently of each other. In such scenarios, analyzing them separately through simple linear regressions can lead to misleading estimates. This is because each regression would not account for the influence of other predictors, potentially resulting in an inaccurate representation of the relationship between the predictors and the dependent variable. Moreover, this approach can complicate the process of making overall predictions, as it isolates each predictor without considering their combined effect. This is in stark contrast to multiple regression models, where all predictors are included in a single model, allowing for a more comprehensive analysis that takes into account the potential interactions and correlations between predictors. This ensures a more accurate and reliable estimation of the relationships at play, ultimately leading to better-informed predictions and conclusions. Therefore, while simple linear regressions can be useful in certain contexts, their limitations become apparent when dealing with correlated predictors, highlighting the need for more complex and holistic modeling approaches."}
{"id": 49, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of multiple linear regression, the \u03b2 coefficients play a crucial role in understanding the relationship between the predictor variables and the response variable. Specifically, each \u03b2 coefficient represents the expected change in the response variable for a one-unit increase in its corresponding predictor variable, while keeping all other predictor variables constant. This interpretation allows for a nuanced understanding of how each predictor influences the response, making it possible to predict the response variable based on the values of the predictors. It is important to note that while multiple linear regression and neural networks are both tools used for prediction, they operate on different principles and have different capabilities. Neural networks, with their ability to model complex, non-linear relationships, provide a more powerful and flexible framework for classification and regression tasks compared to linear regression models. Even a minimal neural network, with just a single hidden layer, has the capacity to learn any function, showcasing its versatility and strength in capturing intricate patterns in data. However, the interpretability of neural networks is often lower than that of linear regression models, as the \u03b2 coefficients in linear regression provide direct insights into the relationship between predictors and the response variable, which can be invaluable in certain applications."}
{"id": 50, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of multiple linear regression, the F-statistic plays a crucial role in understanding the relationship between the predictors and the response variable. Essentially, the F-statistic is used to conduct a test of significance, aiming to determine whether there is a significant linear relationship between the predictors and the response. The null hypothesis in this scenario posits that the model with no predictors fits the data as well as your model. A high F-statistic value would lead to the rejection of the null hypothesis, indicating that at least one of the predictors is significantly related to the response. This test is vital for model validation, ensuring that the relationships observed in the data are not occurring by mere chance. It is important to note that while the F-statistic provides valuable insights, it does not pinpoint which predictor is significant; further analysis, such as t-tests for individual coefficients, is required for that purpose. The F-statistic test in multiple linear regression ensures that the model\u2019s explanatory power is not just a result of the sample size or the number of predictors, but is indicative of a genuine relationship between the variables, providing a solid foundation for predictions and insights derived from the model."}
{"id": 51, "contributed_by": "group 1", "title": "", "section": "", "text": "The R-squared (R2) value is a common metric used to evaluate the goodness of fit of a regression model, indicating the proportion of variance in the dependent variable that is predictable from the independent variables. However, it has several limitations. One of the main issues is that R2 can increase with the addition of more predictors to the model, regardless of whether those predictors are actually relevant or contribute meaningfully to the model. This can lead to a misleadingly high R2 value, suggesting a better fit than the model actually provides. Additionally, R2 does not account for overfitting, a situation where the model is too complex and captures the noise in the data as if it were a real pattern. Overfitting results in a model that performs well on the training data but poorly on new, unseen data. This is a critical limitation, especially when the goal is to make predictions or generalizations from the model. In summary, while R2 can provide a quick glance at the model's performance, relying solely on it can be deceptive, and it is crucial to consider other metrics and diagnostic tools to evaluate the model's fit and predictive capabilities accurately."}
{"id": 52, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of multiple linear regression, the purpose of variable selection is crucial for various reasons. It primarily aids in pinpointing the most significant predictors within the dataset, ensuring that the model incorporates only those variables that contribute meaningfully to the prediction of the dependent variable. This process of identifying and selecting the most relevant variables helps in simplifying the model, making it more interpretable and easier to understand. By eliminating redundant or irrelevant predictors, the model becomes more efficient, potentially leading to better performance and more accurate predictions. Furthermore, a simplified model with fewer variables is less prone to overfitting, enhancing its generalizability to unseen data. In essence, variable selection plays a vital role in optimizing the performance of a multiple linear regression model, ensuring that it is both accurate and efficient, while also being straightforward and interpretable. This process aligns with the broader goals of statistical modeling and machine learning, where the aim is to develop models that are not just powerful and accurate, but also transparent and easy to understand."}
{"id": 53, "contributed_by": "group 1", "title": "", "section": "", "text": "In the realm of multiple linear regression, variable selection plays a crucial role in model building, aiming to enhance the model\u2019s performance and interpretability. Among the prevalent strategies for variable selection, forward selection, backward selection, and mixed selection stand out as common methods. Forward selection begins with an empty model, progressively adding variables based on their statistical significance. Backward selection, conversely, starts with a full model, iteratively removing the least significant variables until an optimal subset is achieved. Mixed selection combines elements of both forward and backward selection, allowing for variables to be added or removed as the model evolves. These methods aim to strike a balance between model complexity and explanatory power, ensuring that the final model is both accurate and interpretable. By judiciously selecting variables, these methods contribute to the creation of robust and efficient multiple linear regression models, facilitating better predictions and insights."}
{"id": 54, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of multiple linear regression, prediction intervals and confidence intervals serve different purposes and are interpreted in distinct ways. Prediction intervals provide a range within which we expect a particular future observation to fall, taking into account both the uncertainty in estimating the underlying regression model and the inherent variability of the response variable. On the other hand, confidence intervals offer a range within which we are certain to a specific degree that the true parameter (such as the mean response or a regression coefficient) lies. As a result, prediction intervals are generally wider than confidence intervals because they encompass not only the error in estimating the model parameters but also the natural variability of the response variable. This means that prediction intervals account for both reducible errors (which can be minimized with a better model or more data) and irreducible errors (which are inherent to the process being studied and cannot be eliminated). Understanding the distinction between these two types of intervals is crucial for accurate interpretation of regression analysis results and making informed decisions based on those results."}
{"id": 55, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of multiple linear regression, the irreducible error plays a crucial role in understanding the limitations of predictive modeling. This error, often denoted as \u03b5, represents the inherent variability in the response variable that cannot be captured by the model, regardless of how well the model is specified or how many predictor variables are included. It encompasses the random fluctuations and the unobserved variables that contribute to the variability in the outcome. The irreducible error is an essential component of the regression equation, Y = \u03b20 + \u03b21X1 + \u03b22X2 + ... + \u03b2nXn + \u03b5, where Y is the response variable, X1, X2, ..., Xn are the predictor variables, \u03b20, \u03b21, ..., \u03b2n are the coefficients, and \u03b5 is the irreducible error. Understanding that there is a limit to the accuracy of predictions due to this irreducible error is crucial for setting realistic expectations and for the proper interpretation of the model results. It highlights the importance of considering the uncertainty and variability in predictions when making decisions based on the model. In summary, the irreducible error in multiple linear regression encapsulates the unavoidable uncertainty in the model, stemming from random error and unobserved variables, and it is a vital concept for anyone working with predictive modeling to grasp."}
{"id": 56, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression models, qualitative predictors, also known as categorical variables, play a crucial role in analyzing and interpreting the relationships between different variables. Unlike quantitative predictors, which are numerical and represent quantities, qualitative predictors are variables that represent categories or classes. They are used to describe characteristics or attributes of the data, such as 'student status' (e.g., undergraduate or graduate), 'marital status' (e.g., single, married, or divorced), or 'region' (e.g., North, South, East, West). These predictors can provide valuable insights into how different categories or groups within the data may exhibit different behaviors or trends. To incorporate qualitative predictors into a linear regression model, they are typically converted into a series of binary variables through a process known as one-hot encoding or dummy coding. This process transforms the categorical variable into a format that can be effectively used in the regression analysis, allowing for the estimation of separate regression coefficients for each category or class, and thereby capturing the unique impact of each category on the dependent variable. Understanding the role and treatment of qualitative predictors in linear regression models is essential for accurate analysis and interpretation of the relationships between variables, and it contributes to the development of more comprehensive and nuanced statistical models."}
{"id": 57, "contributed_by": "group 1", "title": "", "section": "", "text": "When dealing with qualitative predictors in a linear regression model, especially those with only two levels, the incorporation of dummy variables becomes essential. A dummy variable is a numerical stand-in for a categorical fact, taking on values such as 1 or 0 to represent the presence or absence of a certain characteristic. For example, in a scenario where the qualitative predictor is the ownership of a house, one might introduce a dummy variable that takes the value of 1 if the person owns a house and 0 if they do not. This method allows for the seamless integration of categorical data into a linear regression model, facilitating the analysis and interpretation of the influence of these qualitative predictors on the dependent variable. Just like in logistic regression and neural networks, where the mathematics behind the scenes shares a lot of similarities, the use of dummy variables in linear regression is a crucial step in ensuring that the model accurately represents the complexities of the data at hand. Neural networks, with their capacity to act as powerful classifiers, also benefit from the proper encoding and incorporation of categorical data, ensuring that even minimal configurations with a single hidden layer can learn and adapt to represent a wide variety of functions and relationships within the data."}
{"id": 58, "contributed_by": "group 1", "title": "", "section": "", "text": "One-hot encoding plays a crucial role in machine learning, especially when it comes to handling qualitative predictors. In essence, this method transforms qualitative data, which is often categorical and non-numeric, into a binary format that can be easily processed by machine learning algorithms. The process involves creating a separate binary variable for each category or level of the qualitative predictor. Each instance in the dataset is then represented by a vector of 0s and 1s, where a 1 indicates the presence of a particular category, and a 0 indicates its absence. This binary representation is particularly beneficial for models that rely on numerical input, as it enables them to interpret and learn from qualitative data. By converting categories into a format that machine learning algorithms can understand, one-hot encoding enhances the versatility of these models, allowing them to handle a wider variety of data types. This, in turn, contributes to the development of more accurate and robust predictive models. Neural networks, for instance, share much of the same mathematics as logistic regression, but they are a more powerful classifier. Even a minimal neural network, with just a single \u2018hidden layer,\u2019 can learn any function, showcasing the importance of effectively handling different data types, including qualitative predictors, to harness the full potential of these advanced machine learning models."}
{"id": 59, "contributed_by": "group 1", "title": "", "section": "", "text": "Polynomial regression is a form of regression analysis that extends the linear regression model by including polynomial functions of the predictors. This approach allows for the modeling of non-linear relationships between the predictors and the response variable, providing a more flexible fit to the data. In a polynomial regression model, terms such as predictor^2, predictor^3, and so on, are added to capture non-linear patterns and trends in the dataset. This is particularly useful when the relationship between the variables is not simply a straight line, enabling the model to adapt to the curvature in the data. By incorporating these higher-degree terms, polynomial regression can provide a better fit to the data compared to linear regression, especially when the underlying relationship is complex and non-linear. However, it is crucial to be mindful of the potential for overfitting, as adding too many polynomial terms can lead to a model that is overly complex and captures noise in the data as if it were a real pattern. To mitigate this risk, it is important to carefully select the degree of the polynomial and consider using regularization techniques. Overall, polynomial regression serves as a powerful tool for capturing non-linear relationships, extending the capabilities of linear regression and providing more accurate and insightful models."}
{"id": 60, "contributed_by": "group 1", "title": "", "section": "", "text": "Linear regression modeling, despite its widespread usage in statistical analysis and predictive modeling, is susceptible to several potential problems that can significantly impact the accuracy and reliability of its predictions. One of the primary issues arises when the relationship between the independent and dependent variables is not linear, as linear regression assumes a linear relationship. When the data exhibits non-linearity, the model may fail to capture the underlying patterns, leading to poor predictions. Another problem is the correlation of error terms, which violates the assumption of independence of errors and can result in biased parameter estimates. Non-constant variance of error terms, also known as heteroscedasticity, is another issue that can lead to inefficient estimates and affect the accuracy of predictions. Outliers and high-leverage points can have a disproportionate impact on the regression line, potentially skewing the results. Finally, collinearity, the presence of highly correlated independent variables, can make it difficult to ascertain the effect of each variable on the dependent variable, leading to unstable parameter estimates. Addressing these issues is crucial for ensuring the validity of a linear regression model, and it requires careful data analysis and potentially the use of alternative modeling techniques."}
{"id": 61, "contributed_by": "group 1", "title": "", "section": "", "text": "In the context of linear regression modeling, identifying non-linearity is a crucial aspect to ensure the accuracy and reliability of the model. One effective method to detect non-linearity is by examining residual plots. Residuals are the differences between the observed values and the values predicted by the model. When these residuals are plotted and exhibit a clear pattern, it indicates that there is non-linearity in the data. This is because, in a well-fitted linear model, the residuals should be randomly scattered around zero, showing no apparent pattern. If the residuals display a systematic pattern, it suggests that the linear model is not capturing some aspect of the underlying data structure, and a non-linear model may be more appropriate. This is where neural networks come into play. Neural networks share much of the same mathematics as logistic regression. But neural networks are a more powerful classifier than logistic regression, and indeed a minimal neural network (technically one with a single \u2018hidden layer\u2019) can be shown to learn any function. By using a neural network, one can model complex non-linear relationships in the data, providing a more accurate and robust model compared to linear regression when non-linearity is present."}
{"id": 62, "contributed_by": "group 1", "title": "", "section": "", "text": "In linear regression, the impact of correlated error terms is significant and can lead to misleading results. When the error terms are correlated, it violates one of the key assumptions of linear regression, which is that the error terms are independent of each other. This correlation can lead to underestimated standard errors, resulting in narrower confidence intervals and lower p-values. Consequently, this may give an unwarranted sense of confidence in the model, as the results may appear to be more precise and reliable than they actually are. It is crucial to identify and address the issue of correlated error terms to ensure the validity and reliability of the regression model. Techniques such as Durbin-Watson test can be used to detect autocorrelation in the residuals, and if found, remedies such as adding lagged variables or using generalized least squares can be applied to mitigate the impact. Ignoring the presence of correlated error terms can lead to incorrect inferences and potentially flawed decision-making based on the regression results. Therefore, it is imperative to thoroughly check the assumptions of linear regression and take appropriate measures to address any violations, ensuring a robust and trustworthy model."}
{"id": 63, "contributed_by": "group 1", "title": "", "section": "", "text": "To determine if error terms are correlated in time series data, it is effective to plot the residuals as a function of time. When error terms are correlated, it often leads to patterns in the residuals, such as tracking, where adjacent residuals showcase similar values. This phenomenon occurs because the error terms are not independent of each other, and the value of one error term can be used to predict the value of another. Identifying such patterns is crucial as it can affect the accuracy and reliability of the time series model. Correlated error terms violate the assumption of independence, which is a key requirement in many statistical modeling techniques, leading to inefficient estimates and potentially misleading conclusions. Addressing this issue might involve transforming the data, adding additional explanatory variables to the model, or using different modeling techniques that can accommodate the correlation in error terms. Neural networks, with their ability to model complex relationships in data, can be a powerful tool in such scenarios. Although they share much of the same mathematics as logistic regression, neural networks are a more powerful classifier. Even a minimal neural network, with a single \u2018hidden layer\u2019, has the capability to learn any function, providing a robust solution to model and analyze time series data with correlated error terms."}
{"id": 64, "contributed_by": "group 1", "title": "", "section": "", "text": "Collinearity in linear regression modeling refers to the situation where two or more predictor variables are highly correlated, meaning that they have a linear relationship with each other. This can create problems in the modeling process as it becomes challenging to ascertain the effect of each individual predictor on the response variable. When collinearity is present, the coefficient estimates can become highly sensitive to changes in the model, leading to instability and making the estimates very large or very small. This instability can, in turn, make the model difficult to interpret, as the coefficient values may not reflect the true relationship between the predictors and the response variable. Additionally, collinearity can lead to a reduction in the accuracy of the predictions made by the model. In severe cases, it might even be impossible to estimate the coefficients for the affected variables accurately. To mitigate the effects of collinearity, one might consider using techniques such as ridge regression, which adds a penalty term to the regression equation to constrain the size of the coefficients, or principal component analysis, which transforms the correlated predictors into a set of uncorrelated variables. Identifying and addressing collinearity is a crucial step in ensuring that a linear regression model is reliable, accurate, and interpretable."}
{"id": 65, "contributed_by": "group 1", "title": "", "section": "", "text": "A 'parametric approach' in regression involves assuming a specific form for the relationship between variables, such as a linear equation in the case of linear regression. This approach is advantageous because it simplifies the modeling process, requiring only a limited number of parameters to describe the relationship. This simplicity not only makes the model easier to interpret but also facilitates the use of statistical tests to evaluate the model's validity and accuracy. In contrast, non-parametric methods like K-nearest neighbors (KNN) do not assume a specific form for the relationship between variables. While KNN can be more flexible and adapt to complex data patterns, it also has its drawbacks. For instance, it can be computationally intensive, especially with large datasets, and its performance heavily depends on the choice of the distance metric and the value of K. Furthermore, KNN can be sensitive to irrelevant or redundant features since all features contribute to the calculation of the distance between points. In summary, while parametric approaches like regression provide a simpler and more interpretable model that is easier to validate statistically, non-parametric methods like K-nearest neighbors offer greater flexibility at the cost of increased computational complexity and sensitivity to the choice of parameters."}
{"id": 66, "contributed_by": "group 1", "title": "", "section": "", "text": "In K-nearest neighbors (KNN) regression, the 'K' value plays a crucial role in determining the behavior of the prediction model. Specifically, it dictates how many of the nearest data points to a given input are considered when making a prediction. When the 'K' value is small, the prediction line tends to be less smooth and more sensitive to fluctuations in the data. This is because it closely follows individual data points, capturing more of the noise and variability present in the dataset. On the other hand, a larger 'K' value leads to a smoother prediction line. This occurs because the model averages over a greater number of data points, which has the effect of dampening the influence of any single point and reducing the impact of noise. In essence, the 'K' value acts as a tuning parameter that balances the trade-off between capturing the underlying trend in the data and avoiding overfitting to the noise. Adjusting the 'K' value is a critical step in KNN regression, as it can significantly influence the performance and accuracy of the model."}
{"id": 67, "contributed_by": "group 1", "title": "", "section": "", "text": "The curse of dimensionality is a term used to describe the challenges and issues that arise when analyzing and organizing data in high-dimensional spaces. This phenomenon occurs because as the number of dimensions increases, the volume of the space increases exponentially, and the available data becomes sparse. This sparsity is problematic for methods that rely on statistical significance. In the context of K-nearest neighbors (KNN), a popular machine learning algorithm used for classification and regression, the curse of dimensionality is particularly problematic. KNN works by finding the 'k' training examples closest to a given test point and making predictions based on these neighbors. However, in high-dimensional spaces, the distance between points increases, and the concept of 'closeness' becomes less meaningful. As a result, the nearest neighbors may be very far away in the input space, leading to less reliable and less accurate predictions. The sparsity of data in high-dimensional spaces means that there are fewer nearby data points, and the nearest neighbors found by KNN may not be close at all, diminishing the algorithm's effectiveness. To mitigate the effects of the curse of dimensionality, dimensionality reduction techniques or feature selection methods can be employed to reduce the number of features in the dataset, helping to improve the performance of KNN and other machine learning algorithms."}
{"id": 68, "contributed_by": "group 1", "title": "", "section": "", "text": "Predicting a qualitative response for an observation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classification first predict the probability that the observation belongs to each of the categories of a qualitative variable, as the basis for making the classification. In this sense they also behave like regression methods."}
{"id": 69, "contributed_by": "group 1", "title": "", "section": "", "text": "Each method makes very different assumptions: LDA assumes that the features are normally distributed with a common within-class covariance matrix, and naive Bayes instead assumes independence of the features."}
{"id": 70, "contributed_by": "group 1", "title": "", "section": "", "text": "The Bayes classifier works by assigning an observation to the class for which the posterior probability pk (X) is greatest. In the two-class case, this amounts to assigning an observation to the default class if Pr(default = Yes|X = x) > 0.5. Thus, the Bayes classifier, and by extension LDA, uses a threshold of 50% for the posterior probability of default in order to assign an observation to the default class."}
{"id": 71, "contributed_by": "group 1", "title": "", "section": "", "text": "The Bayes classifier works by assigning an observation to the class for which the posterior probability pk (X) is greatest. In the two-class case, this amounts to assigning an observation to the default class if Pr(default = Yes|X = x) > 0.5. Thus, the Bayes classifier, and by extension LDA, uses a threshold of 50% for the posterior probability of default in order to assign an observation to the default class. However, if we are concerned about incorrectly predicting the default status for individuals who default, then we can consider lowering this threshold. For instance, we might label any customer with a posterior probability of default above 20% to the default class. In other words, instead of assigning an observation to the default class if (4.26) holds, we could instead assign an observation to this class if Pr(default = Yes|X = x) > 0.2."}
{"id": 72, "contributed_by": "group 1", "title": "", "section": "", "text": "we must model p(X) using a function that gives outputs between 0 and 1 for all values of X. Many functions meet this description. In logistic regression, we use the logistic function. To fit the model, we use a method called maximum likelihood."}
{"id": 73, "contributed_by": "group 1", "title": "", "section": "", "text": "For a binary (two level) qualitative response, the situation is better... We could then fit a linear regression to this binary response, and predict drug overdose if Y > 0.5 and stroke otherwise... However, if we use linear regression, some of our estimates might be outside the [0, 1] interval (see Figure 4.2), making them hard to interpret as probabilities! Rather than modeling this response Y directly, logistic regression models the probability that Y belongs to a particular category... The values of Pr(default = Yes|balance), which we abbreviate p(balance), will range between 0 and 1. Then for any given value of balance, a prediction can be made for default."}
{"id": 74, "contributed_by": "group 1", "title": "", "section": "", "text": "Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines. The test error rates for the Bayes and LDA classifiers are 0.0746 and 0.0770, through a linear combination of its elements. As previously discussed, this is the reason for the word linear in LDA."}
{"id": 75, "contributed_by": "group 1", "title": "", "section": "", "text": "The quantity p(X)/[1 \u2212 p(X)] is called the odds, and can take on any value between 0 and \u221e. Values of the odds close to 0 and \u221e indicate very low and very high probabilities of default, respectively. For example, on average 1 in 5 people with an odds of 1/4 will default, since p(X) = 0.2 implies an odds of 1\u22120.2 = 1/4. Likewise, on average nine out of every ten people with an odds of 9 will default, since p(X) = 0.9 implies an odds of 1\u22120.9 = 9. Odds are traditionally used instead of probabilities in horse-racing, since they relate more naturally to the correct betting strategy."}
{"id": 76, "contributed_by": "group 1", "title": "", "section": "", "text": "In Chapter 3, we used the least squares approach to estimate the unknown linear regression coefficients. Although we could use (non-linear) least squares to fit the model, the more general method of maximum likelihood is preferred, since it has better statistical properties. The basic intuition behind using maximum likelihood."}
{"id": 77, "contributed_by": "group 1", "title": "", "section": "", "text": "To summarize, there are at least two reasons not to perform classification using a regression method: (a) a regression method cannot accommodate a qualitative response with more than two classes; (b) a regression method will not provide meaningful estimates of Pr(Y |X), even with just two classes. Thus, it is preferable to use a classification method that is truly suited for qualitative response values."}
{"id": 78, "contributed_by": "group 1", "title": "", "section": "", "text": "QDA includes multiplicative terms of the form ckjl xj xl. Therefore, QDA has the potential to be more accurate in settings where interactions among the predictors are important in discriminating between classes."}
{"id": 79, "contributed_by": "group 1", "title": "", "section": "", "text": "The fact that there is not a straight-line relationship betweenp(X) and X, and the fact that the rate of change in p(X) per unit change in X depends on the current value of X."}
{"id": 80, "contributed_by": "group 1", "title": "", "section": "", "text": "In accordance with our earlier notation, we will use the abbreviation pk\u200b(x)=Pr(Y=k\u2223X=x); this is the posterior probability that an observation X=x belongs to the kth class. That is, it is the probability that the observation belongs to the kth class, given the predictor value for that observation."}
{"id": 81, "contributed_by": "group 1", "title": "", "section": "", "text": "The Poisson distribution is typically used to model counts; this is a natural choice for a number of reasons, including the fact that counts, like the Poisson distribution, take on nonnegative integer values."}
{"id": 82, "contributed_by": "group 1", "title": "", "section": "", "text": "This simple example illustrates the dangers and subtleties associated with performing regressions involving only a single predictor when other predictors may also be relevant. As in the linear regression setting, the results obtained using one predictor may be quite different from those obtained using multiple predictors, especially when there is correlation among the predictors. In general, the phenomenon is known as confounding."}
{"id": 83, "contributed_by": "group 1", "title": "", "section": "", "text": "Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off."}
{"id": 84, "contributed_by": "group 1", "title": "", "section": "", "text": "To assign a new observation X = x, LDA plugs these estimates into a formula to obtain quantities k(x), and classifies to the class for which k(x) is largest. Note that in the formula k(x) is a linear function of x; that is, the LDA decision rule depends on x only."}
{"id": 85, "contributed_by": "group 1", "title": "", "section": "", "text": "The ROC curve is a popular graphic for simultaneously displaying the two types of errors for all possible thresholds. The name \u201cROC\u201d is historic, and comes from communications theory. It is an acronym for receiver operating characteristics. Figure 4.8 displays the ROC curve for the LDA classifier on the Default data. It traces out two types of error as we vary the threshold value for the posterior probability of default. The actual thresholds are not shown. The true positive rate is the sensitivity: the fraction of defaulters that are correctly identified, using a given threshold value. The false positive rate is 1-specificity: the fraction of non-defaulters that we classify incorrectly as defaulters, using that same threshold value. The ideal ROC curve hugs the top left corner, indicating a high true positive rate and a low false positive rate. The dotted line represents the \u201cno information\u201d classifier; this is what we would expect if student status and credit card balance are not associated with the probability of default."}
{"id": 86, "contributed_by": "group 1", "title": "", "section": "", "text": "As we have seen above, varying the classifier threshold changes its true positive and false positive rate. These are also called the sensitivity and one minus the specificity of our classifier. [...] The true positive rate is the sensitivity: the fraction of defaulters that are correctly identified, using a given threshold value."}
{"id": 87, "contributed_by": "group 1", "title": "", "section": "", "text": "The Bayes classifier works by assigning an observation to the class for which the posterior probability pk (X) is greatest. In the two-class case, this amounts to assigning an observation to the default class if Pr(default = Yes|X = x) > 0.5. Thus, the Bayes classifier, and by extension LDA, uses a threshold of 50% for the posterior probability of default in order to assign an observation to the default class. However, if we are concerned about incorrectly predicting the default status for individuals who default, then we can consider lowering this threshold. For instance, we might label any customer with a posterior probability of default above 20% to the default class. In other words, instead of assigning an observation to the default class if Pr(default = Yes|X = x) > 0.5, we could instead assign an observation to this class if Pr(default = Yes|X = x) > 0.2."}
{"id": 88, "contributed_by": "group 1", "title": "", "section": "", "text": "In this chapter, we study approaches for predicting qualitative responses, a process that is known as classification. Predicting a qualitative response for an observation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classification first predict the probability that the observation belongs to each of the categories of a qualitative variable, as the basis for making the classification. In this sense they also behave like regression methods."}
{"id": 89, "contributed_by": "group 1", "title": "", "section": "", "text": "Since the p-value associated with balance in Table 4.1 is tiny, we can reject H0. In other words, we conclude that there is indeed an association between balance and probability of default. The estimated intercept in Table 4.1 is typically not of interest; its main purpose is to adjust the average fitted probabilities to the proportion of ones in the data (in this case, the overall default rate)."}
{"id": 90, "contributed_by": "group 1", "title": "", "section": "", "text": "Once we have made the naive Bayes assumption, we can plug to obtain an expression for the posterior probability,To estimate the one-dimensional density function f_{kj} using training data x_{1j}, . . . , x_{nj}, we have a few options."}
{"id": 91, "contributed_by": "group 1", "title": "", "section": "", "text": "As a concrete example, we consider the Bikeshare data set. The response is bikers, the number of hourly users of a bike sharing program in Washington, DC. This response value is neither qualitative nor quantitative: instead, it takes on non-negative integer values, or counts. We will consider counts."}
{"id": 92, "contributed_by": "group 1", "title": "", "section": "", "text": "In previous sections, we used Bayes\u2019 theorem (4.15) to develop the LDA and QDA classifiers. Here, we use Bayes\u2019 theorem to motivate the popular naive Bayes classifier. Recall that Bayes\u2019 theorem (4.15) provides an expression for the posterior probability pk (x) = Pr(Y = k|X = x) in terms of \u03c01 , . . . , \u03c0K and f1 (x), . . . , fK (x). To use (4.15) in practice, we need estimates for \u03c01 , . . . , \u03c0K and f1 (x), . . . , fK (x). As we saw in previous sections, estimating the prior probabilities \u03c01 , . . . , \u03c0K is typically straightforward: for instance, we can estimate \u03c0\u0302k as the proportion of training observations belonging to the kth class, for k = 1, . . . , K."}
{"id": 93, "contributed_by": "group 1", "title": "", "section": "", "text": "Suppose that we wish to classify an observation into one of K classes, where K \u2265 2. In other words, the qualitative response variable Y can take on K possible distinct and unordered values. Let \u03c0k represent the overall or prior probability that a randomly chosen observation comes from the kth class. Let fk(X) \u2261 Pr(X|Y = k) denote the density function of X for an observation that comes from the kth class. In other words, fk(x) is relatively large if there is a high probability that an observation in the kth class has X \u2248 x, and fk(x) is small if it is very unlikely that an observation in the kth class has X \u2248 x."}
{"id": 94, "contributed_by": "group 1", "title": "", "section": "", "text": "we need to estimate the unknown parameters \u03bc1 , . . . , \u03bcK , \u03c31 , . . . , \u03c0K , and \u03a3; the formulas are similar to those used in the one-dimensional case, given in a formula. To assign a new observation X = x, LDA plugs these estimates into (4.24) to obtain quantities k(x), and classifies to the class for which k(x) is largest. Note that in formula k(x) is a linear function of x; that is, the LDA decision rule depends on x only."}
{"id": 95, "contributed_by": "group 1", "title": "", "section": "", "text": "from class 2, one separates class 1 from class 3, and one separates class 2 from class 3. These three Bayes decision boundaries divide the predictor space into three regions. The Bayes classifier will classify an observation according to the region in which it is located."}
{"id": 96, "contributed_by": "group 1", "title": "", "section": "", "text": "Summarized over all possible thresholds, is given by the area under the (ROC) curve (AUC). An ideal ROC curve will hug the top left corner, so the larger the area under the AUC the better the classifier. For this data, the AUC is 0.95, which is close to the maximum of 1.0, so would be considered very good. We expect a classifier that performs no better than chance to have an AUC of 0.5 (when evaluated on an independent test set not used in model training). ROC curves are useful for comparing different classifiers, since they take into account all possible thresholds."}
{"id": 97, "contributed_by": "group 1", "title": "", "section": "", "text": "LDA is a special case of QDA with ckjl = 0 for all j = 1, . . . , p, l = 1, . . . , p, and k = 1, . . . , K. (Of course, this is not surprising, since LDA is simply a restricted version of QDA with \u03a31 = \u00b7 \u00b7 \u00b7 = \u03a3K = \u03a3.) Any classifier with a linear decision boundary is a special case of naive Bayes with gkj (xj ) = bkj xj. In particular, this means that LDA is a special case of naive Bayes! This is not at all obvious from the descriptions of LDA and naive Bayes earlier in this chapter, since each method makes very different assumptions: LDA assumes that the features are normally distributed with a common within-class covariance matrix, and naive Bayes instead assumes independence of the features."}
{"id": 98, "contributed_by": "group 1", "title": "", "section": "", "text": "In the left-hand panel, the two Gaussian classes have a common correlation of 0.7 between X1 and X2. As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suffers from higher variance without a corresponding decrease in bias. In contrast, the right-hand panel displays a situation in which the orange class has a correlation of 0.7 between the variables and the blue class has a correlation of \u22120.7. Now the Bayes decision boundary is quadratic, and so QDA more accurately approximates this boundary than does LDA."}
{"id": 99, "contributed_by": "group 1", "title": "", "section": "", "text": "In fact, since estimating a joint distribution requires such a huge amount of data, naive Bayes is a good choice in a wide range of settings. Essentially, the naive Bayes assumption introduces some bias, but reduces variance, leading to a classifier that works quite well in practice as a result of the bias-variance trade-off."}
{"id": 100, "contributed_by": "group 1", "title": "", "section": "", "text": "As we have discussed, LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class-specific mean vector and a covariance matrix that is common to all K classes. Quadratic discriminant analysis (QDA) provides an alternative approach. Like LDA, the QDA classifier results from assuming that the observations from each class are drawn from a Gaussian distribution, and plugging estimates for the parameters into Bayes\u2019 theorem in order to perform prediction. However, unlike LDA, QDA assumes that each class has its own covariance matrix. That is, it assumes that an observation from the kth class is of the form X ~ N (\u03bck , \u03a3k ), where \u03a3k is a covariance matrix for the kth class. Under this assumption, the Bayes classifier assigns an observation X = x to the class for which \u03b4k (x) is largest."}
{"id": 101, "contributed_by": "group 2", "title": "", "section": "", "text": "Resampling methods are an indispensable tool in modern statistics. They involve repeatedly drawing samples from a training set and refitting a model of interest on each sample in order to obtain additional information about the fitted model."}
{"id": 102, "contributed_by": "group 2", "title": "", "section": "", "text": "For example, in order to estimate the variability of a linear regression fit, we can repeatedly draw different samples from the training data, fit a linear regression to each new sample, and then examine the extent to which the resulting fits differ."}
{"id": 103, "contributed_by": "group 2", "title": "", "section": "", "text": "In this chapter, we discuss two of the most commonly used resampling methods, cross-validation and the bootstrap. Both methods are important tools in the practical application of many statistical learning procedures."}
{"id": 104, "contributed_by": "group 2", "title": "", "section": "", "text": "In Chapter 2, we discuss the distinction between the test error rate and the training error rate. The test error is the average error that results from using a statistical learning method to predict the response on a new observation\u2014that is, a measurement that was not used in training the method."}
{"id": 105, "contributed_by": "group 2", "title": "", "section": "", "text": "Suppose that we would like to estimate the test error associated with fitting a particular statistical learning method on a set of observations. The validation set approach, displayed in Figure 5.1, is a very simple strategy for this task. It involves randomly dividing the available set of observations into two parts, a training set and a validation set or hold-out set."}
{"id": 106, "contributed_by": "group 2", "title": "", "section": "", "text": "The variability among validation set MSE curves, as seen in different random splits of the data, indicates that model selection is not straightforward. While it's clear that the linear fit is inadequate for the data, there is no consensus among the curves as to which model results in the smallest validation set MSE, showing the challenge in model selection."}
{"id": 107, "contributed_by": "group 2", "title": "", "section": "", "text": "The validation set approach is conceptually simple and is easy to implement. However, it has two potential drawbacks: 1. The validation estimate of the test error rate can be highly variable, depending on precisely which observations are included in the training set and which observations are included in the validation set. 2. In the validation approach, only a subset of the observations\u2014those that are included in the training set rather than in the validation set\u2014are used to fit the model."}
{"id": 108, "contributed_by": "group 2", "title": "", "section": "", "text": "In the coming subsections, we will present cross-validation, a refinement of the validation set approach that addresses these two issues."}
{"id": 109, "contributed_by": "group 2", "title": "", "section": "", "text": "Like the validation set approach, LOOCV involves splitting the set of observations into two parts. However, instead of creating two subsets of comparable size, a single observation (x1, y1) is used for the validation set, and the remaining observations (x2, y2),...,(xn, yn)make up the training set. The statistical learning method is fit on the n - 1 training observations, and a prediction y^1 is made for the excluded observation, using its value x1."}
{"id": 110, "contributed_by": "group 2", "title": "", "section": "", "text": "We can repeat the procedure by selecting (x2, y2) for the validation data, training the statistical learning procedure on the n - 1 observations (x1, y1),(x3, y3),...,(xn, yn), and computing MSE2 = (y2-y^2)2. Repeating this approach n times produces n squared errors, MSE1,..., MSEn."}
{"id": 111, "contributed_by": "group 2", "title": "", "section": "", "text": "The LOOCV estimate for the test MSE is the average of these n test error estimates: CV(n) = 1/n0ni=1MSEi"}
{"id": 112, "contributed_by": "group 2", "title": "", "section": "", "text": "LOOCV has a couple of major advantages over the validation set approach. First, it has far less bias. In LOOCV, we repeatedly fit the statistical learning method using training sets that contain n - 1 observations, almost as many as are in the entire data set. Second, in contrast to the validation approach which will yield different results when applied repeatedly due to randomness in the training/validation set splits, performing LOOCV multiple times will always yield the same results: there is no randomness in the training/validation set splits."}
{"id": 113, "contributed_by": "group 2", "title": "", "section": "", "text": "An alternative to LOOCV is k-fold CV. This approach involves randomly dividing the set of observations into k groups, or folds, of approximately equal size. The first fold is treated as a validation set, and the method is fit on the remaining k - 1 folds. The mean squared error, MSE1, is then computed on the observations in the held-out fold. This procedure is repeated k times; each time, a different group of observations is treated as a validation set. This process results in k estimates of the test error, MSE1, MSE2,..., MSEk. The k-fold CV estimate is computed by averaging these values, CV(k) = 1k0ki=1MSEi."}
{"id": 114, "contributed_by": "group 2", "title": "", "section": "", "text": "In practice, one typically performs k-fold CV using k = 5 or k = 10. What is the advantage of using k = 5 or k = 10 rather than k = n? The most obvious advantage is computational. LOOCV requires fitting the statistical learning method n times. This has the potential to be computationally expensive (except for linear models fit by least squares, in which case formula (5.2) can be used). But cross-validation is a very general approach that can be applied to almost any statistical learning method. Some statistical learning methods have computationally intensive fitting procedures, and so performing LOOCV may pose computational problems, especially if n is extremely large. In contrast, performing 10-fold CV requires fitting the learning procedure only ten times, which may be much more feasible. As we see in Section 5.1.4, there also can be other non-computational advantages to performing 5-fold or 10-fold CV, which involve the bias-variance trade-off."}
{"id": 115, "contributed_by": "group 2", "title": "", "section": "", "text": "To summarize, there is a bias-variance trade-off associated with the choice of k in k-fold cross-validation. Typically, given these considerations, one performs k-fold cross-validation using k = 5 or k = 10, as these values have been shown empirically to yield test error rate estimates that suffer neither from excessively high bias nor from very high variance."}
{"id": 116, "contributed_by": "group 2", "title": "", "section": "", "text": "Why is this the case? When we perform LOOCV, we are in effect averaging the outputs of n fitted models, each of which is trained on an almost identical set of observations; therefore, these outputs are highly (positively) correlated with each other. In contrast, when we perform k-fold CV with k < n, we are averaging the outputs of k fitted models that are somewhat less correlated with each other, since the overlap between the training sets in each model is smaller. Since the mean of many highly correlated quantities has higher variance than does the mean of many quantities that are not as highly correlated, the test error estimate resulting from LOOCV tends to have higher variance than does the test error estimate resulting from k-fold CV."}
{"id": 117, "contributed_by": "group 2", "title": "", "section": "", "text": "However, we know that bias is not the only source for concern in an estimating procedure; we must also consider the procedure's variance. It turns out that LOOCV has higher variance than does k-fold CV with k < n. Why is this the case? When we perform LOOCV, we are in effect averaging the outputs of n fitted models, each of which is trained on an almost identical set of observations; therefore, these outputs are highly (positively) correlated with each other. In contrast, when we perform k-fold CV with k < n, we are averaging the outputs of k fitted models that are somewhat less correlated with each other, since the overlap between the training sets in each model is smaller. Since the mean of many highly correlated quantities has higher variance than does the mean of many quantities that are not as highly correlated, the test error estimate resulting from LOOCV tends to have higher variance than does the test error estimate resulting from k-fold CV."}
{"id": 118, "contributed_by": "group 2", "title": "", "section": "", "text": "But at other times we are interested only in the location of the minimum point in the estimated test MSE curve. This is because we might be performing cross-validation on a number of statistical learning methods, or on a single method using different levels of flexibility, in order to identify the method that results in the lowest test error. For this purpose, the location of the minimum point in the estimated test MSE curve is important, but the actual value of the estimated test MSE is not."}
{"id": 119, "contributed_by": "group 2", "title": "", "section": "", "text": "When we perform cross-validation, our goal might be to determine how well a given statistical learning procedure can be expected to perform on independent data; in this case, the actual estimate of the test MSE is of interest. But at other times we are interested only in the location of the minimum point in the estimated test MSE curve. This is because we might be performing cross-validation on a number of statistical learning methods, or on a single method using different levels of flexibility, in order to identify the method that results in the lowest test error."}
{"id": 120, "contributed_by": "group 2", "title": "", "section": "", "text": "It was mentioned in Section 5.1.1 that the validation set approach can lead to overestimates of the test error rate, since in this approach the training set used to fit the statistical learning method contains only half the observations of the entire data set."}
{"id": 121, "contributed_by": "group 2", "title": "", "section": "", "text": "Using this logic, it is not hard to see that LOOCV will give approximately unbiased estimates of the test error since each training set contains n - 1 observations, which is almost as many as the number of observations in the full data set."}
{"id": 122, "contributed_by": "group 2", "title": "", "section": "", "text": "To summarize, there is a bias-variance trade-off associated with the choice of k in k-fold cross-validation. Typically, given these considerations, one performs k-fold cross-validation using k = 5 or k = 10, as these values have been shown empirically to yield test error rate estimates that suffer neither from excessively high bias nor from very high variance."}
{"id": 123, "contributed_by": "group 2", "title": "", "section": "", "text": "In this chapter so far, we have illustrated the use of cross-validation in the regression setting where the outcome Y is quantitative, and so have used MSE to quantify test error. But cross-validation can also be a very useful approach in the classification setting when Y is qualitative. In this setting, cross-validation works just as described earlier in this chapter, except that rather than using MSE to quantify test error, we instead use the number of misclassified observations. For instance, in the classification setting, the LOOCV error rate takes the form: CV(n) = 1/n n0ni=1 Erri, where Erri = I(yi \u2260 ^ % yi). The k-fold CV error rate and validation set error rates are defined analogously."}
{"id": 124, "contributed_by": "group 2", "title": "", "section": "", "text": "The LOOCV error rate takes the form: CV(n) = 1/n0ni Erri, where Erri = I(yi \u2260 ^ % yi)."}
{"id": 125, "contributed_by": "group 2", "title": "", "section": "", "text": "We can easily extend logistic regression to obtain a non-linear decision boundary by using polynomial functions of the predictors. For example, we can fit a quadratic logistic regression model, given by: log(p / (1 - p)) = Beta0 + Beta1X1 + Beta2X2 + Beta3X2^2 + Beta4X2^2. The top-right panel of Figure 5.7 displays the resulting decision boundary, which is now curved."}
{"id": 126, "contributed_by": "group 2", "title": "", "section": "", "text": "Since this is simulated data, we can compute the true test error rate, which takes a value of 0.201 and so is substantially larger than the Bayes error rate of 0.133. Clearly logistic regression does not have enough flexibility to model the Bayes decision boundary in this setting."}
{"id": 127, "contributed_by": "group 2", "title": "", "section": "", "text": "A much larger improvement is apparent in the bottom-left panel of Figure 5.7, in which we have fit a logistic regression model involving cubic polynomials of the predictors. Now the test error rate has decreased to 0.160."}
{"id": 128, "contributed_by": "group 2", "title": "", "section": "", "text": "The bootstrap is a widely applicable and extremely powerful statistical tool that can be used to quantify the uncertainty associated with a given estimator or statistical learning method. As a simple example, the bootstrap can be used to estimate the standard errors of the coefficients from a linear regression fit. In the specific case of linear regression, this is not particularly useful, since we saw in Chapter 3 that standard statistical software such as R outputs such standard errors automatically. However, the power of the bootstrap lies in the fact that it can be easily applied to a wide range of statistical learning methods, including some for which a measure of variability is otherwise difficult to obtain and is not automatically output by statistical software.In practice, however, the procedure for estimating SE(^Alpha) outlined above cannot be applied because for real data, we cannot generate new samples from the original population. However, the bootstrap approach allows us to use a computer to emulate the process of obtaining new sample sets, so that we can estimate the variability of Alpha^ without generating additional samples. Rather than repeatedly obtaining independent data sets from the population, we instead obtain distinct data sets by repeatedly sampling observations from the original data set. The bootstrap approach is illustrated in the center panel of Figure 5.10, which displays a histogram of 1,000 bootstrap estimates of Alpha, each computed using a distinct bootstrap data set. This panel was constructed on the basis of a single data set and hence could be created using real data. Note that the histogram looks very similar to the left-hand panel, which displays the idealized histogram of the estimates of Alpha obtained by generating 1,000 simulated data sets from the true population. "}
{"id": 129, "contributed_by": "group 2", "title": "", "section": "", "text": "In particular, the bootstrap estimate SE(^Alpha) from (5.8) is 0.087, very close to the estimate of 0.083 obtained using 1,000 simulated data sets. The right-hand panel displays the information in the center and left panels in a different way, via boxplots of the estimates for Alpha obtained by generating 1,000 simulated data sets from the true population and using the bootstrap approach. Again, the boxplots have similar spreads, indicating that the bootstrap approach can be used to effectively estimate the variability associated with Alpha^."}
{"id": 130, "contributed_by": "group 2", "title": "", "section": "", "text": "The bootstrap approach is illustrated in the center panel of Figure 5.10, which displays a histogram of 1,000 bootstrap estimates of Alpha, each computed using a distinct bootstrap data set. This panel was constructed on the basis of a single data set and hence could be created using real data. Note that the histogram looks very similar to the left-hand panel, which displays the idealized histogram of the estimates of Alpha obtained by generating 1,000 simulated data sets from the true population. In particular, the bootstrap estimate SE(^Alpha) from (5.8) is 0.087, very close to the estimate of 0.083 obtained using 1,000 simulated data sets. The right-hand panel displays the information in the center and left panels in a different way, via boxplots of the estimates for Alpha obtained by generating 1,000 simulated data sets from the true population and using the bootstrap approach. Again, the boxplots have similar spreads, indicating that the bootstrap approach can be used to effectively estimate the variability associated with Alpha^."}
{"id": 131, "contributed_by": "group 2", "title": "", "section": "", "text": "We explore the use of the validation set approach in order to estimate the test error rates that result from fitting various linear models on the Auto data set. We use the function train_test_split() to split the data into training and validation sets. As there are 392 observations, we split into two equal sets of size 196 using the argument test_size=196. It is generally a good idea to set a random seed when performing operations like this that contain an element of randomness, so that the results obtained can be reproduced precisely at a later time. We set the random seed of the splitter with the argument random_state=0. Using this split of the observations into a training set and a validation set, we find that the validation set error rates for the models with linear, quadratic, and cubic terms are 20.76, 16.95, and 16.97, respectively. These results are consistent with our previous findings: a model that predicts mpg using a quadratic function of horsepower performs better than a model that involves only a linear function of horsepower, and there is no evidence of an improvement in using a cubic function of horsepower."}
{"id": 132, "contributed_by": "group 2", "title": "", "section": "", "text": "The cross_validate() function produces a dictionary with several components; we simply want the cross-validated test score here (MSE), which is estimated to be 24.23."}
{"id": 133, "contributed_by": "group 2", "title": "", "section": "", "text": "Above we introduced the outer() method of the np.power() function. The outer() method is applied to an operation that has two arguments, such as add(), min(), or power(). It has two arrays as arguments, and then forms a larger array where the operation is applied to each pair of elements of the two arrays. In the CV example above, we used K = n, but of course we can also use K<n. The code is very similar to the above (and is significantly faster). Here we use KFold() to partition the data into K = 10 random groups. We use random_state to set a random seed and initialize a vector cv_error in which we will store the CV errors corresponding to the polynomial fits of degrees one to five. Notice that the computation time is much shorter than that of LOOCV."}
{"id": 134, "contributed_by": "group 2", "title": "", "section": "", "text": "The cross_validate() function is flexible and can take different splitting mechanisms as an argument. For instance, one can use the ShuffleSplit() function to implement the validation set approach just as easily as K-fold cross-validation."}
{"id": 135, "contributed_by": "group 2", "title": "", "section": "", "text": "Why might we want to use another fitting procedure instead of least squares? As we will see, alternative fitting procedures can yield better pre- diction accuracy and model interpretability."}
{"id": 136, "contributed_by": "group 2", "title": "", "section": "", "text": "Model Interpretability: It is often the case that some or many of the variables used in a multiple regression model are in fact not associated with the response. Including such irrelevant variables leads to unnecessary complexity in the resulting model. By removing these variables that is, by setting the corresponding coefficient estimates to zero, we can obtain a model that is more easily interpreted. Now least squares is extremely unlikely to yield any coefficient estimates that are exactly zero. In this chapter, we see some approaches for automatically performing feature selection or variable selection, that is, for excluding irrelevant variables from a multiple regression model."}
{"id": 137, "contributed_by": "group 2", "title": "", "section": "", "text": "There are many alternatives, both classical and modern, to using least squares to fit. In this chapter, we discuss three important classes of methods.Subset Selection - This approach involves identifying a subset of the p predictors that we believe to be related to the response. We then fit a model using least squares on the reduced set of variables. Shrinkage - This approach involves fitting a model involving all p pre- dictors. However, the estimated coefficients are shrunken towards zero relative to the least squares estimates. This shrinkage (also known as regularization) has the effect of reducing variance. Depending on what type of shrinkage is performed, some of the coefficients may be estimated to be exactly zero. Hence, shrinkage methods can also perform variable selection.Dimension Reduction - This approach involves projecting the p predictors into an M-dimensional subspace, where M less than p. This is achieved by computing M different linear combinations, or projections, of the variables. Then these M projections are used as predictors to fit a linear regression model by least squares."}
{"id": 138, "contributed_by": "group 2", "title": "", "section": "", "text": "Subset Selection. This approach involves identifying a subset of the p predictors that we believe to be related to the response. We then fit a model using least squares on the reduced set of variables."}
{"id": 139, "contributed_by": "group 2", "title": "", "section": "", "text": "Shrinkage. This approach involves fitting a model involving all p predictors. However, the estimated coefficients are shrunken towards zero relative to the least squares estimates. This shrinkage (also known as regularization) has the effect of reducing variance. Depending on what type of shrinkage is performed, some of the coefficients may be estimated to be exactly zero. Hence, shrinkage methods can also perform variable selection."}
{"id": 140, "contributed_by": "group 2", "title": "", "section": "", "text": "Dimension Reduction. This approach involves projecting the p predictors into an M-dimensional subspace, where M is less than p. This is achieved by computing M different linear combinations, or projections, of the variables. Then these M projections are used as predictors to fit a linear regression model by least squares."}
{"id": 141, "contributed_by": "group 2", "title": "", "section": "", "text": "To perform best subset selection, we fit a separate least squares regression for each possible combination of the p predictors. That is, we fit all p models that contain exactly one predictor, all (p2) = p(p-1)/2 models that contain 2 exactly two predictors, and so forth. We then look at all of the resulting models, with the goal of identifying the one that is best."}
{"id": 142, "contributed_by": "group 2", "title": "", "section": "", "text": "For computational reasons, best subset selection cannot be applied with very large p. Best subset selection may also suffer from statistical problems when p is large. The larger the search space, the higher the chance of finding models that look good on the training data, even though they might not have any predictive power on future data. Thus an enormous search space can lead to overfitting and high variance of the coefficient estimates. For both of these reasons, stepwise methods, which explore a far more restricted set of models, are attractive alternatives to best subset selection."}
{"id": 143, "contributed_by": "group 2", "title": "", "section": "", "text": "For both of these reasons, stepwise methods, which explore a far more restricted set of models, are attractive alternatives to best subset selection. Forward stepwise selection is a computationally efficient alternative to best subset selection. While the best subset selection procedure considers all 2p possible models containing subsets of the p predictors, forward step-wise considers a much smaller set of models. Forward stepwise selection begins with a model containing no predictors, and then adds predictors to the model, one-at-a-time, until all of the predictors are in the model. In particular, at each step the variable that gives the greatest additional improvement to the fit is added to the model.Like forward stepwise selection, backward stepwise selection provides an efficient alternative to best subset selection. However, unlike forward step- wise selection, it begins with the full least squares model containing all p predictors, and then iteratively removes the least useful predictor, one-at- a-time. "}
{"id": 144, "contributed_by": "group 2", "title": "", "section": "", "text": "Forward stepwise selection is a computationally efficient alternative to best subset selection. While the best subset selection procedure considers all 2p possible models containing subsets of the p predictors, forward step-wise considers a much smaller set of models. Forward stepwise selection begins with a model containing no predictors, and then adds predictors to the model, one-at-a-time, until all of the predictors are in the model. In particular, at each step the variable that gives the greatest additional improvement to the fit is added to the model. More formally, the forward stepwise selection procedure is given in Algorithm"}
{"id": 145, "contributed_by": "group 2", "title": "", "section": "", "text": "Like forward stepwise selection, backward stepwise selection provides an efficient alternative to best subset selection. However, unlike forward step-wise selection, it begins with the full least squares model containing all p predictors, and then iteratively removes the least useful predictor, one-at-a-time. Details are given in Algorithm"}
{"id": 146, "contributed_by": "group 2", "title": "", "section": "", "text": "In order to select the best model with respect to test error, we need to estimate this test error. There are two common approaches:  1. We can indirectly estimate test error by making an adjustment to the training error to account for the bias due to overfitting.  2. We can directly estimate the test error, using either a validation set approach or a cross-validation approach, as discussed in Chapter 5.  We consider both of these approaches below."}
{"id": 147, "contributed_by": "group 2", "title": "", "section": "", "text": "Principal components analysis (PCA) is a popular approach for deriving a low-dimensional set of features from a large set of variables. PCA is discussed in greater detail as a tool for unsupervised learning in Chapter 12. Here we describe its use as a dimension reduction technique for regression."}
{"id": 148, "contributed_by": "group 2", "title": "", "section": "", "text": "PCA is a technique for reducing the dimension of an n x p data matrix X. The first principal component direction of the data is that along which the observations vary the most. For instance, consider Figure 6.14, which shows population size (pop) in tens of thousands of people, and ad spending for a particular company (ad) in thousands of dollars, for 100 cities. The green solid line represents the first principal component direction of the data. We can see by eye that this is the direction along which there is the greatest variability in the data. That is, if we projected the 100 observations onto this line, then the resulting projected observations would have the largest possible variance; projecting the observations onto any other line would yield projected observations with lower variance. Projecting a point onto a line simply involves finding the location on the line which is closest to the point."}
{"id": 149, "contributed_by": "group 2", "title": "", "section": "", "text": "Unlike Cp, AIC, and BIC, for which a small value indicates a model with a low test error, a large value of adjusted R squared indicates a model with a small test error. Maximizing the adjusted R squared is equivalent to minimizing RSS/n-d-1. While RSS always decreases as the number of variables in the model increases,  RSS/ n-d-1 may increase or decrease, due to the presence of d in the denominator. The intuition behind the adjusted R2 is that once all of the correct variables have been included in the model, adding additional noise variables will lead to only a very small decrease in RSS. Since adding noise variables leads to an increase in d, such variables will lead to an increase in RSS/n-d-1, and consequently a decrease in the adjusted R squared.Therefore, in theory, the model with the largest adjusted R squared will have only correct variables and no noise variables. Unlike the R squared statistic, the adjusted R squared statistic pays a price for the inclusion of unnecessary variables in the model. "}
{"id": 150, "contributed_by": "group 2", "title": "", "section": "", "text": "BIC is derived from a Bayesian point of view, but ends up looking similar to Cp (and AIC) as well. For the least squares model with d predictors, the BIC is, up to irrelevant constants. Like Cp, the BIC will tend to take on a small value for a model with a low test error, and so generally we select the model that has the lowest BIC value. Notice that BIC replaces the value used by Cp with a log term, where n is the number of observations. Since log n greater than 2 for any n greater than 7, the BIC statistic generally places a heavier penalty on models with many variables, and hence results in the selection of smaller models than Cp. In Figure, we see that this is indeed the case for the Credit data set; BIC chooses a model that contains only the four predictors income, limit, cards, and student. In this case the curves are very flat and so there does not appear to be much difference in accuracy between the four-variable and six-variable models."}
{"id": 151, "contributed_by": "group 2", "title": "", "section": "", "text": "Ridge regression advantage over least squares is rooted in the bias-variance trade-off. As lambda increases, the flexibility of the ridge regression fit decreases, leading to decreased variance but increased bias. This is illustrated in the left-hand panel of Figure 6.5, using a simulated data set containing p = 45 predictors and n = 50 observations. The green curve in the left-hand panel of Figure 6.5 displays the variance of the ridge regression predictions as a function of lambda. At the least squares coefficient estimates, which correspond to ridge regression with lambda = 0, the variance is high but there is no bias. But as lambda increases, the shrinkage of the ridge coefficient estimates leads to a substantial reduction in the variance of the predictions, at the expense of a slight increase in bias. Recall that the test mean squared error (MSE), plot- ted in purple, is closely related to the variance plus the squared bias. For values of lambda up to about 10, the variance decreases rapidly, with very little increase in bias, plotted in black. resulting in a large increase in the bias."}
{"id": 152, "contributed_by": "group 2", "title": "", "section": "", "text": "In fact, the estimated test error curves displayed in the center and right-hand panels of Figure are quite flat. While a three-variable model clearly has lower estimated test error than a two-variable model, the estimated test errors of the 3- to 11-variable models are quite similar. Furthermore, if we repeated the validation set approach using a different split of the data into a training set and a validation set, or if we repeated cross-validation using a different set of cross-validation folds, then the precise model with the lowest estimated test error would surely change. In this setting, we can select a model using the one-standard-error rule. We first calculate the standard error of the estimated test MSE for each model size, and then select the smallest model for which the estimated test error is within one standard error of the lowest point on the curve. The rationale here is that if a set of models appear to be more or less equally good, then we might as well choose the simplest model\u2014that is, the model with the smallest number of predictors. In this case, applying the one-standard-error rule to the validation set or cross-validation approach leads to selection of the three-variable model. "}
{"id": 153, "contributed_by": "group 2", "title": "", "section": "", "text": "As an alternative to the approaches just discussed, we can directly estimate the test error using the validation set and cross-validation methods discussed in Chapter 5. We can compute the validation set error or the cross-validation error for each model under consideration, and then select the model for which the resulting estimated test error is smallest. This procedure has an advantage relative to AIC, BIC, Cp, and adjusted R squared, in that it provides a direct estimate of the test error, and makes fewer assumptions about the true underlying model. It can also be used in a wider range of model selection tasks, even in cases where it is hard to pinpoint the model degrees of freedom (e.g. the number of predictors in the model) or hard to estimate the error variance . Note that when cross-validation is used, the sequence of models Mk in Algorithms is determined separately for each training fold, and the validation errors are averaged over all folds for each model size k. This means, for example with best-subset regression, that Mk, the best subset of size k, can differ across the folds. Once the best size k is chosen, we find the best model of that size on the full data set. "}
{"id": 154, "contributed_by": "group 2", "title": "", "section": "", "text": "The standard least squares coefficient estimates discussed in Chapter 3 are scale equivariant: multiplying Xj by a constant c simply leads to a scaling of the least squares coefficient estimates by a factor of 1 divided by c. In other  words, regardless of how the jth predictor is scaled, XjBj will remain the same. In contrast, the ridge regression coefficient estimates can change substantially when multiplying a given predictor by a constant. For instance, consider the income variable, which is measured in dollars. One could reasonably have measured income in thousands of dollars, which would result in a reduction in the observed values of income by a factor of 1,000. Now due to the sum of squared coefficients term in the ridge regression formulation, such a change in scale will not simply cause the ridge regression coefficient estimate for income to change by a factor of 1,000. In other words, will depend not only on the value of lambda, but also on the scaling of the  jth predictor. In fact, the value may even depend on the scaling of the other predictors! Therefore, it is best to apply ridge regression after standardizing the predictors, using the formula so that they are all on the same scale. The denominator is the estimated standard deviation of the jth predictor. Consequently, all of the standardized predictors will have a standard deviation of one. As a result the final fit will not depend on the scale on which the predictors are measured. "}
{"id": 155, "contributed_by": "group 2", "title": "", "section": "", "text": "Ridge regression does have one obvious disadvantage. Unlike best subset, forward stepwise, and backward stepwise selection, which will generally select models that involve just a subset of the variables, ridge regression will include all p predictors in the final model. The penalty will shrink all of the coefficients towards zero, but it will not set any of them exactly to zero (unless lambda = infinity). This may not be a problem for prediction accuracy, but it can create a challenge in model interpretation in settings in which the number of variables p is quite large."}
{"id": 156, "contributed_by": "group 2", "title": "", "section": "", "text": "As with ridge regression, the lasso shrinks the coefficient estimates towards zero. However, in the case of the lasso, the l1 penalty has the effect of forcing some of the coefficient estimates to be exactly equal to zero when the tuning parameter lambda is sufficiently large. Hence, much like best subset selection, the lasso performs variable selection. As a result, models generated from the lasso are generally much easier to interpret than those produced by ridge regression. We say that the lasso yields sparse models that is, models that involve only a subset of the variables."}
{"id": 157, "contributed_by": "group 2", "title": "", "section": "", "text": "These two examples illustrate that neither ridge regression nor the lasso will universally dominate the other. In general, one might expect the lasso to perform better in a setting where a relatively small number of predictors have substantial coefficients, and the remaining predictors have coefficients that are very small or that equal zero. Ridge regression will perform better when the response is a function of many predictors, all with coefficients of roughly equal size. However, the number of predictors that is related to the response is never known a priori for real data sets. A technique such as cross-validation can be used in order to determine which approach is better on a particular data set."}
{"id": 158, "contributed_by": "group 2", "title": "", "section": "", "text": "We now present partial least squares (PLS), a supervised alternative to PCR. Like PCR, PLS is a dimension reduction method, which first identifies a new set of features, that are linear combinations of the original features, and then fits a linear model via least squares using these M new features. But unlike PCR, PLS identifies these new features in a supervised way - that is, it makes use of the response Y in order to identify new features that not only approximate the old features well but also that are related to the response. Roughly speaking, the PLS approach attempts to find directions that help explain both the response and the predictors."}
{"id": 159, "contributed_by": "group 2", "title": "", "section": "", "text": "We note that even though PCR provides a simple way to perform regression using M less than p predictors, it is not a feature selection method. This is because each of the M principal components used in the regression is a linear combination of all p of the original features. Therefore, while PCR often performs quite well in many practical settings, it does not result in the development of a model that relies upon a small set of the original features. In this sense, PCR is more closely related to ridge regression than to the lasso. In fact, one can show that PCR and ridge regression are very closely related. One can even think of ridge regression as a continuous version of PCR."}
{"id": 160, "contributed_by": "group 2", "title": "", "section": "", "text": "In the past 20 years, new technologies have changed the way that data are collected in fields as diverse as finance, marketing, and medicine. It is now commonplace to collect an almost unlimited number of feature measurements (p very large). While p can be extremely large, the number of observations n is often limited due to cost, sample availability, or other considerations."}
{"id": 161, "contributed_by": "group 2", "title": "", "section": "", "text": "When the number of features p is as large as, or larger than, the number of observations n, least squares as described in Chapter 3 cannot (or rather, should not) be performed. The reason is simple: regardless of whether or not there truly is a relationship between the features and the response, least squares will yield a set of coefficient estimates that result in a perfect fit to the data, such that the residuals are zero. An example is shown in Figure with p = 1 feature (plus an intercept) in two cases: when there are 20 observations, and when there are only two observations. When there are 20 observations, n greater than p and the least squares regression line does not perfectly fit the data; instead, the regression line seeks to approximate the 20 observations as well as possible. On the other hand, when there are only two observations, then regardless of the values of those observations, the regression line will fit the data exactly. This is problematic because this perfect fit will almost certainly lead to overfitting of the data. In other words, though it is possible to perfectly fit the training data in the high-dimensional setting, the resulting linear model will perform extremely poorly on an independent test set, and therefore does not constitute a useful model "}
{"id": 162, "contributed_by": "group 2", "title": "", "section": "", "text": "The third point above is in fact a key principle in the analysis of high-dimensional data, which is known as the curse of dimensionality. One might think that as the number of features used to fit a model increases, the quality of the fitted model will increase as well. However, comparing the left-hand and right-hand panels in Figure, we see that this is not necessarily the case: in this example, the test set MSE almost doubles as p increases from 20 to 2,000. In general, adding additional signal features that are truly associated with the response will improve the fitted model, in the sense of leading to a reduction in test set error. However, adding noise features that are not truly associated with the response will lead to a deterioration in the fitted model, and consequently an increased test set error. This is because noise features increase the dimensionality of the problem, exacerbating the risk of overfitting (since noise features may be assigned nonzero coefficients due to chance associations with the response on the training set) without any potential upside in terms of improved test set error. Thus, we see that new technologies that allow for the collection of measurements for thousands or millions of features are a double-edged sword: they can lead to improved predictive models if these features are in fact relevant to the problem at hand, but will lead to worse results if the features are not relevant. "}
{"id": 163, "contributed_by": "group 2", "title": "", "section": "", "text": "When we perform the lasso, ridge regression, or other regression procedures in the high-dimensional setting, we must be quite cautious in the way that we report the results obtained. In Chapter 3, we learned about multi-collinearity, the concept that the variables in a regression might be correlated with each other. In the high-dimensional setting, the multicollinearity problem is extreme: any variable in the model can be written as a linear combination of all of the other variables in the model. Essentially, this means that we can never know exactly which variables (if any) truly are predictive of the outcome, and we can never identify the best coefficients for use in the regression. At most, we can hope to assign large regression coefficients to variables that are correlated with the variables that truly are predictive of the outcome."}
{"id": 164, "contributed_by": "group 2", "title": "", "section": "", "text": "We can see that ridge regression and the lasso perform two very different types of shrinkage. In ridge regression, each least squares coefficient estimate is shrunken by the same proportion. In contrast, the lasso shrinks each least squares coefficient towards zero by a constant amount, lambda divided by 2; the least squares coefficients that are less than lambda divided by 2 in absolute value are shrunken entirely to zero. The type of shrinkage performed by the lasso in this simple setting is known as soft-thresholding. The fact that some lasso coefficients are shrunken entirely to zero explains why the lasso performs feature selection."}
{"id": 165, "contributed_by": "group 2", "title": "", "section": "", "text": "If g is a Gaussian distribution with mean zero and standard deviation a function of lambda, then it follows that the posterior mode for beta\u2014that is, the most likely value for beta, given the data\u2014is given by the ridge regression solution. (In fact, the ridge regression solution is also the posterior mean.). If g is a double-exponential (Laplace) distribution with mean zero and scale parameter a function of lambda, then it follows that the posterior mode for beta is the lasso solution. (However, the lasso solution is not the posterior mean, and in fact, the posterior mean does not yield a sparse coefficient vector.) The Gaussian and double-exponential priors are displayed in Figure. Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow directly from assuming the usual linear model with normal errors, together with a simple prior distribution for beta. Notice that the lasso prior is steeply peaked at zero, while the Gaussian is flatter and fatter at zero. Hence, the lasso expects a priori that many of the coefficients are (exactly) zero, while ridge assumes the coefficients are randomly distributed about zero."}
{"id": 166, "contributed_by": "group 2", "title": "", "section": "", "text": "The Gaussian and double-exponential priors are displayed in Figure. Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow directly from assuming the usual linear model with normal errors, together with a simple prior distribution for beta. Notice that the lasso prior is steeply peaked at zero, while the Gaussian is flatter and fatter at zero. Hence, the lasso expects a priori that many of the coefficients are (exactly) zero, while ridge assumes the coefficients are randomly distributed about zero."}
{"id": 167, "contributed_by": "group 2", "title": "", "section": "", "text": "Ridge regression also has substantial computational advantages over best subset selection, which requires searching through 2 times of p models. As we discussed previously, even for moderate values of p, such a search can be computationally infeasible. In contrast, for any fixed value of lambda, ridge regression only fits a single model, and the model-fitting procedure can be performed quite quickly. In fact, one can show that the computations required to solve,  simultaneously for all values of lambda, are almost identical to those for fitting a model using least squares."}
{"id": 168, "contributed_by": "group 2", "title": "", "section": "", "text": "However, standard linear regression can have significant limitations in terms of predictive power. This is because the linearity assumption is almost always an approximation, and sometimes a poor one."}
{"id": 169, "contributed_by": "group 2", "title": "", "section": "", "text": "Polynomial regression extends the linear model by including additional predictor variables, obtained by raising the original predictors to various powers. For example, a cubic regression uses three variables, X, X squared, and X cube, as predictors. This approach provides a simple way to provide a nonlinear fit to data."}
{"id": 170, "contributed_by": "group 2", "title": "", "section": "", "text": "Step functions cut the range of a variable into K distinct regions in order to produce a qualitative variable. This has the effect of fitting a piecewise constant function."}
{"id": 171, "contributed_by": "group 2", "title": "", "section": "", "text": "Regression splines are more flexible than polynomials and involve dividing the range of X into K distinct regions. Within each region, a polynomial function is fit to the data. However, these polynomials are constrained so that they join smoothly at the region boundaries or knots. Provided that the interval is divided into enough regions, this can produce an extremely flexible fit."}
{"id": 172, "contributed_by": "group 2", "title": "", "section": "", "text": "It is unusual to use d greater than 3 or 4 because for large values of d, the polynomial curve can become overly flexible and can take on some very strange shapes. This is especially true near the boundary of the X variable."}
{"id": 173, "contributed_by": "group 2", "title": "", "section": "", "text": "The strength of generalized additive models lies in their ability to fit multivariate regression models with more flexibility than linear models. We demonstrate two approaches: the first in a more manual fashion using natural splines and piecewise constant functions, and the second using the pygam package and smoothing splines."}
{"id": 174, "contributed_by": "group 2", "title": "", "section": "", "text": "We now fit a GAM by hand to predict wage using natural spline functions of year and age, treating education as a qualitative predictor."}
{"id": 175, "contributed_by": "group 2", "title": "", "section": "", "text": "We will build the model matrix in a more manual fashion here, since we wish to access the pieces separately when constructing partial dependence plots."}
{"id": 176, "contributed_by": "group 2", "title": "", "section": "", "text": "Local regression is a different approach for fitting flexible non-linear functions, which involves computing the fit at a target point x0 regression using only the nearby training observations."}
{"id": 177, "contributed_by": "group 2", "title": "", "section": "", "text": "The weights Ki0 will differ for each value of x0. In other words, in order to obtain the local regression fit at a new point, we need to fit a new weighted least squares regression model by minimizing (7.14) for a new set of weights."}
{"id": 178, "contributed_by": "group 2", "title": "", "section": "", "text": "Local regression is sometimes referred to as a memory-based procedure, because like nearest-neighbors, we need all the training data each time we wish to compute a prediction."}
{"id": 179, "contributed_by": "group 2", "title": "", "section": "", "text": "While all of these choices make some difference, the most important choice is the span s, which is the proportion of points used to compute the local regression at x0, as defined in Step 1 above. The span plays a role like that of the tuning parameter."}
{"id": 180, "contributed_by": "group 2", "title": "", "section": "", "text": "When we fit a spline, where should we place the knots? The regression spline is most flexible in regions that contain a lot of knots, because in those regions the polynomial coefficients can change rapidly. Hence, oneoption is to place more knots in places where we feel the function might vary most rapidly, and to place fewer knots where it seems more stable."}
{"id": 181, "contributed_by": "group 2", "title": "", "section": "", "text": "While this option can work well, in practice it is common to place knots in a uniform fashion. One way to do this is to specify the desired degrees of freedom, and then have the software automatically place the corresponding number of knots at uniform quantiles of the data."}
{"id": 182, "contributed_by": "group 2", "title": "", "section": "", "text": "The regression spline is most flexible in regions that contain a lot of knots, because in those regions the polynomial coefficients can change rapidly."}
{"id": 183, "contributed_by": "group 2", "title": "", "section": "", "text": "Smoothing splines are similar to regression splines, but arise in a slightly different situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty."}
{"id": 184, "contributed_by": "group 2", "title": "", "section": "", "text": "The notation g(t) indicates the second derivative of the function g. The first derivative g(t) measures the slope."}
{"id": 185, "contributed_by": "group 2", "title": "", "section": "", "text": "It might seem that a smoothing spline will have far too many degrees of freedom, since a knot at each data point allows a great deal of flexibility. But the tuning parameter controls the roughness of the smoothing spline, and hence the effective degrees of freedom."}
{"id": 186, "contributed_by": "group 2", "title": "", "section": "", "text": "Although a smoothing spline has n parameters and hence n nominal degrees of freedom, these n parameters are heavily constrained or shrunk down. Hence measure of the flexibility of the smoothing spline\u2014the higher it is, the more flexible"}
{"id": 187, "contributed_by": "group 2", "title": "", "section": "", "text": "The function g(x) that minimizes can be shown to have some special properties: it is a piecewise cubic polynomial with knots at the unique values of x1, . . . ,xn, and continuous first and second derivatives at each knot. Furthermore, it is linear in the region outside f the extreme knot."}
{"id": 188, "contributed_by": "group 2", "title": "", "section": "", "text": "Usually degrees of freedom refer to the number of free parameters, such as the number of coefficients fit in a polynomial or cubic spline. Although a smoothing spline has n parameters and hence n nominal degrees of freedom, these n parameters are heavily constrained or shrunk down."}
{"id": 189, "contributed_by": "group 2", "title": "", "section": "", "text": "Although a smoothing spline has n parameters and hence n nominal degrees of freedom, these n parameters are heavily constrained or shrunk down."}
{"id": 190, "contributed_by": "group 2", "title": "", "section": "", "text": "we can always make RSS zero simply by choosing g such that it interpolates all of the yi. Such a function would woefully overfit the data\u2014it would be far too flexible. What we really want is a function g that makes RSS small, but that is also smooth."}
{"id": 191, "contributed_by": "group 2", "title": "", "section": "", "text": "In fact, in this case, g will be the linear least squares line, since the loss function in amounts to minimizing the residual sum of squares.."}
{"id": 192, "contributed_by": "group 2", "title": "", "section": "", "text": "When lamda is infinity, g will be perfectly smooth\u2014it will just be a straight line that passes as closely as possible to the training points. In fact, in this case, g will be the linear least squares line, since the loss function in amounts to minimizing the residual sum of squares."}
{"id": 193, "contributed_by": "group 2", "title": "", "section": "", "text": "Generalized Additive Models (GAMs) provide a framework for extending standard linear models by allowing non-linear functions of variables while maintaining additivity. They can be used for both quantitative and qualitative responses."}
{"id": 194, "contributed_by": "group 2", "title": "", "section": "", "text": "Generalized additive models (GAMs) provide a general framework for generalized additive model extending a standard linear model by allowing non-linear functions of each of the variables, while maintaining additivity. Just like linear models, GAMs can be applied with both quantitative and qualitative responses."}
{"id": 195, "contributed_by": "group 2", "title": "", "section": "", "text": "In order to allow for non-linear relationships between each feature and the response is to replace each linear component with a (smooth) nonlinear function."}
{"id": 196, "contributed_by": "group 2", "title": "", "section": "", "text": "Generalized additive models (GAMs) provide a general framework for generalized additive model extending a standard linear model by allowing non-linear functions of each of the variables, while maintaining additivity. Just like linear models, GAMs can be applied with both quantitative and qualitative responses."}
{"id": 197, "contributed_by": "group 2", "title": "", "section": "", "text": "The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the form."}
{"id": 198, "contributed_by": "group 2", "title": "", "section": "", "text": "To include interactions in a GAM, additional terms such as Xj x Xk can be added to the model. Alternatively, low-dimensional interaction functions like fjk(Xj, Xk) can be introduced and fitted using two-dimensional smoothers or splines."}
{"id": 199, "contributed_by": "group 2", "title": "", "section": "", "text": "The beauty of GAMs is that we can use these methods as building blocks for fitting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of fittingthe model. "}
{"id": 200, "contributed_by": "group 2", "title": "", "section": "", "text": "With polynomial regression we must decide on the degree of the polynomial to use. Sometimes we just wing it, and decide to use second or third degree polynomials, simply to obtain a nonlinear fit. But we can make such a decision in a more systematic way. One way to do this is through hypothesis tests, which we demonstrate here."}
{"id": 201, "contributed_by": "group 3", "title": "", "section": "", "text": "In this chapter, we describe tree-based methods for regression and classification. These involve stratifying or segmenting the predictor space into a number of simple regions. Decision trees can be applied to both regression and classification problems. We first consider regression problems, and then move on to classification."}
{"id": 202, "contributed_by": "group 3", "title": "", "section": "", "text": "We now elaborate on Step 1 above. How do we construct the regions R1, . . . , RJ? In order to make a prediction for a given observation, we typically use the mean or the mode response value for the training observations in the region to which it belongs. For every observation that falls into the region Rj, we make the same prediction, which is simply the mean of the response values for the training observations in Rj."}
{"id": 203, "contributed_by": "group 3", "title": "", "section": "", "text": "In theory, the regions could have any shape. However, we choose to divide the predictor space into high-dimensional rectangles, or boxes, for simplicity and for ease of interpretation of the resulting predictive model. The goal is to find boxes R1, . . . , RJ that minimize the RSS, given by sum of (yi - yRj)^2, where yRj is the mean response for the training observations within the jth box."}
{"id": 204, "contributed_by": "group 3", "title": "", "section": "", "text": "Unfortunately, it is computationally infeasible to consider every possible partition of the feature space into J boxes. For this reason, we take a top-down, greedy approach that is known as recursive binary splitting. The approach is top-down because it begins at the top of the tree (at which point all observations belong to a single region) and then successively splits the predictor space; each split is indicated via two new branches further down on the tree."}
{"id": 205, "contributed_by": "group 3", "title": "", "section": "", "text": "Next, we repeat the process, looking for the best predictor and best cutpoint in order to split the data further so as to minimize the RSS within each of the resulting regions. However, this time, instead of splitting the entire predictor space, we split one of the two previously identified regions. We now have three regions. Again, we look to split one of these three regions further, so as to minimize the RSS. The process continues until a stopping criterion is reached; for instance, we may continue until no region contains more than five observations."}
{"id": 206, "contributed_by": "group 3", "title": "", "section": "", "text": "A classification tree is very similar to a regression tree, except that it is used to predict a qualitative response rather than a quantitative one. Recall that for a regression tree, the predicted response for an observation is given by the mean response of the training observations that belong to the same terminal node. In contrast, for a classification tree, we predict that each observation belongs to the most commonly occurring class of training observations in the region to which it belongs."}
{"id": 207, "contributed_by": "group 3", "title": "", "section": "", "text": "Decision trees for regression and classification have a number of advantages over the more classical approaches seen in Chapters 3 and 4: Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression! Some people believe that decision trees more closely mirror human decision-making than do the regression and classification approaches seen in previous chapters!"}
{"id": 208, "contributed_by": "group 3", "title": "", "section": "", "text": "Once the regions R1, . . . , RJ have been created, we predict the response for a given test observation using the mean of the training observations in the region to which that test observation belongs. A five-region example of this approach is shown in Figure 8.3. In keeping with the tree analogy, the regions R1, R2, . . . , RJ are known as terminal nodes or leaves of the tree."}
{"id": 209, "contributed_by": "group 3", "title": "", "section": "", "text": "The process described above may produce good predictions on the training set, but is likely to overfit the data, leading to poor test set performance. This is because the resulting tree might be too complex. A smaller tree with fewer splits (that is, fewer regions R1, . . . , RJ) might lead to lower variance and better interpretation at the cost of a little bias."}
{"id": 210, "contributed_by": "group 3", "title": "", "section": "", "text": "Cost complexity pruning\u2014also known as weakest link pruning\u2014gives us a way to do just this. Rather than considering every possible subtree, we consider a sequence of trees indexed by a nonnegative tuning parameter A. For each value of A there corresponds a subtree T \u2282 T0 such that |T |sum of i:xiERm (yi - yRm )^2 + A|T | is as small as possible."}
{"id": 211, "contributed_by": "group 3", "title": "", "section": "", "text": "Bootstrap aggregation, or bagging, is a general-purpose procedure for reducing the variance of a statistical learning method; we introduce it here because it is particularly useful and frequently used in the context of decision trees. Recall that given a set of n independent observations Z1, . . . , Zn, each with variance B2, the variance of the mean Z of the observations is given by B2/n."}
{"id": 212, "contributed_by": "group 3", "title": "", "section": "", "text": "Random forests provide an improvement over bagged trees by way of a small tweak that decorrelates the trees. As in bagging, we build a number of decision trees on bootstrapped training samples. But when building these decision trees, each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors."}
{"id": 213, "contributed_by": "group 3", "title": "", "section": "", "text": "Boosting works in a similar way, except that the trees are grown sequentially: each tree is grown using information from previously grown trees. Consider first the regression setting. Like bagging, boosting involves combining a large number of decision trees, f1, . . . , fB."}
{"id": 214, "contributed_by": "group 3", "title": "", "section": "", "text": "Given the current model, we fit a decision tree to the residuals from the model. That is, we fit a tree using the current residuals."}
{"id": 215, "contributed_by": "group 3", "title": "", "section": "", "text": "Finally, we discuss Bayesian additive regression trees (BART), another ensemble method that uses decision trees as its building blocks. For simplicity, we present BART for regression (as opposed to classification). Recall that bagging and random forests make predictions from an average of regression trees, each of which is built using a random sample of data and/or predictors."}
{"id": 216, "contributed_by": "group 3", "title": "", "section": "", "text": "It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. Recall that the key to bagging is that trees are repeatedly fit to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations."}
{"id": 217, "contributed_by": "group 3", "title": "", "section": "", "text": "Thus far, we have assumed that the predictor variables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables. For instance, in the Heart data, some of the predictors, such as Sex, Thal (Thallium stress test), and ChestPain, are qualitative."}
{"id": 218, "contributed_by": "group 3", "title": "", "section": "", "text": "Once the regions R1, . . . , RJ have been created, we predict the response for a given test observation using the mean of the training observations in the region to which that test observation belongs. A five-region example of this approach is shown in Figure 8.3. In keeping with the tree analogy, the regions R1, R2, . . . , RJ are known as terminal nodes or leaves of the tree."}
{"id": 219, "contributed_by": "group 3", "title": "", "section": "", "text": "We can access the value of the deviance using log_loss(), -2m k nmk log pmk, where nmk is the number of observations in the mth terminal node that belong to the kth class. A small value indicates a tree that provides a good fit to the (training) data."}
{"id": 220, "contributed_by": "group 3", "title": "", "section": "", "text": "The Gini index is defined by G = K k=1 pmk(1 - pmk), a measure of total variance across the K classes. It is not hard to see that the Gini index takes on a small value if all of the pmk's are close to zero or one. For this reason the Gini index is referred to as a measure of node purity\u2014a small value indicates that a node contains predominantly observations from a single class."}
{"id": 221, "contributed_by": "group 3", "title": "", "section": "", "text": "An alternative to the Gini index is entropy, given by D = -K k=1 pmk log pmk. Since 0 \u2264 pmk \u2264 1, it follows that 0 \u2264 -pmk log pmk. One can show that the entropy will take on a value near zero if the pmk's are all near zero or near one. Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure."}
{"id": 222, "contributed_by": "group 3", "title": "", "section": "", "text": "Boosting has been demonstrated to give impressive improvements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression context, to predict a quantitative outcome Y. How can bagging be extended to a classification problem where Y is qualitative?"}
{"id": 223, "contributed_by": "group 3", "title": "", "section": "", "text": "An ensemble method is an approach that combines many simple \u201cbuilding block\u201d models in order to obtain a single and potentially very powerful model. These simple building block models are sometimes known as weak learners, since they may lead to mediocre predictions on their own."}
{"id": 224, "contributed_by": "group 3", "title": "", "section": "", "text": "More generally d is the interaction depth, and controls the interaction order of the boosted model, since d splits can involve at most d variables. In general, statistical learning approaches that learn slowly tend to perform well. Note that in boosting, unlike in bagging, the construction of each tree depends strongly on the trees that have already been grown."}
{"id": 225, "contributed_by": "group 3", "title": "", "section": "", "text": "In the case of bagging regression trees, we can record the total amount that the RSS (8.1) is decreased due to splits over a given predictor, averaged over all B trees. A large value indicates an important predictor. Similarly, in the context of bagging classification trees, we can add up the total amount that the Gini index (8.6) is decreased by splits over a given predictor, averaged over all B trees."}
{"id": 226, "contributed_by": "group 3", "title": "", "section": "", "text": "BART is related to both approaches: each tree is constructed in a random manner as in bagging and random forests, and each tree tries to capture signal not yet accounted for by the current model, as in boosting. The main novelty in BART is the way in which new trees are generated."}
{"id": 227, "contributed_by": "group 3", "title": "", "section": "", "text": "We have just described the process of boosting regression trees. Boosting classification trees proceeds in a similar but slightly more complex way, and the details are omitted here. Boosting has three tuning parameters: 1. The number of trees B. Unlike bagging and random forests, boosting can overfit if B is too large, although this overfitting tends to occur slowly if at all. We use cross-validation to select B."}
{"id": 228, "contributed_by": "group 3", "title": "", "section": "", "text": "We typically throw away the first few of these prediction models, since models obtained in the earlier iterations \u2014 known as the burn-in period \u2014 tend not to provide very good results. However, it is also possible to compute quantities other than the average: for instance, the percentiles of fL+1(x), . . . , fB(x) provide a measure of uncertainty in the final prediction."}
{"id": 229, "contributed_by": "group 3", "title": "", "section": "", "text": "Random forests overcome this problem by forcing each split to consider only a subset of the predictors. Therefore, on average (p - m)/p of the splits will not even consider the strong predictor, and so other predictors will have more of a chance. We can think of this process as decorrelating the trees, thereby making the average of the resulting trees less variable and hence more reliable."}
{"id": 230, "contributed_by": "group 3", "title": "", "section": "", "text": "Regression and classification trees have a very different flavor from the more classical approaches for regression and classification presented in Chapters 3 and 4. In particular, linear regression assumes a model of the form f(X) = B'0 + p j=1 XjB'j, whereas regression trees assume a model of the form f(X) = M m=1 cm \u00b7 1(XERm) where R1, . . . , RM represent a partition of feature space, as in Figure 8.3."}
{"id": 231, "contributed_by": "group 3", "title": "", "section": "", "text": "In a p-dimensional space, a hyperplane is a flat affine subspace of dimension p - 1. For instance, in two dimensions, a hyperplane is a flat one-dimensional subspace-in other words, a line. In three dimensions, a hyperplane is a flat two-dimensional subspace-that is, a plane. In p > 3 dimensions, it can be hard to visualize a hyperplane, but the notion of a (p - 1)-dimensional flat subspace still applies."}
{"id": 232, "contributed_by": "group 3", "title": "", "section": "", "text": "The maximal margin hyperplane (also known as the optimal separating hyperplane) is the separating hyperplane that is farthest from the training observations. That is, we can compute the (perpendicular) distance from each training observation to a given separating hyperplane; the smallest such distance is the minimal distance from the observations to the hyperplane, and is known as the margin. The maximal margin hyperplane is the separating hyperplane for which the margin is largest-that is, it is the hyperplane that has the farthest minimum distance to the training observations."}
{"id": 233, "contributed_by": "group 3", "title": "", "section": "", "text": "The maximal margin hyperplane is the separating hyperplane for which the margin is margin largest-that is, it is the hyperplane that has the farthest minimum distance to the training observations.We can then classify a test observation based on which side of the maximal margin hyperplane it lies. This is known as the maximal margin classifier."}
{"id": 234, "contributed_by": "group 3", "title": "", "section": "", "text": "However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal margin classifier. In this case, the optimization problem has no solution with M > 0. In this case, we cannot exactly separate the two classes. However, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almost separates the classes, using a so-called soft margin. The generalization of the maximal margin classifier to the non-separable case is known as the support vector classifier."}
{"id": 235, "contributed_by": "group 3", "title": "", "section": "", "text": "The support vector classifier, sometimes called a soft margin classifier, does exactly this. Rather than seeking the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane."}
{"id": 236, "contributed_by": "group 3", "title": "", "section": "", "text": "We now consider the role of the tuning parameter C. C bounds the sum of the i's, and so it determines the number and severity of the violations to the margin (and to the hyperplane) that we will tolerate. We can think of C as a budget for the amount that the margin can be violated by the n observations."}
{"id": 237, "contributed_by": "group 3", "title": "", "section": "", "text": "Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors."}
{"id": 238, "contributed_by": "group 3", "title": "", "section": "", "text": "In order to accommodate non-linear class boundaries, the feature space can be expanded using kernels. This allows the maximal margin hyperplane to become non-linear in the original feature space."}
{"id": 239, "contributed_by": "group 3", "title": "", "section": "", "text": "When the support vector classifier is combined with a non-linear kernel, the resulting classifier is known as a support vector machine."}
{"id": 240, "contributed_by": "group 3", "title": "", "section": "", "text": "K(xi, xi') is some function that we will refer to as a kernel. A kernel is a function that quantifies the similarity of two observations."}
{"id": 241, "contributed_by": "group 3", "title": "", "section": "", "text": "It is known as a linear kernel because the support vector classifier is linear in the features; the linear kernel essentially quantifies the similarity of a pair of observations using Pearson (standard) correlation."}
{"id": 242, "contributed_by": "group 3", "title": "", "section": "", "text": "With a smaller value of the cost parameter, we obtain a larger number of support vectors, because the margin is now wider."}
{"id": 243, "contributed_by": "group 3", "title": "", "section": "", "text": "It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one and one-versus-all approaches."}
{"id": 244, "contributed_by": "group 3", "title": "", "section": "", "text": "A one-versus-one or all-pairs approach constructs (K2) SVMs, each of which compares a pair of classes."}
{"id": 245, "contributed_by": "group 3", "title": "", "section": "", "text": "The one-versus-all approach (also referred to as one-versus-rest) is an alternative procedure for applying SVMs in the case of K > 2 classes. We fit K SVMs, each time comparing one of the K classes to the remaining K - 1 classes."}
{"id": 246, "contributed_by": "group 3", "title": "", "section": "", "text": "It turns out that the hinge loss function is closely related to the loss function used in logistic regression. Due to the similarities between their loss functions, logistic regression and the support vector classifier often give very similar results. When the classes are well separated, SVMs tend to behave better than logistic regression; in more overlapping regimes, logistic regression is often preferred."}
{"id": 247, "contributed_by": "group 3", "title": "", "section": "", "text": "There is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualitative response), called support vector regression. We saw that least squares regression seeks coefficients B0, B1, . . . , Bp such that the sum of squared residuals is as small as possible. Support vector regression instead seeks coefficients that minimize a different type of loss, where only residuals larger in absolute value than some positive constant contribute to the loss function. This is an extension of the margin used in support vector classifiers to the regression setting."}
{"id": 248, "contributed_by": "group 3", "title": "", "section": "", "text": "This is known as hinge loss. However, it turns out that the hinge loss function is closely related to the loss function used in logistic regression."}
{"id": 249, "contributed_by": "group 3", "title": "", "section": "", "text": "It turns out that the solution to the support vector classifier problem involves only the inner products of the observations (as opposed to the observations themselves)."}
{"id": 250, "contributed_by": "group 3", "title": "", "section": "", "text": "With this hinge-loss + penalty representation, the margin corresponds to the value one, and the width of the margin is determined by ridge coefficents."}
{"id": 251, "contributed_by": "group 3", "title": "", "section": "", "text": "This means that training observations that are far from x* will play essentially no role in the predicted class label for x*. In other words, the radial kernel has very local behavior, in the sense that only nearby training observations have an effect on the class label of a test observation."}
{"id": 252, "contributed_by": "group 3", "title": "", "section": "", "text": "It is known as a linear kernel because the support vector classifier is linear in the features; the linear kernel essentially quantifies the similarity of a pair of observations using Pearson (standard) correlation."}
{"id": 253, "contributed_by": "group 3", "title": "", "section": "", "text": "We classify a test observation x* based on which side of the hyperplane it lies. That is, we classify the test observation based on the sign of f(x*) = B0 + B1x*1 + B2x*2 + ... + Bpx*p."}
{"id": 254, "contributed_by": "group 3", "title": "", "section": "", "text": "If f(x*) is far from zero, then this means that x* lies far from the hyperplane, and so we can be confident about our class assignment for x*. On the other hand, if f(x*) is close to zero, then x* is located near the hyperplane, and so we are less certain about the class assignment for x*."}
{"id": 255, "contributed_by": "group 3", "title": "", "section": "", "text": "This is due to the fact that the loss function is exactly zero for observations for which y_i(B0 + B1xi1 + ... + Bpxip) >= 1; these correspond to observations that are on the correct side of the margin. In contrast, the loss function for logistic regression is not exactly zero anywhere. But it is very small for observations that are far from the decision boundary. Due to the similarities between their loss functions, logistic regression and the support vector classifier often give very similar results. When the classes are well separated, SVMs tend to behave better than logistic regression."}
{"id": 256, "contributed_by": "group 3", "title": "", "section": "", "text": "By considering a range of these thresholds, positive and negative, we produce the ingredients for a ROC plot. We can access these values by calling the decision_function() method of a fitted SVM estimator."}
{"id": 257, "contributed_by": "group 3", "title": "", "section": "", "text": "When C is small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance. On the other hand, when C is larger, the margin is wider and we allow more violations to it; this amounts to fitting the data less hard and obtaining a classifier that is potentially more biased but may have lower variance."}
{"id": 258, "contributed_by": "group 3", "title": "", "section": "", "text": "In practice, C is treated as a tuning parameter that is generally chosen via cross-validation. As with the tuning parameters that we have seen throughout this book, C controls the bias-variance trade-off of the statistical learning technique."}
{"id": 259, "contributed_by": "group 3", "title": "", "section": "", "text": "What is the advantage of using a kernel rather than simply enlarging the feature space using functions of the original features. One advantage is computational, and it amounts to the fact that using kernels, one need only compute K(xi, x'i) for all (n2) distinct pairs i, i' without explicitly working in the enlarged feature space."}
{"id": 260, "contributed_by": "group 3", "title": "", "section": "", "text": "The ridge penalty term plays a similar role in controlling the bias-variance trade-off for the support vector classifier."}
{"id": 261, "contributed_by": "group 3", "title": "", "section": "", "text": "Neural networks rebounded around 2010 with big successes in image classification. Around that time, massive databases of labeled images were being accumulated, with ever-increasing numbers of classes."}
{"id": 262, "contributed_by": "group 3", "title": "", "section": "", "text": "In the early instances of neural networks, the sigmoid activation function was favored, g(z) = exp(z)/(1 + exp(z)) = 1/(1 + exp(-z)), which is the same function used in logistic regression to convert a linear function into probabilities between zero and one."}
{"id": 263, "contributed_by": "group 3", "title": "", "section": "", "text": "This is a form of weight sharing used by RNNs, and similar to the use of filters in convolutional neural networks (Section 10.3.1.) As we proceed from beginning to end, the activations A! accumulate a history of what has been seen before, so that the learned context can be used for prediction."}
{"id": 264, "contributed_by": "group 3", "title": "", "section": "", "text": "Convolution layers search for instances of small patterns in the image, whereas pooling layers downsample these to select a prominent subset."}
{"id": 265, "contributed_by": "group 3", "title": "", "section": "", "text": "Convolution layers search for instances of small patterns in the image, whereas pooling layers downsample these to select a prominent subset."}
{"id": 266, "contributed_by": "group 3", "title": "", "section": "", "text": "Dropout learning can be used at each layer, as well as lasso or ridge regularization."}
{"id": 267, "contributed_by": "group 3", "title": "", "section": "", "text": "Recurrent neural networks (RNNs), where the input object X is a sequence."}
{"id": 268, "contributed_by": "group 3", "title": "", "section": "", "text": "Convolutional neural networks (CNNs) have evolved for classifying images such as these, and has shown spectacular success on a wide range of problems. Recurrent neural networks (RNNs), where the input object X is a sequence."}
{"id": 269, "contributed_by": "group 3", "title": "", "section": "", "text": "This process is known as stochastic gradient descent (SGD) and is the state of the art for learning deep neural networks."}
{"id": 270, "contributed_by": "group 3", "title": "", "section": "", "text": "We have suppressed the output here, which is a progress report on the fitting of the model, grouped by epoch. This is very useful, since on large datasets fitting can take time."}
{"id": 271, "contributed_by": "group 3", "title": "", "section": "", "text": "Overfitting can be controlled via the various forms of regularization."}
{"id": 272, "contributed_by": "group 3", "title": "", "section": "", "text": "One can use these pretrained hidden layers for new problems with much smaller training sets (a process referred to as weight freezing), and just train the last few layers of the network, which requires much less data."}
{"id": 273, "contributed_by": "group 3", "title": "", "section": "", "text": "We have repeatedly discussed the bias-variance tradeoff, first presented in Section 2.2.2."}
{"id": 274, "contributed_by": "group 3", "title": "", "section": "", "text": "An additional important trick used with image modeling is data augmentation."}
{"id": 275, "contributed_by": "group 3", "title": "", "section": "", "text": "This means (in our case) that we need a matrix E of dimension m \u00d7 10,000, where each column is indexed by one of the 10,000 words in our dictionary."}
{"id": 276, "contributed_by": "group 3", "title": "", "section": "", "text": "All the parameters B0, . . . , BK and w10, . . . , wKp need to be estimated from data."}
{"id": 277, "contributed_by": "group 3", "title": "", "section": "", "text": "In multi-task learning one can predict different responses simultaneously with a single network; they all have a say in the formation of the hidden layers."}
{"id": 278, "contributed_by": "group 3", "title": "", "section": "", "text": "There are numerous successes of RNNs in speech and language translation, forecasting, and document modeling."}
{"id": 279, "contributed_by": "group 3", "title": "", "section": "", "text": "One implication of the bias-variance trade-off is that it is generally not a good idea to interpolate the training data \u2014 that is, to get zero training error."}
{"id": 280, "contributed_by": "group 3", "title": "", "section": "", "text": "However, it turns out that in certain specific settings it can be possible for a statistical learning method that interpolates the training data to perform well \u2014 or at least, better than a slightly less complex model that does not quite interpolate the data. This phenomenon is known as double descent."}
{"id": 281, "contributed_by": "group 3", "title": "", "section": "", "text": "When we fit neural networks with a huge number of parameters, we are sometimes able to get good results with zero training error."}
{"id": 282, "contributed_by": "group 3", "title": "", "section": "", "text": "Though double descent can sometimes occur in neural networks, we typically do not want to rely on this behavior."}
{"id": 283, "contributed_by": "group 3", "title": "", "section": "", "text": "Often they give extremely impressive results, especially when the datasets are very large and can support the fitting of high-dimensional nonlinear models. However, if we can produce models with the simpler tools that perform as well, they are likely to be easier to fit and understand, and potentially less fragile than the more complex approaches."}
{"id": 284, "contributed_by": "group 3", "title": "", "section": "", "text": "Linear models are much easier to present and understand than the neural network, which is essentially a black box."}
{"id": 285, "contributed_by": "group 3", "title": "", "section": "", "text": "This shows the redundancy in the softmax function; for K classes we really only need to estimate K \u2212 1 sets of coefficients."}
{"id": 286, "contributed_by": "group 3", "title": "", "section": "", "text": "The Bayes error rate, which results from the optimal classifier."}
{"id": 287, "contributed_by": "group 3", "title": "", "section": "", "text": "Start with a guess \u03b80 for all the parameters in \u03b8, and set t = 0."}
{"id": 288, "contributed_by": "group 3", "title": "", "section": "", "text": "We could probably achieve slightly better results by changing the form and amount of regularization, and including additional hidden layers."}
{"id": 289, "contributed_by": "group 3", "title": "", "section": "", "text": "A convolution filter relies on a very simple operation, called a convolution, which basically amounts to repeatedly multiplying matrix elements and then adding the results."}
{"id": 290, "contributed_by": "group 3", "title": "", "section": "", "text": "There are a variety of ways to account for the document length; here we only score a word as in or out of the document."}
{"id": 291, "contributed_by": "group 3", "title": "", "section": "", "text": "SGD naturally enforces its own form of approximately quadratic regularization."}
{"id": 292, "contributed_by": "group 3", "title": "", "section": "", "text": "Linear models are much easier to present and understand than the neural network."}
{"id": 293, "contributed_by": "group 3", "title": "", "section": "", "text": "With long sequences, this overcomes the problem of early signals being washed out by the time they get propagated through the chain to the final activation vector AL."}
{"id": 294, "contributed_by": "group 3", "title": "", "section": "", "text": "This used to be called weight sharing in the early years of neural networks."}
{"id": 295, "contributed_by": "group 3", "title": "", "section": "", "text": "Many of the models that we enjoy in daily life (like Google Translate) use state-of-the-art architectures developed by teams of highly skilled engineers."}
{"id": 296, "contributed_by": "group 3", "title": "", "section": "", "text": "In theory a single hidden layer with a large number of units has the ability to approximate most functions."}
{"id": 297, "contributed_by": "group 3", "title": "", "section": "", "text": "This code can be impressively fast with certain special processors."}
{"id": 298, "contributed_by": "group 3", "title": "", "section": "", "text": "Although it is possible that if we were to spend more time, and got the form and amount of regularization just right, that we might be able to match or even outperform linear regression and the lasso."}
{"id": 299, "contributed_by": "group 3", "title": "", "section": "", "text": "Potentially less fragile than the more complex approaches."}
{"id": 300, "contributed_by": "group 3", "title": "", "section": "", "text": "The development of neural-network architectures to match human performance."}
{"id": 301, "contributed_by": "group 4", "title": "", "section": "", "text": "Thus far, this textbook has mostly focused on estimation and its close cousin, prediction. In this chapter, we instead focus on hypothesis testing, which is key to conducting inference. We remind the reader that inference was briefy discussed in Chapter 2. While Section 13.1 provides a brief review of null hypotheses, p-values, test statistics, and other key ideas in hypothesis testing, this chapter assumes that the reader has had previous exposure to these topics. In particular, we will not focus on why or how to conduct a hypothesis test  a topic on which entire books can be (and have been) written! Instead, we will assume that the reader is interested in testing some particular set of null hypotheses, and has a specifc plan in mind for how to conduct the tests and obtain p-values"}
{"id": 302, "contributed_by": "group 4", "title": "", "section": "", "text": " Much of the emphasis in classical statistics focuses on testing a single null hypothesis, such as H0: the expected blood pressure of mice in the control group equals the expected blood pressure of mice in the treatment group. Of course, we would probably like to discover that there is a diference between the mean blood pressure in the two groups. But for reasons that will become clear, we construct a null hypothesis corresponding to no diference. In contemporary settings, we are often faced with huge amounts of data, and consequently may wish to test a great many null hypotheses. For instance, rather than simply testing H0, we might want to test m null hypotheses, H01,...,H0m, where H0j : the expected value of the jth biomarker among mice in the control group equals the expected value of the jth biomarker among mice in the treatment group. When conducting multiple testing, we need to be very careful about how we interpret the results, in order to avoid erroneously rejecting far too many null hypotheses."}
{"id": 303, "contributed_by": "group 4", "title": "", "section": "", "text": " This chapter discusses classical as well as more contemporary ways to conduct multiple testing in a big-data setting. In Section 13.2, we highlight the challenges associated with multiple testing. Classical solutions to these Springer Nature Switzerland AG 2023 G. James et al., An Introduction to Statistical Learning, Springer Texts in Statistics, https://doi.org/10.1007/978-3-031-38747-0_13 557 558 13. Multiple Testing challenges are presented in Section 13.3, and more contemporary solutions in Sections 13.4 and 13.5. In particular, Section 13.4 focuses on the false discovery rate. The notion of the false discovery rate dates back to the 1990s. It quickly rose in popularity in the early 2000s, when large-scale data sets began to come out of genomics. These datasets were unique not only because of their large size,1 but also because they were typically collected for exploratory purposes: researchers collected these datasets in order to test a huge number of null hypotheses, rather than just a very small number of pre-specifed null hypotheses. Today, of course, huge datasets are collected without a pre-specifed null hypothesis across virtually all felds. As we will see, the     false discovery rate is perfectly-suited for this modern-day reality."}
{"id": 304, "contributed_by": "group 4", "title": "", "section": "", "text": " This chapter naturally centers upon the classical statistical technique of p-values, used to quantify the results of hypothesis tests. At the time of writing of this book (2020), p-values have recently been the topic of extensive commentary in the social science research community, to the extent that some social science journals have gone so far as to ban the use of p-values altogether! We will simply comment that when properly understood and applied, p-values provide a powerful tool for drawing inferential conclusions from our data. 13.1 A Quick Review of Hypothesis Testing Hypothesis tests provide a rigorous statistical framework for answering simple yes-or-no questions about data, such as the following: 1. Is the true coefcient j in a linear regression of Y onto X1,...,Xp equal to zero?2 2. Is there a diference in the expected blood pressure of laboratory mice in the control group and laboratory mice in the treatment group?3 In Section 13.1.1, we briefy review the steps involved in hypothesis testing. Section 13.1.2 discusses the diferent types of mistakes, or errors, that can occur in hypothesis testing."}
{"id": 305, "contributed_by": "group 4", "title": "", "section": "", "text": " Testing a Hypothesis Conducting a hypothesis test typically proceeds in four steps. First, we defne the null and alternative hypotheses. Next, we construct a test statistic that summarizes the strength of evidence against the null hypothesis. We then compute a p-value that quantifes the probability of having obtained 1Microarray data was viewed as big data at the time, although by todays standards, this label seems quaint: a microarray dataset can be (and typically was) stored in a Microsoft Excel spreadsheet! 2This hypothesis test was discussed on page 76 of Chapter 3. 3The treatment group refers to the set of mice that receive an experimental treatment, and the control group refers to those that do not. 13.1 A Quick Review of Hypothesis Testing 559 a comparable or more extreme value of the test statistic under the null hypothesis. Finally, based on the p-value, we decide whether to reject the null hypothesis. We now briefy discuss each of these steps in turn"}
{"id": 306, "contributed_by": "group 4", "title": "", "section": "", "text": " In hypothesis testing, we divide the world into two possibilities: the null hypothesis and the alternative hypothesis. The null hypothesis, denoted H0, null hypothesis alternative hypothesis is the default state of belief about the world.4 For instance, null hypotheses associated with the two questions posed earlier in this chapter are as follows: 1. The true coefcient j in a linear regression of Y onto X1,...,Xp equals zero. 2. There is no diference between the expected blood pressure of mice in the control and treatment groups. The null hypothesis is boring by construction: it may well be true, but we might hope that our data will tell us otherwise. The alternative hypothesis, denoted Ha, represents something diferent and unexpected: for instance, that there is a diference between the expected blood pressure of the mice in the two groups. Typically, the alternative hypothesis simply posits that the null hypothesis does not hold: if the null hypothesis states that there is no diference between A and B, then the alternative hypothesis states that there is a diference between A and B."}
{"id": 307, "contributed_by": "group 4", "title": "", "section": "", "text": "It is important to note that the treatment of H0 and Ha is asymmetric. H0 is treated as the default state of the world, and we focus on using data to reject H0. If we reject H0, then this provides evidence in favor of Ha. We can think of rejecting H0 as making a discovery about our data: namely, we are discovering that H0 does not hold! By contrast, if we fail to reject H0, then our fndings are more nebulous: we will not know whether we failed to reject H0 because our sample size was too small (in which case testing H0 again on a larger or higher-quality dataset might lead to rejection), or whether we failed to reject H0 because H0 really holds. Step 2: Construct the Test Statistic Next, we wish to use our data in order to fnd evidence for or against the null hypothesis. In order to do this, we must compute a test statistic, test statistic denoted T, which summarizes the extent to which our data are consistent with H0. The way in which we construct T depends on the nature of the null hypothesis that we are testing."}
{"id": 308, "contributed_by": "group 4", "title": "", "section": "", "text": "The distribution of the test statistic under H0 (also known as the test statistics null distribution) will depend on the details of what type of null distribution null hypothesis is being tested, and what type of test statistic is used. In general, most commonly-used test statistics follow a well-known statistical distribution under the null hypothesis  such as a normal distribution, a t-distribution, a 2-distribution, or an F-distribution  provided that the sample size is sufciently large and that some other assumptions hold. Typically, the R function that is used to compute a test statistic will make use of this null distribution in order to output a p-value. In Section 13.5, we will see an approach to estimate the null distribution of a test statistic using re-sampling; in many contemporary settings, this is a very attractive option, as it exploits the availability of fast computers in order to avoid having to make potentially problematic assumptions about the data. The p-value is perhaps one of the most used and abused notions in all of statistics. In particular, it is sometimes said that the p-value is the probability that H0 holds, i.e., that the null hypothesis is true. This is not correct! The one and only correct interpretation of the p-value is as the fraction of the time that we would expect to see such an extreme value of the test statistic8 if we repeated the experiment many many times, provided H0 holds."}
{"id": 309, "contributed_by": "group 4", "title": "", "section": "", "text": "In Step 2 we computed a test statistic, and noted that a large (absolute) value of the test statistic provides evidence against H0. In Step 3 the test statistic was converted to a p-value, with small p-values providing evidence against H0. What, then, did we accomplish by converting the test statistic from Step 2 into a p-value in Step 3? To answer this question, suppose a data analyst conducts a statistical test, and reports a test statistic of T = 17.3. Does this provide strong evidence against H0? Its impossible to know, without more information: in particular, we would need to know 7More precisely, assuming that the observations are drawn from a normal distribution, then T follows a t-distribution with nt + nc slash   2 degrees of freedom. Provided that nt + nc slash   2 is larger than around 40, this is very well-approximated by a N(0, 1) distribution. In Section 13.5, we will see an alternative and often more attractive way to approximate the null distribution of T, which avoids making stringent assumptions about the data. 8A one-sided p-value is the probability of seeing such an extreme value of the test statistic; e.g. the probability of seeing a test statistic greater than or equal to T = 2.33. A two-sided p-value is the probability of seeing such an extreme value of the absolute test statistic;"}
{"id": 310, "contributed_by": "group 4", "title": "", "section": "", "text": "Once we have computed a p-value corresponding to H0, it remains for us to decide whether or not to reject H0. (We do not usually talk about accepting H0: instead, we talk about failing to reject H0.) A small pvalue indicates that such a large value of the test statistic is unlikely to occur under H0, and thereby provides evidence against H0. If the p-value is sufciently small, then we will want to reject H0 (and, therefore, make a     ). But how small is small enough to reject H0? It turns out that the answer to this question is very much in the eyes of the beholder, or more specifcally, the data analyst. The smaller the pvalue, the stronger the evidence against H0. In some felds, it is typical to reject H0 if the p-value is below 0.05; this means that, if H0 holds, we would expect to see such a small p-value no more than 5% of the time.9 However, in other felds, a much higher burden of proof is required: for example, in some areas of physics, it is typical to reject H0 only if the p-value is below 10slash  9! In the example displayed in Figure 13.1, if we use a threshold of 0.05 as our cut-of for rejecting the null hypothesis, then we will reject the null. By contrast, if we use a threshold of 0.01, then we will fail to reject the null. These ideas are formalized in the next section."}
{"id": 311, "contributed_by": "group 4", "title": "", "section": "", "text": "In the previous section, we saw that rejecting H0 if the p-value is below (say) 0.01 provides us with a simple way to control the Type I error for H0 at level 0.01: if H0 is true, then there is no more than a 1% probability that we will reject it. But now suppose that we wish to test m null hypotheses, H01,...,H0m. Will it do to simply reject all null hypotheses for which the corresponding p-value falls below (say) 0.01? Stated another way, if we reject all null hypotheses for which the p-value falls below 0.01, then how many Type I errors should we expect to make? As a frst step towards answering this question, consider a stockbroker who wishes to drum up new clients by convincing them of her trading 10There are parallels between Table 13.1 and Table 4.6, which has to do with the output of a binary classifer. In particular, recall from Table 4.6 that a false positive results from predicting a positive (non-null) label when the true label is in fact negative (null). This is closely related to a Type I error, which results from rejecting the null hypothesis when in fact the null hypothesis holds. 564 13. Multiple Testing acumen. She tells 1,024 (1,024 = 210) potential new clients that she can correctly predict whether Apples stock price will increase or decrease for 10"}
{"id": 312, "contributed_by": "group 4", "title": "", "section": "", "text": "What happened here? Does the stockbroker have any actual insight into whether Apples stock price will increase or decrease? No. How, then, did she manage to predict Apples stock price perfectly for 10 days running? The answer is that she made a lot of guesses, and one of them happened to be exactly right. How does this relate to multiple testing? Suppose that we fip 1,024 fair coins11 ten times each. Then we would expect (on average) one coin to come up all tails. (Theres a 1/210 = 1/1,024 chance that any single coin will come up all tails. So if we fip 1,024 coins, then we expect one coin to come up all tails, on average.) If one of our coins comes up all tails, then we might therefore conclude that this particular coin is not fair. In fact, a standard hypothesis test for the null hypothesis that this particular coin is fair would lead to a p-value below 0.002! 12 But it would be incorrect to conclude that the coin is not fair: in fact, the null hypothesis holds, and we just happen to have gotten ten tails in a row by chance."}
{"id": 313, "contributed_by": "group 4", "title": "", "section": "", "text": "These examples illustrate the main challenge of multiple testing: when multiple testing testing a huge number of null hypotheses, we are bound to get some very small p-values by chance. If we make a decision about whether to reject each null hypothesis without accounting for the fact that we have performed a very large number of tests, then we may end up rejecting a great number of true null hypotheses  that is, making a large number of Type I errors. How severe is the problem? Recall from the previous section that if we reject a single null hypothesis, H0, if its p-value is less than, say,  = 0.01, then there is a 1% chance of making a false rejection if H0 is in fact true. Now what if we test m null hypotheses, H01,...,H0m, all of which are true? Theres a 1% chance of rejecting any individual null hypothesis; therefore, we expect to falsely reject approximately 0.01  m null hypotheses. If m = 10,000, then that means that we expect to falsely reject 100 null hypotheses by chance! That is a lot of Type I errors. The crux of the issue is as follows: rejecting a null hypothesis if the p-value is below  controls the probability of falsely rejecting that null hypothesis at level . However, if we do this for m null hypotheses, then the chance of falsely rejecting at least one of the m null hypotheses is quite a bit higher!"}
{"id": 314, "contributed_by": "group 4", "title": "", "section": "", "text": "Hence, if we test only one null hypothesis, then FWER()=1slash  (1slash  )1 = , so the Type I error rate and the FWER are equal. However, if we perform m = 100 independent tests, then FWER()=1 slash   (1 slash   )100. For instance, taking  = 0.05 leads to a FWER of 1 slash   (1 slash   0.05)100 = 0.994. In other words, we are virtually guaranteed to make at least one Type I error! Figure 13.2 displays (13.5) for various values of m, the number of hypotheses, and , the Type I error. We see that setting  = 0.05 results in a high FWER even for moderate m. With  = 0.01, we can test no more than fve null hypotheses before the FWER exceeds 0.05. Only for very small values, such as  = 0.001, do we manage to ensure a small FWER, at least for moderately-sized m. We now briefy return to the example in Section 13.1.1, in which we consider testing a single null hypothesis of the form H0 : t = c using a two-sample t-statistic. Recall from Figure 13.1 that in order to guarantee that the Type I error does not exceed 0.02, we decide whether or not to reject H0 using a cutpoint of 2.33 (i.e. we reject H0 if |T|  2.33). Now,"}
{"id": 315, "contributed_by": "group 4", "title": "", "section": "", "text": "TABLE 13.3. The frst two columns correspond to the sample mean and sample standard deviation of the percentage excess return, over n = 50 months, for the frst fve managers in the Fund dataset. The last two columns provide the t-statistic ( n  X/S ) and associated p-value for testing H0j : j = 0, the null hypothesis that the (population) mean return for the jth hedge fund manager equals zero. 13.3.2 Approaches to Control the Family-Wise Error Rate In this section, we briefy survey some approaches to control the FWER. We will illustrate these approaches on the Fund dataset, which records the monthly percentage excess returns for 2,000 fund managers over n = 50 months.13 Table 13.3 provides relevant summary statistics for the frst fve managers. We frst present the Bonferroni method and Holms step-down procedure, which are very general-purpose approaches for controlling the FWER that can be applied whenever m p-values have been computed, regardless of the form of the null hypotheses, the choice of test statistics, or the (in)dependence of the p-values. We then briefy discuss Tukeys method and Schefs method in order to illustrate the fact that, in certain situations, more specialized approaches for controlling the FWER may be preferable."}
{"id": 316, "contributed_by": "group 4", "title": "", "section": "", "text": "As in the previous section, suppose we wish to test H01,...,H0m. Let Aj denote the event that we make a Type I error for the jth null hypothesis, for j = 1,...,m. Then FWER = Pr(falsely reject at least one null hypothesis) = Pr(m j=1Aj ) 0m j=1 Pr(Aj ). (13.6) In (13.6), the inequality results from the fact that for any two events A and B, Pr(A  B) Pr(A) + Pr(B), regardless of whether A and B are independent. The Bonferroni method, or Bonferroni correction, sets the threshold for rejecting each hypothesis test to /m, so that Pr(Aj ) /m. Equation 13.6 implies that FWER(/m) m   m = , 13Excess returns correspond to the additional return the fund manager achieves beyond the markets overall return. So if the market increases by 5% during a given period and the fund manager achieves a 7% return, their excess return would be 7% slash   5% = 2%. 568 13. Multiple Testing so this procedure controls the FWER at level . For instance, in order to control the FWER at level 0.1 while testing m = 100 null hypotheses, the Bonferroni procedure requires us to control the Type I error for each null hypothesis at level 0.1/100 = 0.001, i.e. to reject all null hypotheses for which the p-value is below 0.001. We now consider the Fund dataset"}
{"id": 317, "contributed_by": "group 4", "title": "", "section": "", "text": "We now consider applying Holms method to the frst fve fund managers in the Fund dataset in Table 13.3, while controlling the FWER at level 0.05. The ordered p-values are p(1) = 0.006, p(2) = 0.012, p(3) = 0.601, p(4) = 0.756 and p(5) = 0.918. The Holm procedure rejects the frst two null hypotheses, because p(1) = 0.006 < 0.05/(5 + 1 slash   1) = 0.01 and p(2) = 0.012 < 0.05/(5 + 1 slash   2) = 0.0125, but p(3) = 0.601 > 0.05/(5 + 1 slash   3) = 0.0167, which implies that L = 3. We note that, in this setting, Holm is more powerful than Bonferroni: the former rejects the null hypotheses for the frst and third managers, whereas the latter rejects the null hypothesis only for the frst manager. Figure 13.3 provides an illustration of the Bonferroni and Holm methods on three simulated data sets in a setting involving m = 10 hypothesis tests, of which m0 = 2 of the null hypotheses are true. Each panel displays the ten corresponding p-values, ordered from smallest to largest, and plotted on a log scale. The eight red points represent the false null hypotheses, and the two black points represent the true null hypotheses. We wish to control the FWER at level 0.05. The Bonferroni procedure requires us to reject all null"}
{"id": 318, "contributed_by": "group 4", "title": "", "section": "", "text": "Two Special Cases: Tukeys Method and Schefs Method Bonferronis method and Holms method can be used in virtually any setting in which we wish to control the FWER for m null hypotheses: they 570 13. Multiple Testing 2 4 6 8 10 1eslash  05 1eslash  04 1eslash  03 1eslash  02 1eslash  01 Ordering of pslash  values pslash  values (log scale) 2 4 6 8 10 1eslash  07 1eslash  05 1eslash  03 1eslash  01 Ordering of pslash  values pslash  values (log scale) 2 4 6 8 10 1eslash  05 1eslash  04 1eslash  03 1eslash  02 1eslash  01 Ordering of pslash  values pslash  values (log scale) FIGURE 13.3. Each panel displays, for a separate simulation, the sorted p-values for tests of m = 10 null hypotheses. The p-values corresponding to the m0 = 2 true null hypotheses are displayed in black, and the rest are in red. When controlling the FWER at level 0.05, the Bonferroni procedure rejects all null hypotheses that fall below the black line, and the Holm procedure rejects all null hypotheses that fall below the blue line. The region between the blue and black lines indicates null hypotheses that are rejected using the Holm procedure but not using the Bonferroni procedure. In the center panel, the Holm procedure"}
{"id": 319, "contributed_by": "group 4", "title": "", "section": "", "text": "Schefs method is designed for exactly this setting. It allows us to com- Schefs method pute a value S such that rejecting the null hypothesis H0 in (13.8) if the p-value is below S will control the Type I error at level . It turns out that for the Fund example, in order to control the Type I error at level  = 0.05, we must set S = 0.002. Therefore, we are unable to reject H0 in (13.8), despite the apparently very small p-value of 0.004. An important advantage of Schefs method is that we can use this same threshold of S = 0.002 in order to perform a pairwise comparison of any split of the managers into two groups: for instance, we could also test H0 : 1 3 (1 + 2 + 3) = 1 2 (4 + 5) and H0 : 1 4 (1 + 2 + 3 + 4) = 5 using the same threshold of 0.002, without needing to further adjust for multiple testing. To summarize, Holms procedure and Bonferronis procedure are very general approaches for multiple testing correction that can be applied under all circumstances. However, in certain special cases, more powerful procedures for multiple testing correction may be available, in order to control the FWER while achieving higher power (i.e. committing fewer Type II errors) than would be possible using Holm or Bonferroni. In this section, we have illustrated two such examples."}
{"id": 320, "contributed_by": "group 4", "title": "", "section": "", "text": "In general, there is a trade-of between the FWER threshold that we choose, and our power to reject the null hypotheses. Recall that power is defned as the number of false null hypotheses that we reject divided by the total number of false null hypotheses, i.e. S/(m slash   m0) using the notation of Table 13.2. Figure 13.5 illustrates the results of a simulation setting involving m null hypotheses, of which 90% are true and the remaining 10% are false; power is displayed as a function of the FWER. In this particular simulation setting, when m = 10, a FWER of 0.05 corresponds to power of approximately 60%. However, as m increases, the power decreases. With m = 500, the power is below 0.2 at a FWER of 0.05, so that we successfully reject only 20% of the false null hypotheses. Figure 13.5 indicates that it is reasonable to control the FWER when m takes on a small value, like 5 or 10. However, for m = 100 or m = 1,000, attempting to control the FWER will make it almost impossible to reject any of the false null hypotheses. In other words, the power will be extremely low. Why is this the case? Recall that, using the notation in Table 13.2, the FWER is defned as Pr(V  1) (13.3). In other other words, controlling the FWER at"}
{"id": 321, "contributed_by": "group 4", "title": "", "section": "", "text": "As we just discussed, when m is large, then trying to prevent any false positives (as in FWER control) is simply too stringent. Instead, we might try to make sure that the ratio of false positives (V ) to total positives (V + S = R) is sufciently low, so that most of the rejected null hypotheses are not false positives. The ratio V /R is known as the false discovery proportion false discovery proportion (FDP). It might be tempting to ask the data analyst to control the FDP: to make sure that no more than, say, 20% of the rejected null hypotheses are false positives. However, in practice, controlling the FDP is an impossible task for the data analyst, since she has no way to be certain, on any particular dataset, which hypotheses are true and which are false. This is very similar to the fact that the data analyst can control the FWER, i.e. she can guarantee that Pr(V  1)  for any pre-specifed , but she cannot guarantee that V = 0 on any particular dataset (short of failing to reject any null hypotheses, i.e. setting R = 0)."}
{"id": 322, "contributed_by": "group 4", "title": "", "section": "", "text": "When we control the FDR at (say) level q = 20%, we are rejecting as many null hypotheses as possible while guaranteeing that no more than 20% of those rejected null hypotheses are false positives, on average. In the defnition of the FDR in (13.9), the expectation is taken over the population from which the data are generated. For instance, suppose we control the FDR for m null hypotheses at q = 0.2. This means that if we repeat this experiment a huge number of times, and each time control the FDR at q = 0.2, then we should expect that, on average, 20% of the rejected null hypotheses will be false positives. On a given dataset, the fraction of false positives among the rejected hypotheses may be greater than or less than 20%."}
{"id": 323, "contributed_by": "group 4", "title": "", "section": "", "text": "It is worth noting that unlike p-values, for which a threshold of 0.05 is typically viewed as the minimum standard of evidence for a positive result, and a threshold of 0.01 or even 0.001 is viewed as much more compelling, there is no standard accepted threshold for FDR control. Instead, the choice of FDR threshold is typically context-dependent, or even datasetdependent. For instance, the genomic researcher in the previous example might seek to control the FDR at a threshold of 10% if the planned follow15If R = 0, then we replace the ratio V /R with 0, to avoid computing 0/0. Formally, FDR = E(V /R|R > 0) Pr(R > 0). 13.4 The False Discovery Rate 575 up analysis is time-consuming or expensive. Alternatively, a much larger threshold of 30% might be suitable if she plans an inexpensive follow-up analysis. 13.4.2 The Benjamini Hochberg Procedure We now focus on the task of controlling the FDR: that is, deciding which null hypotheses to reject while guaranteeing that the FDR, E(V /R), is less than or equal to some pre-specifed value q. In order to do this, we need some way to connect the p-values, p1,...,pm, from the m null hypotheses to the desired FDR value, q. It turns out that a very simple procedure, outlined in Algorithm 13.2, can be used to control the FDR."}
{"id": 324, "contributed_by": "group 4", "title": "", "section": "", "text": "Algorithm 13.2 is known as the Benjamini Hochberg procedure. The crux Benjamini  Hochberg procedure of this procedure lies in (13.10). For example, consider again the frst fve managers in the Fund dataset, presented in Table 13.3. (In this example, m = 5, although typically we control the FDR in settings involving a much greater number of null hypotheses.) We see that p(1) = 0.006 < 0.05  1/5, p(2) = 0.012 < 0.05  2/5, p(3) = 0.601 > 0.05  3/5, p(4) = 0.756 > 0.05  4/5, and p(5) = 0.918 > 0.05  5/5. Therefore, to control the FDR at 5%, we reject the null hypotheses that the frst and third fund managers perform no better than chance. As long as the m p-values are independent or only mildly dependent, then the Benjamini Hochberg procedure guarantees16 that FDR q. In other words, this procedure ensures that, on average, no more than a fraction q of the rejected null hypotheses are false positives. Remarkably, this holds regardless of how many null hypotheses are true, and regardless of the distribution of the p-values for the null hypotheses that are false. Therefore, the Benjamini Hochberg procedure gives us a very easy way to determine, given a set of m p-values, which null hypotheses to reject in order to control the FDR at any pre-specifed level q."}
{"id": 325, "contributed_by": "group 4", "title": "", "section": "", "text": "There is a fundamental diference between the Bonferroni procedure of Section 13.3.2 and the Benjamini Hochberg procedure. In the Bonferroni procedure, in order to control the FWER for m null hypotheses at level , we must simply reject null hypotheses for which the p-value is below /m. This threshold of /m does not depend on anything about the data (beyond the value of m), and certainly does not depend on the p-values themselves. By contrast, the rejection threshold used in the Benjamini  Hochberg procedure is more complicated: we reject all null hypotheses for which the p-value is less than or equal to the Lth smallest p-value, where L is itself a function of all m p-values, as in (13.10). Therefore, when conducting the Benjamini Hochberg procedure, we cannot plan out in advance what threshold we will use to reject p-values; we need to frst see our data. For instance, in the abstract, there is no way to know whether we will reject a null hypothesis corresponding to a p-value of 0.01 when using an FDR threshold of 0.1 with m = 100; the answer depends on the values of the other m slash   1 p-values. This property of the Benjamini Hochberg procedure is shared by the Holm procedure, which also involves a data-dependent p-value threshold."}
{"id": 326, "contributed_by": "group 4", "title": "", "section": "", "text": "Thus far, the discussion in this chapter has assumed that we are interested in testing a particular null hypothesis H0 using a test statistic T, which has some known (or assumed) distribution under H0, such as a normal distribution, a t-distribution, a 2-distribution, or an F-distribution. This is referred to as the theoretical null distribution. We typically rely upon theoretical null distribution the availability of a theoretical null distribution in order to obtain a pvalue associated with our test statistic. "}
{"id": 327, "contributed_by": "group 4", "title": "", "section": "", "text": "Indeed, for most of the types of null hypotheses that we might be interested in testing, a theoretical null distribution is available, provided that we are willing to make stringent assumptions about our data. However, if our null hypothesis H0 or test statistic T is somewhat unusual, then it may be the case that no theoretical null distribution is available. Alternatively, even if a theoretical null distribution exists, then we may be wary of relying upon it, perhaps because some assumption that is required for it to hold is violated. For instance, maybe the sample size is too small."}
{"id": 328, "contributed_by": "group 4", "title": "", "section": "", "text": " In this section, we present a framework for performing inference in this setting, which exploits the availability of fast computers in order to approximate the null distribution of T, and thereby to obtain a p-value. While this framework is very general, it must be carefully instantiated for a specifc problem of interest. Therefore, in what follows, we consider a specifc example in which we wish to test whether the means of two random variables are equal, using a two-sample t-test. The discussion in this section is more challenging than the preceding sections in this chapter, and can be safely skipped by a reader who is content to use the theoretical null distribution to compute p-values for his or her test statistics."}
{"id": 329, "contributed_by": "group 4", "title": "", "section": "", "text": "We try out this procedure on the Khan dataset, which consists of expression measurements for 2,308 genes in four sub-types of small round blood cell tumors, a type of cancer typically seen in children. This dataset is part of the ISLR2 package. We restrict our attention to the two sub-types for which the most observations are available: rhabdomyosarcoma (nX = 29) and Burkitts lymphoma (nY = 25)."}
{"id": 330, "contributed_by": "group 4", "title": "", "section": "", "text": "A two-sample t-test for the null hypothesis that the 11th genes mean expression values are equal in the two groups yields T = slash  2.09. Using the theoretical null distribution, which is a t52 distribution (since nX + nY slash   2 = 52), we obtain a p-value of 0.041. (Note that a t52 distribution is virtually indistinguishable from a N(0, 1) distribution.) If we instead apply Algorithm 13.3 with B = 10,000, then we obtain a p-value of 0.042. Figure 13.7 displays the theoretical null distribution, the re-sampling null distribution, and the actual value of the test statistic (T = slash  2.09) for this gene. In this example, we see very little diference between the p-values obtained using the theoretical null distribution and the re-sampling null distribution."}
{"id": 331, "contributed_by": "group 4", "title": "", "section": "", "text": "By contrast, Figure 13.8 shows an analogous set of results for the 877th gene. In this case, there is a substantial diference between the theoretical and re-sampling null distributions, which results in a diference between their p-values. In general, in settings with a smaller sample size or a more skewed data distribution (so that the theoretical null distribution is less accurate), the diference between the re-sampling and theoretical p-values will tend to be more pronounced. In fact, the substantial diference between the resampling and theoretical null distributions in Figure 13.8 is due to the fact that a single observation in the 877th gene is very far from the other observations, leading to a very skewed distribution. "}
{"id": 332, "contributed_by": "group 4", "title": "", "section": "", "text": " approximated the null distribution via a re-sampling approach. We saw that using the re-sampling approach gave us substantially diferent results from using the theoretical p-value approach in Figure 13.8, but not in Figure 13.7. In general, there are two settings in which a re-sampling approach is particularly useful: 1. Perhaps no theoretical null distribution is available. This may be the case if you are testing an unusual null hypothesis H0, or using an unsual test statistic T. 2. Perhaps a theoretical null distribution is available, but the assumptions required for its validity do not hold. For instance, the twosample t-statistic in (13.11) follows a tnX+nY slash  2 distribution only if the observations are normally distributed. Furthermore, it follows a N(0, 1) distribution only if nX and nY are quite large. If the data are non-normal and nX and nY are small, then p-values that make use of the theoretical null distribution will not be valid (i.e. they will not properly control the Type I error). "}
{"id": 333, "contributed_by": "group 4", "title": "", "section": "", "text": "In general, if you can come up with a way to re-sample or permute your observations in order to generate data that follow the null distribution, then you can compute p-values or estimate the FDR using variants of Algorithms 13.3 and 13.4. In many real-world settings, this provides a powerful tool for hypothesis testing when no out-of-box hypothesis tests are available, or when the key assumptions underlying those out-of-box tests are violated."}
{"id": 334, "contributed_by": "group 4", "title": "", "section": "", "text": "We are not interested in prediction, because we do not have an associated response variable Y. Rather, the goal is to discover interesting things about the measurements on X1, X2,...,Xp. Is there an informative way to visualize the data? Can we discover subgroups among the variables or among the observations? Unsupervised learning refers to a diverse set of techniques for answering questions such as these."}
{"id": 335, "contributed_by": "group 4", "title": "", "section": "", "text": "In the supervised learning setting, we typically have access to a set of p features X1, X2,...,Xp, measured on n observations, and a response Y also measured on those same n observations. The goal is then to predict Y using X1, X2,...,Xp. on unsupervised learning, a set of statistical tools intended for the setting in which we have only a set of features X1, X2,...,Xp measured on n observations."}
{"id": 336, "contributed_by": "group 4", "title": "", "section": "", "text": "Unsupervised learning is often performed as part of an exploratory data analysis. Furthermore, it can be hard to assess the results obtained from unsupervised learning methods, since there is no universally accepted mechanism for performing cross-validation or validating results on an independent data set."}
{"id": 337, "contributed_by": "group 4", "title": "", "section": "", "text": "Since clustering is popular in many felds, there exist a great number of clustering methods. In this section we focus on perhaps the two best-known clustering approaches: K-means clustering and hierarchical clustering."}
{"id": 338, "contributed_by": "group 4", "title": "", "section": "", "text": "Clustering refers to a very broad set of techniques for fnding subgroups, or clustering clusters, in a data set. When we cluster the observations of a data set, we seek to partition them into distinct groups so that the observations within each group are quite similar to each other, while observations in diferent groups are quite diferent from each other. Of course, to make this concrete, we must defne what it means for two or more observations to be similar or diferent. Indeed, this is often a domain-specifc consideration that must be made based on knowledge of the data being studied."}
{"id": 339, "contributed_by": "group 4", "title": "", "section": "", "text": "For instance, suppose that we have a set of n observations, each with p features. The n observations could correspond to tissue samples for patients with breast cancer, and the p features could correspond to measurements collected for each tissue sample; these could be clinical measurements, such as tumor stage or grade, or they could be gene expression measurements. We may have a reason to believe that there is some heterogeneity among the n tissue samples; for instance, perhaps there are a few diferent un- known subtypes of breast cancer. Clustering could be used to fnd these subgroups. This is an unsupervised problem because we are trying to dis- cover structurein this case, distinct clusterson the basis of a data set. The goal in supervised problems, on the other hand, is to try to predict some outcome vector such as survival time or response to drug treatment."}
{"id": 340, "contributed_by": "group 4", "title": "", "section": "", "text": "suppose that most of the observations truly belong to a small number of (unknown) subgroups, and a small subset of the observations are quite diferent from each other and from all other observations. Then since Kmeans and hierarchical clustering force every observation into a cluster, the clusters found may be heavily distorted due to the presence of outliers that do not belong to any cluster. Mixture models are an attractive approach for accommodating the presence of such outliers."}
{"id": 341, "contributed_by": "group 4", "title": "", "section": "", "text": "One potential disadvantage of K-means clustering is that it requires us to pre-specify the number of clusters K. Hierarchical clustering is an alternative approach which does not require that we commit to a particular choice of K. Hierarchical clustering has an added advantage over K-means clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram"}
{"id": 342, "contributed_by": "group 4", "title": "", "section": "", "text": "PCA provides a tool to do just this. It fnds a low-dimensional representation of a data set that contains as much as possible of the variation. The idea is that each of the n observations lives in p-dimensional space, but not all of these dimensions are equally interesting. PCA seeks a small number of dimensions that are as interesting as possible, where the concept of interesting is measured by the amount that the observations vary along each dimension."}
{"id": 343, "contributed_by": "group 4", "title": "", "section": "", "text": "The frst principal component of a set of features X1, X2,...,Xp is the normalized linear combination of the features that has the largest variance."}
{"id": 344, "contributed_by": "group 4", "title": "", "section": "", "text": "Given an n  p data set X, how do we compute the frst principal component? Since we are only interested in variance, we assume that each of the variables in X has been centered to have mean zero (that is, the column means of X are zero). We then look for the linear combination of the sample feature values that has largest sample variance"}
{"id": 345, "contributed_by": "group 4", "title": "", "section": "", "text": "Once we have computed the princ 4,cipal components, we can plot them against each other in order to produce low-dimensional views of the data. For instance, we can plot the score vector Z1 against Z2, Z1 against Z3, Z2 against Z3, and so forth. Geometrically, this amounts to projecting the original data down onto the subspace spanned by 1, 2, and 3, and plotting the projected points."}
{"id": 346, "contributed_by": "group 4", "title": "", "section": "", "text": "The frst principal component loading vector has a very special property it is the line in p-dimensional space that is closest to the n observation (using average squared Euclidean distance as a measure of closeness). Thi interpretation can be seen in the left-hand panel of Figure 6.15; the dashe lines indicate the distance between each observation and the line defne by the frst principal component loading vector."}
{"id": 347, "contributed_by": "group 4", "title": "", "section": "", "text": "The notion of principal components as the dimensions that are closest to the n observations extends beyond just the frst principal component. For instance, the frst two principal components of a data set span the plane that is closest to the n observations, in terms of average squared Euclidean distance."}
{"id": 348, "contributed_by": "group 4", "title": "", "section": "", "text": "We can now ask a natural question: how much of the information in a given data set is lost by projecting the observations onto the frst few principal components? That is, how much of the variance in the data is not contained in the frst few principal components? More generally, we are interested in knowing the proportion of variance explained (PVE) by each principal component."}
{"id": 349, "contributed_by": "group 4", "title": "", "section": "", "text": "In the USArrests data, the frst principal component explains 62.0 % of the variance in the data, and the next principal component explains 24.7 % of the variance. Together, the frst two principal components explain almost 87 % of the variance in the data, and the last two principal components explain only 13 % of the variance. This means that Figure 12.1 provides a pretty accurate summary of the data using just two dimensions."}
{"id": 350, "contributed_by": "group 4", "title": "", "section": "", "text": "In Figure 12.2, we performed PCA on a three-dimensional data set (lefthand panel) and projected the data onto the frst two principal component loading vectors in order to obtain a two-dimensional view of the data (i.e. the principal component score vectors; right-hand panel). We see that this two-dimensional representation of the three-dimensional data does successfully capture the major pattern in the data: the orange, green, and cyan observations that are near each other in three-dimensional space remain nearby in the two-dimensional representation."}
{"id": 351, "contributed_by": "group 4", "title": "", "section": "", "text": "We typically decide on the number of principal components required to visualize the data by examining a scree plot, such as the one shown in the left-hand panel of Figure 12.3. We choose the smallest number of principal components that are required in order to explain a sizable amount of the variation in the data."}
{"id": 352, "contributed_by": "group 4", "title": "", "section": "", "text": "We could remove the rows that contain missing observations and perform our data analysis on the complete rows. But this seems wasteful, and depending on the fraction missing, unrealistic. Alternatively, if xij is missing, then we could replace it by the mean of the jth column (using the non-missing entries to compute the mean). "}
{"id": 353, "contributed_by": "group 4", "title": "", "section": "", "text": "This approach for imputing missing data is appropriate if the missingness is random. For example, it is suitable if a patients weight is missing because missing at the battery of the electronic scale was fat at the time of his exam. By random contrast, if the weight is missing because the patient was too heavy to climb on the scale, then this is not missing at random; the missingness is 516 12. Unsupervised Learning informative, and the approach described here for handling missing data is not suitable."}
{"id": 354, "contributed_by": "group 4", "title": "", "section": "", "text": "In K-means clustering, we seek to partition the observations into a pre-specifed number of clusters. On the other hand, in hierarchical clustering, we do not know in advance how many clusters we want; in fact, we end up with a tree-like visual representation of the observations, called a dendrogram, that allows us to view at once the clusterings obtained for each possible number of clusters, from 1 to n."}
{"id": 355, "contributed_by": "group 4", "title": "", "section": "", "text": "In general, we can cluster observations on the basis of the features in order to identify subgroups among the observations, or we can cluster features on the basis of the observations in order to discover subgroups among the features."}
{"id": 356, "contributed_by": "group 4", "title": "", "section": "", "text": "A simulated data set with 150 observations in two-dimensional space. Panels show the results of applying K-means clustering with diferent values of K, the number of clusters. The color of each observation indicates the cluster to which it was assigned using the K-means clustering algorithm. Note that there is no ordering of the clusters, so the cluster coloring is arbitrary. These cluster labels were not used in clustering; instead, they are the outputs of the clustering procedure"}
{"id": 357, "contributed_by": "group 4", "title": "", "section": "", "text": "To perform K-means clustering, we must frst specify the desired number of clusters K; then the K-means algorithm will assign each observation to exactly one of the K clusters. Figure 12.7 shows the results obtained from performing K-means clustering on a simulated example consisting of 150 observations in two dimensions, using three diferent values of K"}
{"id": 358, "contributed_by": "group 4", "title": "", "section": "", "text": "In Step 2(a) the cluster means for each feature are the constants that minimize the sum-of-squared deviations, and in Step 2(b), reallocating the observations can only improve (12.18). This means that as the algorithm is run, the clustering obtained will continually improve until the result no longer changes; the objective of (12.17) will never increase. When the result no longer changes, a local optimum has been reached."}
{"id": 359, "contributed_by": "group 4", "title": "", "section": "", "text": "Because the K-means algorithm fnds a local rather than a global optimum, the results obtained will depend on the initial (random) cluster assignment of each observation in Step 1 of Algorithm 12.2. For this reason, it is important to run the algorithm multiple times from diferent random initial confgurations."}
{"id": 360, "contributed_by": "group 4", "title": "", "section": "", "text": "Hierarchical clustering is an alternative approach which does not require that we commit to a particular choice of K. Hierarchical clustering has an added advantage over K-means clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram."}
{"id": 361, "contributed_by": "group 4", "title": "", "section": "", "text": "This highlights a very important point in interpreting dendrograms that is often misunderstood. Consider the left-hand panel of Figure 12.12, which shows a simple dendrogram obtained from hierarchically clustering nine observations. One can see that observations 5 and 7 are quite similar to each other, since they fuse at the lowest point on the dendrogram. Observations 1 and 6 are also quite similar to each other. However, it is tempting but incorrect to conclude from the fgure that observations 9 and 2 are quite similar to each other on the basis that they are located near each other on the dendrogram. In fact, based on the information contained in the dendrogram, observation 9 is no more similar to observation 2 than it is to observations 8, 5, and 7. (This can be seen from the right-hand panel of Figure 12.12, in which the raw data are displayed.) To put it mathematically, there are 2n1 possible reorderings of the dendrogram, where n is the number of leaves. This is because at each of the n  1 points where fusions occur, the positions of the two fused branches could be swapped without afecting the meaning of the dendrogram. Therefore, we cannot draw conclusions about the similarity of two observations based on their proximity along the horizontal axis. Rather, we draw conclusions about the similarity of two observations based on the location on the vertical axis where branches containing those two observations frst are fused."}
{"id": 362, "contributed_by": "group 4", "title": "", "section": "", "text": "The term hierarchical refers to the fact that clusters obtained by cutting the dendrogram at a given height are necessarily nested within the clusters obtained by cutting the dendrogram at any greater height. However, on an arbitrary data set, this assumption of hierarchical structure might be unrealistic. For instance, suppose that our observations correspond to a group of men and women, evenly split among Americans, Japanese, and French. We can imagine a scenario in which the best division into two groups might split these people by gender, and the best division into three groups might split them by nationality. In this case, the true clusters are not nested, in the sense that the best division into three groups does not result from taking the best division into two groups and splitting up one of those groups. Consequently, this situation could not be well-represented by hierarchical clustering."}
{"id": 363, "contributed_by": "group 4", "title": "", "section": "", "text": "We begin by defning some sort of dissimilarity measure between each pair of observations. Most often, Euclidean distance is used; we will discuss the choice of dissimilarity measure later in this chapter. The algorithm proceeds iteratively. Starting out at the bottom of the dendrogram, each of the n observations is treated as its own cluster. The two clusters that are most similar to each other are then fused so that there now are n1 clusters. Next the two clusters that are most similar to each other are fused again, so that there now are n  2 clusters. The algorithm proceeds in this fashion until all of the observations belong to one single cluster, and the dendrogram is complete."}
{"id": 364, "contributed_by": "group 4", "title": "", "section": "", "text": "Should the observations or features frst be standardized in some way? For instance, maybe the variables should be scaled to have standard deviation one. In the case of hierarchical clustering, What dissimilarity measure should be used? What type of linkage should be used? Where should we cut the dendrogram in order to obtain clusters? In the case of K-means clustering, how many clusters should we look for in the data?"}
{"id": 365, "contributed_by": "group 4", "title": "", "section": "", "text": "An eclectic online retailer sells two items: socks and computers. Left: the number of pairs of socks, and computers, purchased by eight online shoppers is displayed. Each shopper is shown in a diferent color. If inter-observation dissimilarities are computed using Euclidean distance on the raw variables, then the number of socks purchased by an individual will drive the dissimilarities obtained, and the number of computers purchased will have little efect. This might be undesirable, since (1) computers are more expensive than socks and so the online retailer may be more interested in encouraging shoppers to buy computers than socks, and (2) a large diference in the number of socks purchased by two shoppers may be less informative about the shoppers overall shopping preferences than a small diference in the number of computers purchased. Center: the same data are shown, after scaling each variable by its standard deviation. Now the two products will have a comparable efect on the inter-observation dissimilarities obtained. Right: the same data are displayed, but now the y-axis represents the number of dollars spent by each online shopper on socks and on computers. Since computers are much more expensive than socks, now computer purchase history will drive the inter-observation dissimilarities obtained."}
{"id": 366, "contributed_by": "group 4", "title": "", "section": "", "text": "Both K-means and hierarchical clustering will assign each observation to a cluster. However, sometimes this might not be appropriate. For instance, suppose that most of the observations truly belong to a small number of (unknown) subgroups, and a small subset of the observations are quite diferent from each other and from all other observations. Then since Kmeans and hierarchical clustering force every observation into a cluster, the clusters found may be heavily distorted due to the presence of outliers that do not belong to any cluster. Mixture models are an attractive approach for accommodating the presence of such outliers. These amount to a soft version of K-means clustering, and are described in ESL."}
{"id": 367, "contributed_by": "group 4", "title": "", "section": "", "text": "clustering can be a very useful and valid statistical tool if used properly. We mentioned that small decisions in how clustering is performed, such as how the data are standardized and what type of linkage is used, can have a large efect on the results. Therefore, we recommend performing clustering with diferent choices of these parameters, and looking at the full set of results in order to see what patterns consistently emerge. Since clustering can be non-robust, we recommend clustering subsets of the data in order to get a sense of the robustness of the clusters obtained."}
{"id": 368, "contributed_by": "group 4", "title": "", "section": "", "text": "In this chapter, we will consider the topics of survival analysis and censored survival analysis data. These arise in the analysis of a unique kind of outcome variable: the censored data time until an event occurs."}
{"id": 369, "contributed_by": "group 4", "title": "", "section": "", "text": "For example, suppose that we have conducted a five-year medical study, in which patients have been treated for cancer. We would like to fit a model to predict patient survival time, using features such as baseline health measurements or type of treatment. At first pass, this may sound like a regression problem of the kind discussed in Chapter 3. But there is an important complication: hopefully some or many of the patients have survived until the end of the study. Such a patients survival time is said to be censored: we know that it is at least five years, but we do not know its true value. We do not want to discard this subset of surviving patients, as the fact that they survived at least five years amounts to valuable information. However, it is not clear how to make use of this information using the techniques covered thus far in this textbook."}
{"id": 370, "contributed_by": "group 4", "title": "", "section": "", "text": "For each individual, we suppose that there is a true survival time, T, as well as a true censoring time, C. (The survival time is also known as the failure time or the event time.) The survival time represents the time at which the failure time event of interest occurs: for instance, the time at which the patient dies, or the customer cancels his or her subscription. By contrast, the censoring time is the time at which  censoring occurs: for example, the time at which the patient drops out of the study or the study ends."}
{"id": 371, "contributed_by": "group 4", "title": "", "section": "", "text": "We observe either the survival time T or else the censoring time C. Specifically, we observe the random variable Y = min(T,C). (11.1) In other words, if the event occurs before censoring (i.e. T <C) then we observe the true survival time T; however, if censoring occurs before the event (T >C) then we observe the censoring time. We also observe a status indicator,  = = 1 if T  C 0 if T > C. Thus,  = 1 if we observe the true survival time, and  = 0 if we instead observe the censoring time."}
{"id": 372, "contributed_by": "group 4", "title": "", "section": "", "text": "In this chapter, we focus on right censoring, which occurs when T  Y, i.e. the true event time T is at least as large as the observed time Y. (Notice that T  Y is a consequence of (11.1). Right censoring derives its name from the fact that time is typically displayed from left to right, as in Figure 11.1.) However, other types of censoring are possible. For instance, in left censoring, the true event time T is less than or equal to the observed time Y . For example, in a study of pregnancy duration, suppose that we survey patients 250 days after conception, when some have already had their babies. Then we know that for those patients, pregnancy duration is less than 250 days. More generally, interval censoring refers to the setting in which we do not know the exact event time, but we know that it falls in some interval. For instance, this setting arises if we survey patients once per week in order to determine whether the event has occurred. While left censoring and interval censoring can be accommodated using variants of the ideas presented in this chapter, in what follows we focus specifcally on right censoring."}
{"id": 373, "contributed_by": "group 4", "title": "", "section": "", "text": "In general, we need to assume that the censoring mechanism is independent: conditional on the features, the event time T is independent of the censoring time C. The two examples above violate the assumption of independent censoring. Typically, it is not possible to determine from the data itself whether the censoring mechanism is independent. Instead, one has to carefully consider the data collection process in order to determine whether independent censoring is a reasonable assumption. In the remainder of this chapter, we will assume that the censoring mechanism is independent."}
{"id": 374, "contributed_by": "group 4", "title": "", "section": "", "text": "The survival curve, or survival function, is defined as. This decreasing function quantifes the probability of surviving past time t. For example, suppose that a company is interested in modeling customer churn. Let T represent the time that a customer cancels a subscription to the companys service. Then S(t) represents the probability that a customer cancels later than time t. The larger the value of S(t), the less likely that the customer will cancel before time t."}
{"id": 375, "contributed_by": "group 4", "title": "", "section": "", "text": "For times t between dk and dk+1, we set. Consequently, the KaplanMeier survival curve has a step like shape. The Kaplan Meier survival curve for the BrainCancer data is displayed. Each point in the solid step like curve shows the estimated probability of surviving past the time indicated on the horizontal axis. The estimated probability of survival past 20 months is 71%, which is quite a bit higher than the naive estimates of 55% and 68% presented earlier."}
{"id": 376, "contributed_by": "group 4", "title": "", "section": "", "text": "At first glance, a two-sample t-test seems like an obvious choice: we could test whether the mean survival time among the females equals the mean survival time among the males. But the presence of censoring again creates a complication. To overcome this challenge, we will conduct a log-rank test, which examines how the events in each group unfold sequentially in time."}
{"id": 377, "contributed_by": "group 4", "title": "", "section": "", "text": "The hazard function or hazard rate also known as the force of mortality hazard  is formally defined as function h(t) = limt0 Pr(t<T  t + t|T >t) t , (11.9) where T is the (unobserved) survival time. It is the death rate in the instant after time t, given survival past that time.7 In (11.9), we take the limit as t approaches zero, so we can think of t as being an extremely tiny number. Thus, more informally, (11.9) implies that h(t)  Pr(t<T  t + t|T >t) t for some arbitrarily small t."}
{"id": 378, "contributed_by": "group 4", "title": "", "section": "", "text": "We now consider the hazard function h(t) in a bit more detail. Recall that for two events A and B, the probability of A given B can be expressed as Pr(A | B) = Pr(A  B)/Pr(B), i.e. the probability that A and B both occur divided by the probability that B occurs. Furthermore, recall from (11.2) that S(t) = Pr(T >t). Thus, h(t) = limt0 Pr ((t<T  t + t)  (T >t)) /t Pr(T >t) = lim t0 Pr(t<T  t + t)/t Pr(T >t) = f(t) S(t), (11.10) where f(t) = limt0 Pr(t<T  t + t) t (11.11)is the probability density function associated with T, i.e. it is the instantaneous rate of death at time t. The second equality in (11.10) made use of the fact that if t<T  t + t, then it must be the case that T >t."}
{"id": 379, "contributed_by": "group 4", "title": "", "section": "", "text": "Equation 11.10 implies a relationship between the hazard function h(t), the survival function S(t), and the probability density function f(t). In fact, these are three equivalent ways8 of describing the distribution of T."}
{"id": 380, "contributed_by": "group 4", "title": "", "section": "", "text": "The proportional hazards assumption states that proportional hazards assumption h(t|xi) = h0(t) exp 0p j=1 xijj   , (11.14) where h0(t)  0 is an unspecifed function, known as the baseline hazard. baseline hazard It is the hazard function for an individual with features xi1 =  = xip = 0. The name proportional hazards arises from the fact that the hazard function for an individual with feature vector xi is some unknown function h0(t) times the factor exp 1)p j=1 xijj 2. The quantity exp 1)p j=1 xijj 2 is called the relative risk for the feature vector xi = (xi1,...,xip)T , relative to that for the feature vector xi = (0,..., 0)T ."}
{"id": 381, "contributed_by": "group 4", "title": "", "section": "", "text": "Because the form of h0(t) in the proportional hazards assumption (11.14) is unknown, we cannot simply plug h(t|xi) into the likelihood (11.13) and then estimate  = (1,..., p)T by maximum likelihood. The magic of Coxs proportional hazards model lies in the fact that it is in fact possible to estimate  without having to specify the form of h0(t)."}
{"id": 382, "contributed_by": "group 4", "title": "", "section": "", "text": "In fact, there is a close relationship between these two approaches. In particular, when taking Approach #1, there are a number of possible ways to test H0. One way is known as a score test. It turns out that in the case of a single binary covariate, the score test for H0 :  = 0 in Coxs proportional hazards model is exactly equal to the log-rank test."}
{"id": 383, "contributed_by": "group 4", "title": "", "section": "", "text": "Therefore, to assess the model fit, we must take a diferent approach, which involves stratifying the observations using the coefcient estimates. In particular, for each test observation, we compute the risk score budgeti  budget + impacti  impact, where budget and impact are the coefcient estimates for these two features from the training set. We then use these risk scores to categorize the observations based on their risk. For instance, the high risk group consists of the observations for which budgeti  budget +impacti  impact is largest; by (11.14), we see that these are the observations for which the instantaneous probability of being published at any moment in time is largest. In other words, the high risk group consists of the trials that are likely to be published sooner. On the Publication data, we stratify the observations into tertiles of low, medium, and high risk. The resulting survival curves for each of the three strata are displayed in Figure 11.8. We see that there is clear separation between the three strata, and that the strata are correctly ordered in terms of low, medium, and high risk of publication."}
{"id": 384, "contributed_by": "group 4", "title": "", "section": "", "text": "Therefore, Harrells concordance index (or C-index) computes the pro- Harrells concordance index portion of observation pairs for which i! > i and yi > yi! : C = ) i,i!:yi>yi! I(i! > i)i! ) i,i!:yi>yi! i! , where the indicator variable I(i! > i) equals one if i! > i, and equals zero otherwise. The numerator and denominator are multiplied by the status indicator i! , since if the i $ th observation is uncensored (i.e. if i! = 1), then yi > yi! implies that ti > ti! . By contrast, if i! = 0, then yi > yi! does not imply that ti > ti! . We ft a Cox proportional hazards model on the training set of the Publication data, and computed the C-index on the test set. This yielded C = 0.733. Roughly speaking, given two random papers from the test set, the model can predict with 73.3% accuracy which will be published frst."}
{"id": 385, "contributed_by": "group 4", "title": "", "section": "", "text": "We have seen that Coxs proportional hazards model relies on the proportional hazards assumption (11.14). While results from the Cox model tend to be fairly robust to violations of this assumption, it is still a good idea to check whether it holds. In the case of a qualitative feature, we can plot the log hazard function for each level of the feature. If (11.14) holds, then the log hazard functions should just difer by a constant, as seen in the top-left panel of Figure 11.4. In the case of a quantitative feature, we can take a similar approach by stratifying the feature."}
{"id": 386, "contributed_by": "group 4", "title": "", "section": "", "text": "A powerful feature of the proportional hazards model is its ability to handle time-dependent covariates, predictors whose value may change over time. For example, suppose we measure a patients blood pressure every week over the course of a medical study. In this case, we can think of the blood pressure for the ith observation not as xi, but rather as xi(t) at time t."}
{"id": 387, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Why Estimate f?", "text": "More generally, suppose that we observe a quantitative response Y and p different predictors, X1, X2, . . . , Xp. We assume that there is some relationship between Y and X = (X1,X2, . . . ,Xp), which can be written in the very general form Y = f(X) + epsilon. Here f is some fixed but unknown function of X1, . . . ,Xp, and epsilon is a random error term, which is independent of X and has mean zero."}
{"id": 388, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Why Estimate f?", "text": "Statistical learning, in essence, is the process of using a set of approaches to estimate the relationship between input variables (such as X1, X2, X3) and output variables (Y). It aims to understand and quantify how these input variables are related to the output variable, allowing us to make predictions or gain insights based on this relationship."}
{"id": 389, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Why Estimate f?", "text": "Even if it were possible to form a perfect estimate for f, so that our estimated response took the form  Y = f(X), our prediction would still have some error in it This is because Y is also a function of epsilon, which, by definition, cannot be predicted using X."}
{"id": 390, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "How Do We Estimate f?", "text": "As we have seen, there are advantages and disadvantages to parametric and non-parametric methods for statistical learning. Non-parametric methods have a major disadvantage in that they require a very large number of observations for accurate estimation of f."}
{"id": 391, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "How Do We Estimate f?", "text": "In this setting,  f is often treated as a black box, in the sense that one is not typically concerned with the exact form of  f, provided that it yields accurate predictions for Y."}
{"id": 392, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "The Trade-Off Between Prediction Accuracy and Model Interpretability", "text": "Generalized additive models (GAMs), discussed , instead extend the linear model to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve."}
{"id": 393, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "The Trade-Off Between Prediction Accuracy and Model Interpretability", "text": "Generalized additive models (GAMs), discussed , instead extend the linear model (2.4) to allow for certain non-linear relationships. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve."}
{"id": 394, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "The Trade-Off Between Prediction Accuracy and Model Interpretability", "text": "For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between Y and X1,X2, . . . ,Xp. In contrast, very flexible approaches, such as the splines discussed and the boosting methods, can lead to such complicated estimates of f that it is difficult to understand how any individual predictor is associated with the response."}
{"id": 395, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Supervised Versus Unsupervised Learning", "text": "In this setting, we wish to use a statistical learning method that can incorporate the m observations for which response measurements are available as well as the n \u2212m observations for which they are not."}
{"id": 396, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Supervised Versus Unsupervised Learning", "text": "Examples of qualitative variables include a person\u2019s marital status (married or not), the brand of product purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia)."}
{"id": 397, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "The Trade-Off Between Prediction Accuracy and Model Interpretability", "text": "Least squares linear regression is used with a quantitative response, whereas logistic regression is typically used with a qualitative (two-class, or binary) response. Thus, despite its name, logistic regression is a classification method."}
{"id": 398, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "Measuring the Quality of Fit", "text": "In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by MSE = (1/n) * sum (yi - f(xi))^2."}
{"id": 399, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "Measuring the Quality of Fit", "text": "We instead care about how well it will predict tomorrow\u2019s price or next month\u2019s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease) for a number of patients, as well as information about whether each patient has diabetes. We can use these patients to train a statistical learning method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurements."}
{"id": 400, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "Measuring the Quality of Fit", "text": "When a given method yields a small training MSE but a large test MSE, we are said to be overfitting the data. This happens because our statistical learning procedure is working too hard to find patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f."}
{"id": 401, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "Measuring the Quality of Fit", "text": "there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger."}
{"id": 402, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Bias-Variance Trade-Off", "text": "in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. That is, bias E1[y0 \u2212 f(x0)]^2 defines the expected test MSE at x0, and refers to the average test MSE that we would obtain if we repeatedly estimated f using a large number of training sets, and tested each at x0. The overall expected test MSE can be computed by averaging E1[y0 \u2212 f(x0)]^2 over all possible values of x0 in the test set.that the expected test MSE can always be decomposed into the sum of three fundamental quantities: the variance of f(x0), the squared bias of f(x0), and the variance of the error terms."}
{"id": 403, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Bias-Variance Trade-Off", "text": "Bias refers to the error that is introduced by approximating a real-life problem, which may be extremely complicated, by a much simpler model. For example, linear regression assumes that there is a linear relationship between Y and X1,X2, . . . ,Xp. It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing linear regression will undoubtedly result in some bias in the estimate of f."}
{"id": 404, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Bias-Variance Trade-Off", "text": "The relationship between bias, variance, and test set MSE given in Equation 2.7 and displayed as the bias-variance trade-off. Good test set performance of a statistical learning method requires low variance as well as low squared bias. This is referred to as a trade-off because it is easy to obtain a method with extremely low bias but high variance or a method with very low variance but high bias. The challenge lies in finding a method for which both the variance and the squared bias are low. This trade-off is one of the most important recurring themes in this book."}
{"id": 405, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Bias-Variance Trade-Off", "text": "The orange least squares line is relatively inflexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line."}
{"id": 406, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Bias-Variance Trade-Off", "text": "The relative rate of change of bias and variance determines whether the test MSE increases or decreases. As we increase the flexibility of a class of methods, the bias tends to initially decrease faster than the variance increases. Consequently, the expected test MSE declines. However, at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. When this happens the test MSE increases."}
{"id": 407, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "Measuring the Quality of Fit", "text": "It is possible to show (though the proof is outside of the scope of this book) that the test error rate is minimized by a very simple classifier that assigns each observation to the most likely class, given its predictor values."}
{"id": 408, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Classification Setting", "text": "In a two-class problem where there are only two possible response values, say class 1 or class 2, the Bayes classifier corresponds to predicting class one if Pr(Y = 1|X = x0) > 0.5, and class two otherwise."}
{"id": 409, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Classification Setting", "text": "One such method is the K-nearest neighbors (KNN) classifier."}
{"id": 410, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Classification Setting", "text": "The KNN classifier first identifies the K points in the training data that are closest to x0... and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue."}
{"id": 411, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Classification Setting", "text": "When K = 1, the decision boundary is overly flexible, and it finds patterns in the data that don't correspond to the Bayes decision boundary."}
{"id": 412, "contributed_by": "group 5", "title": "Assessing Model Accuracy", "section": "The Classification Setting", "text": "In both the regression and classification settings, choosing the correct level of flexibility is critical to the success of any statistical learning method. The bias-variance tradeoff, and the resulting U-shape in the test error, can make this a difficult task."}
{"id": 413, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Why Estimate f?", "text": "Now  f cannot be treated as a black box, because we need to know its exact form."}
{"id": 414, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Why Estimate f?", "text": "Even if it were possible to form a perfect estimate for f, so that our estimated response took the form  Y = f(X), our prediction would still have some error in it! This is because Y is also a function of epsilon, which, by definition, cannot be predicted using X. Therefore, variability associated with epsilon also affects the accuracy of our predictions. This is known as the irreducible error, because no matter how well we estimate f, we cannot reduce the error introduced by "}
{"id": 415, "contributed_by": "group 5", "title": "What is Statistical Learning", "section": "Supervised Versus Unsupervised Learning", "text": "The goal of cluster analysis is to ascertain, on the basis of x1, . . . , xn, whether the observations fall into relatively distinct groups."}
{"id": 416, "contributed_by": "group 5", "title": "Lab: Introduction to Python", "section": "", "text": "We just saw that we can modify an element of an array. Can we also modify a tuple? It turns out that we cannot and trying to do so introduces an exception, or error."}
{"id": 417, "contributed_by": "group 5", "title": "Lab: Introduction to Python", "section": "", "text": "The ndim attribute yields the number of dimensions, and T provides its transpose."}
{"id": 418, "contributed_by": "group 5", "title": "Lab: Introduction to Python", "section": "", "text": "The np.mean(), np.var(), and np.std() functions can be used to compute the mean, variance, and standard deviation of arrays."}
{"id": 419, "contributed_by": "group 5", "title": "Lab: Introduction to Python", "section": "", "text": "In order to ensure that our code provides exactly the same results each time it is run, we can set a random seed using the np.random.default_rng() function. This function takes an arbitrary, user-specified integer argument."}
{"id": 420, "contributed_by": "group 5", "title": "Simple Linear Regression", "section": "3.1", "text": "Simple linear regression lives up to its name: it is a very straightforward approach for predicting a quantitative response Y on the basis of a single predictor variable X."}
{"id": 421, "contributed_by": "group 5", "title": "Simple Linear Regression", "section": "3.1", "text": "Beta0 and Beta1 are two unknown constants that represent the intercept and slope terms in the linear model. Together, Beta0 and Beta1 are known as the model coefficients or parameters."}
{"id": 422, "contributed_by": "group 5", "title": "Assessing the Accuracy of the Model", "section": "3.1.3", "text": "The RSE is considered a measure of the lack of fit of the model to the data. If the predictions obtained using the model are very close to the true outcome values, then RSE will be small, and we can conclude that the model fits the data very well."}
{"id": 423, "contributed_by": "group 5", "title": "Assessing the Accuracy of the Model", "section": "3.1.3", "text": "The RSE is considered a measure of the lack of fit of the model to the data. If the predictions obtained using the model are very close to the true outcome values, then RSE will be small, and we can conclude that the model fits the data very well."}
{"id": 424, "contributed_by": "group 5", "title": "Assessing the Accuracy of the Model", "section": "3.1.3", "text": "The R-squared statistic is a measure of the linear relationship between X and Y."}
{"id": 425, "contributed_by": "group 5", "title": "Assessing the Accuracy of the Model", "section": "3.1.3", "text": "This suggests that we might be able to use r = Cor(X, Y) instead of R-squared to assess the fit of the linear model."}
{"id": 426, "contributed_by": "group 5", "title": "Estimating the Coefficients", "section": "3.1.1", "text": "The least squares approach chooses Beta0 and Beta1 to minimize the RSS (Residual Sum of Squares). Using some calculus, one can show that the minimizers are."}
{"id": 427, "contributed_by": "group 5", "title": "Multiple Linear Regression", "section": "3.2", "text": "This hypothesis test is performed by computing the F-statistic."}
{"id": 428, "contributed_by": "group 5", "title": "Multiple Linear Regression", "section": "3.2", "text": "Therefore, unless p is very small, we cannot consider all 2^p models, and instead we need an automated and efficient approach to choose a smaller set of models to consider. There are three classical approaches for this task: Forward Selection, Backward Selection, Mixed Selection."}
{"id": 429, "contributed_by": "group 5", "title": "Extensions of the Linear Model", "section": "3.3.2", "text": "The additivity assumption means that the association between a predictor Xj and the response Y does not depend on the values of the other predictors."}
{"id": 430, "contributed_by": "group 5", "title": "Extensions of the Linear Model", "section": "3.3.2", "text": "The linearity assumption states that the change in the response Y associated with a one-unit change in Xj is constant, regardless of the value of Xj."}
{"id": 431, "contributed_by": "group 5", "title": "Outliers", "section": "3.3.3", "text": "One can identify non-constant variances in the errors, or heteroscedasticity, from the presence of a tunnel shape in the residual plot."}
{"id": 432, "contributed_by": "group 5", "title": "Outliers", "section": "3.3.3", "text": "An outlier is a point for which yi is far from the value predicted by the model."}
{"id": 433, "contributed_by": "group 5", "title": "Collinearity", "section": "3.3.3", "text": "Collinearity refers to the situation in which two or more predictor variables are closely related to one another."}
{"id": 434, "contributed_by": "group 5", "title": "Collinearity", "section": "3.3.3", "text": "It is possible for collinearity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity."}
{"id": 435, "contributed_by": "group 5", "title": "Comparison of Linear Regression with K-Nearest Neighbors", "section": "3.5", "text": "However, spreading 50 observations over p = 20 dimensions results in a phenomenon in which a given observation has no nearby neighbors\u2014this is the so-called curse of dimensionality."}
{"id": 436, "contributed_by": "group 5", "title": "Comparison of Linear Regression with K-Nearest Neighbors", "section": "3.5", "text": "Here we consider one of the simplest and best-known non-parametric methods, K-nearest neighbors regression (KNN regression)."}
{"id": 437, "contributed_by": "group 5", "title": "Qualitative Predictors", "section": "3.3.1", "text": "If a qualitative predictor, also known as a factor, only has two levels or possible values, then incorporating it into a regression model is very simple. We simply create an indicator or dummy variable that takes on two possible numerical values."}
{"id": 438, "contributed_by": "group 5", "title": "Qualitative Predictors", "section": "3.3.1", "text": "If a qualitative predictor, also known as a factor, only has two levels or possible values, then incorporating it into a regression model is very simple. We simply create an indicator or dummy variable that takes on two possible numerical values."}
{"id": 439, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "We use a confidence interval to quantify the uncertainty surrounding the average sales over a large number of cities. On the other hand, a prediction interval can be used to quantify the uncertainty surrounding sales for a particular city."}
{"id": 440, "contributed_by": "group 5", "title": "Estimating the Regression Coefficients", "section": "3.2.1", "text": "This hypothesis test is performed by computing the F-statistic."}
{"id": 441, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "There are three classical approaches for this task."}
{"id": 442, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "The new (p \u2212 1)-variable model is fit, and the variable with the largest p-value is removed. This procedure continues until a stopping rule is reached."}
{"id": 443, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "Instead of fitting a separate simple linear regression model for each predictor, a better approach is to extend the simple linear regression model so that it can directly accommodate multiple predictors."}
{"id": 444, "contributed_by": "group 5", "title": "Estimating the Regression Coefficients", "section": "3.2.1", "text": "We choose Beta 0, Beta 1, .., Beta p to minimize the sum of squared residuals."}
{"id": 445, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "Forward selection is a greedy approach and might include variables early that later become redundant. Mixed selection can remedy this."}
{"id": 446, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "We begin with the null model, which contains an intercept but no predictors. We then fit p simple linear regressions and add to the null model the variable that results in the lowest RSS."}
{"id": 447, "contributed_by": "group 5", "title": "Some Important Questions", "section": "3.2.2", "text": "In addition to looking at the RSE and R-squared statistics just discussed, it can be useful to plot the data."}
{"id": 448, "contributed_by": "group 5", "title": "Potential Problems", "section": "3.3.3", "text": "If the true relationship is far from linear, then virtually all of the conclusions that we draw from the fit are suspect."}
{"id": 449, "contributed_by": "group 5", "title": "Potential Problems", "section": "3.3.3", "text": "The presence of a pattern may indicate a problem with some aspect of the linear model."}
{"id": 450, "contributed_by": "group 5", "title": "Potential Problems", "section": "3.3.3", "text": "If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, confidence and prediction intervals will be narrower than they should be."}
{"id": 451, "contributed_by": "group 5", "title": "Potential Problems", "section": "3.3.3", "text": "In many cases, observations that are obtained at adjacent time points will have positively correlated errors."}
{"id": 452, "contributed_by": "group 5", "title": "Potential Problems", "section": "3.3.3", "text": "But in practice, it can be difficult to decide how large a residual needs to be before we consider the point to be an outlier. To address this problem, instead of plotting the residuals, we can plot the studentized residuals."}
{"id": 453, "contributed_by": "group 5", "title": "Classification", "section": "Introduction", "text": "The linear regression model discussed in Chapter 3 assumes that the response variable Y is quantitative. But in many situations, the response variable is instead qualitative."}
{"id": 454, "contributed_by": "group 5", "title": "Classification", "section": "Overview", "text": "Two reasons not to perform classification using a regression method: (a) a regression method cannot accommodate a qualitative response with more than two classes; (b) a regression method will not provide meaningful estimates of probabilities, even with two classes. In the next section, we present logistic regression, which is well-suited for the classification of a binary qualitative response."}
{"id": 455, "contributed_by": "group 5", "title": "Classification", "section": "Logistic", "text": "Consider again the Default data set, where the response default falls into one of two categories, Yes or No. Rather than modeling this response Y directly, logistic regression models the probability that Y belongs to a particular category. For the Default data, logistic regression models the probability of default."}
{"id": 456, "contributed_by": "group 5", "title": "Classification", "section": "Logistic", "text": "For low balances we now predict the probability of default as close to, but never below, zero. Likewise, for high balances we predict a default probability close to, but never above, one. The logistic function will always produce an S-shaped curve of this form, and so regardless of the value of X, we will obtain a sensible prediction."}
{"id": 457, "contributed_by": "group 5", "title": "Classification", "section": "Coefficients", "text": "Maximum likelihood is a very general approach that is used to fit many of the non-linear models that we examine throughout this book. In the linear regression setting, the least squares approach is in fact a special case of maximum likelihood."}
{"id": 458, "contributed_by": "group 5", "title": "Classification", "section": "Predictions", "text": "The negative coefficient for student in the multiple logistic regression indicates that for a fixed value of balance and income, a student is less likely to default than a non-student."}
{"id": 459, "contributed_by": "group 5", "title": "Classification", "section": "Multinomial", "text": "The coefficient estimates will differ between the two fitted models due to the differing choice of baseline, but the predictions, the log odds between any pair of classes, and the other key model outputs will remain the same."}
{"id": 460, "contributed_by": "group 5", "title": "Classification", "section": "Generative", "text": "Why do we need another method when we have logistic regression? There are several reasons like when there is substantial separation between the two classes, the parameter estimates for the logistic regression model are surprisingly unstable. The methods that we consider in this section do not suffer from this problem."}
{"id": 461, "contributed_by": "group 5", "title": "Classification", "section": "Bayes Theorem", "text": "Bayes classifier, which classifies an observation x to the class for which probability is largest, has the lowest possible error rate out of all classifiers. Therefore, if we can find a way to estimate output, then we can plug it into (4.15) in order to approximate the Bayes classifier."}
{"id": 462, "contributed_by": "group 5", "title": "Classification", "section": "Bayes Theorem", "text": "We would like to obtain an estimate for density function that we can plug into (4.15) in order to estimate probability. We will then classify an observation to the class for which probability is greatest. To estimate the class, we will first make some assumptions about its form. In particular, we assume that the density function is normal or Gaussian."}
{"id": 463, "contributed_by": "group 5", "title": "Classification", "section": "Discriminant", "text": "We then computed the decision boundary, shown as a black solid line, that results from assigning an observation to the class for which delta is largest. All points to the left of this line will be assigned to the green class, while points to the right of this line are assigned to the purple class."}
{"id": 464, "contributed_by": "group 5", "title": "Classification", "section": "Discriminant", "text": "We then computed the decision boundary, shown as a black solid line, that results from assigning an observation to the class for which delta is largest. All points to the left of this line will be assigned to the green class, while points to the right of this line are assigned to the purple class."}
{"id": 465, "contributed_by": "group 5", "title": "Classification", "section": "Discriminant", "text": "The decision boundary corresponds to the midpoint between the sample means for the two classes. The figure indicates that the LDA decision boundary is slightly to the left of the optimal Bayes decision boundary."}
{"id": 466, "contributed_by": "group 5", "title": "Classification", "section": "Discriminant", "text": "Since this is simulated data, we can generate a large number of test observations in order to compute the Bayes error rate and the LDA test error rate. These are 10.6% and 11.1%, respectively. In other words, the LDA classifier\u2019s error rate is only 0.5% above the smallest possible error rate! This indicates that LDA is performing pretty well on this data set."}
{"id": 467, "contributed_by": "group 5", "title": "Classification", "section": "Multivariate LDA", "text": "We now extend the LDA classifier to the case of multiple predictors. To do this, we will assume that all observations are drawn from a multivariate Gaussian (or multivariate normal) distribution, with a class-specific multivariate mean vector and a common covariance matrix. We begin with a brief review of this distribution. The multivariate Gaussian distribution assumes that each individual predictor follows a one-dimensional normal distribution with some correlation between each pair of predictors."}
{"id": 468, "contributed_by": "group 5", "title": "Classification", "section": "Multivariate LDA", "text": "The bell shape will be distorted if the predictors are correlated or have unequal variances, as is illustrated in the right-hand panel of Figure 4.5. In this situation, the base of the bell will have an elliptical, rather than circular shape."}
{"id": 469, "contributed_by": "group 5", "title": "Classification", "section": "Bayes", "text": "20 observations drawn from each of the three classes are displayed, and the resulting LDA decision boundaries are shown as solid black lines. Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines."}
{"id": 470, "contributed_by": "group 5", "title": "Classification", "section": "Overfitting", "text": "First of all, training error rates will usually be lower than test error rates, which are the real quantity of interest. In other words, we might expect this classifier to perform worse if we use it to predict whether or not a new set of individuals will default."}
{"id": 471, "contributed_by": "group 5", "title": "Classification", "section": "Overfitting", "text": "A credit card company might particularly wish to avoid incorrectly classifying an individual who will default, whereas incorrectly classifying an individual who will not default, though still to be avoided, is less problematic."}
{"id": 472, "contributed_by": "group 5", "title": "Classification", "section": "ROC", "text": "The overall performance of a classifier, summarized over all possible thresholds, is given by the area under the curve (AUC). An ideal ROC curve will hug the top left corner, so the larger area under the AUC, the better the classifier."}
{"id": 473, "contributed_by": "group 5", "title": "Classification", "section": "QDA", "text": "By instead assuming that the K classes share a common covariance matrix, the LDA model becomes linear in x, which means there are linear coefficients to estimate. Consequently, LDA is a much less flexible classifier than QDA, and so has substantially lower variance. This can potentially lead to improved prediction performance."}
{"id": 474, "contributed_by": "group 5", "title": "Classification", "section": "QDA", "text": "As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suffers from higher variance without a corresponding decrease in bias."}
{"id": 475, "contributed_by": "group 5", "title": "Classification", "section": "Na\u00efve", "text": "The Na\u00efve Bayes classifier takes a different tack for estimating density functions. Instead of assuming that these functions belong to a particular family of distributions (e.g., multivariate normal), we instead make a single assumption: within the kth class, the p predictors are independent."}
{"id": 476, "contributed_by": "group 5", "title": "Classification", "section": "KNN", "text": "KNN is a completely non-parametric approach: no assumptions are made about the shape of the decision boundary. Because KNN is completely non-parametric, we can expect this approach to dominate LDA and logistic regression when the decision boundary is highly non-linear, provided that n is very large and p is small."}
{"id": 477, "contributed_by": "group 5", "title": "Classification", "section": "QDA", "text": "In settings where the decision boundary is non-linear but n is only modest, or p is not very small, then QDA may be preferred to KNN. This is because QDA can provide a non-linear decision boundary while taking advantage of a parametric form, which means that it requires a smaller sample size for accurate classification, relative to KNN."}
{"id": 478, "contributed_by": "group 5", "title": "Classification", "section": "Bikeshare", "text": "As a concrete example, we consider the Bikeshare data set. The response is bikers, the number of hourly users of a bike sharing program in Washington, DC. This response value is neither qualitative nor quantitative: instead, it takes on non-negative integer values, or counts."}
{"id": 479, "contributed_by": "group 5", "title": "Classification", "section": "Poisson", "text": "Nonnegative fitted values: There are no negative predictions using the Poisson regression model. This is because the Poisson model itself only allows for nonnegative values; see (4.35). By contrast, when we fit a linear regression model to the Bikeshare data set, almost 10% of the predictions were negative."}
{"id": 480, "contributed_by": "group 5", "title": "Classification", "section": "Poisson", "text": "By modeling bike usage with a Poisson regression, we implicitly assume that mean bike usage in a given hour equals the variance of bike usage during that hour. By contrast, under a linear regression model, the variance of bike usage always takes on a constant value. The Poisson regression model is able to handle the mean-variance relationship seen in the Bikeshare data in a way that the linear regression model is not."}
{"id": 481, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "As one would expect, the correlations between the lagged return variables and today\u2019s return are close to zero. The only substantial correlation is between Year and Volume. By plotting the data, we see that Volume is increasing over time. In other words, the average number of shares traded daily increased from 2001 to 2005."}
{"id": 482, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "The predict() method of results can be used to predict the probability that the market will go up, given values of the predictors. This method returns predictions on the probability scale. If no data set is supplied to the predict() function, then the probabilities are computed for the training data that was used to fit the logistic regression model."}
{"id": 483, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "The object train is a vector of 1,250 elements, corresponding to the observations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to True, whereas those that correspond to observations in 2005 are set to False. Hence train is a Boolean array, since its elements are True and False."}
{"id": 484, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "The QDA() classifier will estimate one covariance per class. The output contains the group means. But it does not contain the coefficients of the linear discriminants, because the QDA classifier involves a quadratic, rather than a linear, function of the predictors."}
{"id": 485, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression."}
{"id": 486, "contributed_by": "group 5", "title": "Classification", "section": "Smarket", "text": "As a comparison, we can also fit a logistic regression model to the data. This can also be done with sklearn, though by default it fits something like the ridge regression version of logistic regression. This can be modified by appropriately setting the argument c-value. Its default value is one but by setting it to a very large number, the algorithm converges to the same solution as the usual (unregularized)."}
{"id": 487, "contributed_by": "group 6", "title": "", "section": "", "text": "5 Resampling Methods Resampling methods are an indispensable tool in modern statistics. They involve repeatedly drawing samples from a training set and retting a model of interest on each sample in order to obtain additional information about the fitted model. For example, in order to estimate the variability of a linear regression fit, we can repeatedly draw different samples from the training data, fit a linear regression to each new sample, and then examine the extent to which the resulting fits differ. Such an approach may allow us to obtain information that would not be available from fitting the model only once using the original training sample. Resampling approaches can be computationally expensive, because they involve fitting the same statistical method multiple times using different subsets of the training data. However, due to recent advances in computing power, the computational requirements of resampling methods generally are not prohibitive. In this chapter, we discuss two of the most commonly used resampling methods, cross-validation and the bootstrap. Both methods are important tools in the practical application of many statistical learning procedures. For example, cross-validation can be used to estimate the test error associated with a given statistical learning method in order to evaluate its performance, or to select the appropriate level of flexibility. The process of evaluating a model s performance is known as model assessment, whereas the process of selecting the proper level of flexibility or a model is known as model selection. The bootstrap is used in several context"}
{"id": 488, "contributed_by": "group 6", "title": "", "section": "", "text": "of a parameter estimate or on a given statistical learning method. 202 5. Resampling Methods 5.1 Cross-Validation In Chapter 2 we discuss the distinction between the test error rate and the training error rate. The test error is the average error that results from using a statistical learning method to predict the response on a new observation  that is, a measurement that was not used in training the method. Given a data set, the use of a particular statistical learning method is warranted i it results in the lowest error. The test error can be easily calculated i a designated test set is available. Unfortunately, this is usually not the case. In contrast, the training error can be easily calculated by applying the statistical learning method to the observations used in its training. But as we saw in Chapter 2, the training error rate of ten is quite different from the test error rate, and in particular the former can dramatically underestimate the latter. In the absence of a very large designated test set that can be used to directly estimate the test error rate, a number of techniques can be used to estimate this quantity using the available training data. Some methods make a mathematical adjustment to the training error rate in order to estimate the test error rate. Such approaches are discussed in Chapter 6. In this section, we instead consider a class of methods that estimate the test error rate by holding out a subset of the training observations from the fitting process,"}
{"id": 489, "contributed_by": "group 6", "title": "", "section": "", "text": "and then applying the statistical learning method to those held out observations. In Sections, or simplicity we assume that we are interested in per forming regression with a quantitative response. In Section 5.1.5 we consider the case of classic cation with a qualitative response. As we will see, the key concepts remain the same regardless of whether the response is quantitative or qualitative. 5.1.1 The Validation Set Approach Suppose that we would like to estimate the test error associated with t-ting a particular statistical learning method on a set of observations. The validation set approach, displayed in Figure 5.1, is a very simple strategy for this task. It involves randomly dividing the available set of observations into two parts, a training set and a validation set or hold-out set. The model is t on the training set, and the fitted model is used to predict the responses or the observations in the validation set. The resulting validation set error rate typically assessed using MSE in the case of a quantitative response provides an estimate of the test error rate. We illustrate the validation set approach on the Auto data set. Recall from Chapter 3 that there appears to be a non-linear relationship between mpg and horsepower, and that a model that predicts mpg using horsepower and horsepower2 gives better results than a model that uses only a linear term. It is natural to wonder whether a cubic or higher-order t might provide even better results. We answer this question in Chapter 3 by looking at the p- values"}
{"id": 490, "contributed_by": "group 6", "title": "", "section": "", "text": "associated with a cubic term and higher-order polynomial terms in a linear regression. But we could also answer this question using the validation method. We randomly split the 392 observations into two 5.1 Cross-Validation 203 FIGURE 5.1. A schematic display of the validation set approach. A set of n observations are randomly split into a training set (shown in blue, containing observations 7, 22, and 13, among others) and a validation set (shown in beige, and containing observation 91, among others). The statistical learning method is t on the training set, and its performance is evaluated on the validation set. sets, a training set containing 196 of the data points, and a validation set containing the remaining 196 observations. The validation set error rates that result from fitting various regression models on the training sample and evaluating their performance on the validation sample, using MSE as a measure o validation set error, are shown in the le t-hand panel o Figure 5.2. The validation set MSE or the quadratic t is considerably smaller than for the linear fit. However, the validation set MSE or the cubic t is actually slightly larger than for the quadratic t. This implies that including a cubic term in the regression does not lead to better prediction than simply using a quadratic term. Recall that in order to create the le t-hand panel of Figure 5.2, we randomly divided the data set into two parts, a training set and a validation set. I we repeat the process of randomly splitting the"}
{"id": 491, "contributed_by": "group 6", "title": "", "section": "", "text": "sample set into two parts, we will get a somewhat different estimate or the test MSE. As an illustration, the right-hand panel of Figure 5.2 displays ten different validation set MSE curves from the Auto data set, produced using ten different random splits of the observations into training and validation sets. All ten curves indicate that the model with a quadratic term has a dramatically smaller validation set MSE than the model with only a linear term. Furthermore, all ten curves indicate that there is not much bene t in including cubic or higher-order polynomial terms in the model. But it is worth noting that each of the ten curves results in a different test MSE estimate or each of the ten regression models considered. And there is no consensus among the curves as to which model results in the smallest validation set MSE. Based on the variability among these curves, all that we can conclude with any confidence is that the linear t is not adequate or this data. The validation set approach is conceptually simple and is easy to implement. But it has two potential drawbacks: 1. As is shown in the right-hand panel of Figure 5.2, the validation estimate of the test error rate can be highly variable, depending on precisely which observations are included in the training set and which observations are included in the validation set. 2. In the validation approach, only a subset of the observations those that are included in the training set rather than in the validation set are used"}
{"id": 492, "contributed_by": "group 6", "title": "", "section": "", "text": "to t the model. Since statistical methods tend to perform worse when trained on ewer observations, this suggests that the 204 5. Resampling Methods FIGURE 5.2. The validation set approach was used on the Auto data set in order to estimate the test error that results from predicting mpg using polynomial functions of horsepower. Let: Validation error estimates or a single split into training and validation data sets. Right: The validation method was repeated ten times, each time using a different random split of the observations into a training set and a validation set. This illustrates the variability in the estimated test MSE that results from this approach. validation set error rate may tend to overestimate the test error rate or the model t on the entire data set. In the coming subsections, we will present cross- validation, a refinement of the validation set approach that addresses these two issues. 5.1.2 Leave-One-Out Cross-Validation Leave-one-out cross-validation (LOOCV) is closely related to the validation set approach of Section 5.1.1, but it attempts to address that method s drawbacks. Like the validation set approach, LOOCV involves splitting the set of observations into two parts. However, instead of creating two subsets of comparable size, a single observation (x1, y1) is used or the validation set, and the remaining observations {(x2, y2), . . ., (xn , yn)} make up the training set. The statistical learning method is t on the n   1 training observations, and a prediction y1 is made or the excluded observation, using its value x1. Since (x1,"}
{"id": 493, "contributed_by": "group 6", "title": "", "section": "", "text": "y1) was not used in the fitting process, MSE1 = (y1   y 1)2 provides an approximately unbiased estimate or the test error. But even though MSE1 is unbiased or the test error, it is a poor estimate because it is highly variable, since it is based upon a single observation (x1, y1). We can repeat the procedure by selecting (x2, y2) or the validation data, training the statistical learning procedure on the n   1 observations {(x 1, y1), (x3, y3), . . ., (xn, y n)}, and computing MSE2 = (y2 y2)2. Repeating this approach n times produces no squared errors, MSE1, MSEn. The LOOCV estimate or the test MSE is the average o these n test error estimates: 5.1 Cross-Validation 205 FIGURE 5.3. A schematic display of LOOCV. A set on data points is repeatedly split into a training set (shown in blue) containing all but one observation, and a validation set that contains only that observation (shown in beige). The test error is then estimated by averaging the n resulting MSEs. The first training set contains all but observation 1, the second training set contains all but observation 2, and so orth. A schematic of the LOOCV approach is illustrated in Figure 5.3. LOOCV has a couple of major advantages over the validation set approach. First, it has far less bias. In LOOCV, we repeatedly t the statistical learning method using training sets that contain n   1 observations, almost as many as are in the entire data set. This is in contrast to"}
{"id": 494, "contributed_by": "group 6", "title": "", "section": "", "text": "the validation set approach, in which the training set is typically around half the size of the original data set. Consequently, the LOOCV approach tends not to overestimate the test error rate as much as the validation set approach does. Second, in contrast to the validation approach which will yield different results when applied repeatedly due to randomness in the training/validation set splits, performing LOOCV multiple times will always yield the same results: there is no randomness in the training/vali-dation set splits. We used LOOCV on the Auto data set in order to obtain an estimate of the test set MSE that results from fitting a linear regression model to predict mpg using polynomial functions of horsepower. The results are shown in the le t-hand panel of Figure 5.4. LOOCV has the potential to be expensive to implement, since the model has to be t n times. This can be very time consuming i n is large, and if each individual model is slow to t. With the least square linear or polynomial regression, an amazing shortcut makes the cost of LOOCV the same as that of a single model t! The following formula holds: 206 5. Resampling Methods FIGURE 5.4. Cross-validation was used on the Auto data set in order to estimate the test error that results from predicting mpg using polynomial functions of horsepower. Let: The LOOCV error curve. Right: 10- old CV was run nine separate times, each with a different random split of the data into ten parts. The figure shows the"}
{"id": 495, "contributed_by": "group 6", "title": "", "section": "", "text": "nine slightly different CV error curves. where yi is the ith fitted value from the original least squares t, and hi is the leverage defined in (3.37) on page 105.1 This is like the ordinary MSE, except the ith residual is divided by 1   hi. The leverage lies between 1/n and 1, and reflects the amount that an observation influences its own t. Hence the residuals or high-leverage points are inflated in this formula by exactly the right amount or this equality to hold. LOOCV is a very general method, and can be used with any kind o predictive modeling. For example we could use it with logistic regression or linear discriminant analysis, or any of the methods discussed in later chapters. The magic formula (5.2) does not hold in general, in which case the model has to be re t n times. 5.1.3 k-Fold Cross-Validation An alternative to LOOCV is k- old CV. This approach involves randomly dividing the set of observations into k groups, or folds, of approximately equal size. The first old is treated as a validation set, and the method is t on the remaining k   1 folds. The mean squared error, MSE1, is then computed on the observations in the held-out old. This procedure is repeated k times: each time, a different group of observations is treated as a validation set. This process results in k estimates o the test error, MSE1 , MSE2, . . ., MSEk. The k- old CV estimate is computed by averaging these values,"}
{"id": 496, "contributed_by": "group 6", "title": "", "section": "", "text": "Figure 5.5 illustrates the k- old CV approach. 1In the case of multiple linear regression, the leverage takes a slightly more complicated form than (3.37), but (5.2) still holds. 5.1 Cross-Validation 207 FIGURE 5.5. A schematic display of 5-fold CV. A set on observations is randomly split into five non-overlapping groups. Each of these acts as a validation set (shown in beige), and the remainder as a training set (shown in blue). The test error is estimated by averaging the five resulting MSE estimates. It is not hard to see that LOOCV is a special case of k- old CV in which k is set to equal n. In practice, one typically performs k- old CV using k = 5 or k = 10. What is the advantage of using k = 5 or k = 10 rather than k = n? The most obvious advantage is computational. LOOCV requires fitting the statistical learning method n times. This has the potential to be computationally expensive (except or linear models t by least squares, in which case formula (5.2) can be used). But cross-validation is a very general approach that can be applied to almost any statistical learning method. Some statistical learning methods have computationally intensive fitting procedures, and so performing LOOCV may pose computational problems, especially if n is extremely large. In contrast, per forming 10- old CV requires fitting the learning procedure only ten times, which may be much more feasible. As we see in Section 5.1.4, there also can be other non-computational advantages to"}
{"id": 497, "contributed_by": "group 6", "title": "", "section": "", "text": "performing 5-fold or 10- old CV, which involve the bias-variance trade-of. The right-hand panel of Figure 5.4 displays nine different 10- old CV estimates or the Auto data set, each resulting from a different random split of the observations into ten olds. As we can see from the figure, there is some variability in the CV estimates as a result of the variability in how the observations are divided into ten olds. But this variability is typically much lower than the variability in the test error estimates that results from the validation set approach (right-hand panel of Figure 5.2). When we examine real data, we do not know the true test MSE, and so it is di cult to determine the accuracy of the cross-validation estimate. However, if we examine simulated data, then we can compute the true test MSE, and can thereby evaluate the accuracy of our cross-validation results. In Figure 5.6, we plot the cross-validation estimates and true test error rates that result from applying smoothing splines to the simulated data sets illustrated in Figures 2.9 2.11 o Chapter 2. The true test MSE is displayed in blue. The black dashed and orange solid lines respectively show the estimated LOOCV and 10- old CV estimates. In all three plots, the two cross-validation estimates are very similar. In the right-hand panel 208 5. Resampling Methods FIGURE 5.6. True and estimated test MSE or the simulated data sets in Figures 2.9 (le t), 2.10 (center), and 2.11 (right). The true test MSE is shown in blue, the"}
{"id": 498, "contributed_by": "group 6", "title": "", "section": "", "text": "LOOCV estimate is shown as a black dashed line, and the 10- old CV estimate is shown in orange. The crosses indicate the minimum o each of the MSE curves. o Figure 5.6, the true test MSE and the cross-validation curves are almost identical. In the center panel of Figure 5.6, the two sets of curves are similar at the lower degrees of flexibility, while the CV curves overestimate the test set MSE or higher degrees of flexibility. In the le t-hand panel of Figure 5.6, the CV curves have the correct general shape, but they underestimate the true test MSE. When we perform cross-validation, our goal might be to determine how well a given statistical learning procedure can be expected to perform on independent data; in this case, the actual estimate of the test MSE is of interest. But at other times we are interested only in the location of the minimum point in the estimated test MSE curve. This is because we might be performing cross-validation on a number of statistical learning methods, or on a single method using different levels of flexibility, in order to identify the method that results in the lowest test error. For this purpose, the location of the minimum point in the estimated test MSE curve is important, but the actual value of the estimated test MSE is not. We find in Figure 5.6 that despite the fact that they sometimes underestimate the true test MSE, all of the CV curves come close to identifying the correct level of"}
{"id": 499, "contributed_by": "group 6", "title": "", "section": "", "text": "flexibility that is, the flexibility level corresponding to the smallest test MSE. 5.1.4 Bias-Variance Trade-O or k-Fold Cross-Validation We mentioned in Section 5.1.3 that k- old CV with k < n has a computational advantage to LOOCV. But putting computational issues aside, a less obvious but potentially more important advantage of k- old CV is that it o ten gives more accurate estimates of the test error rate than does LOOCV. This has to do with a bias-variance trade-off. It was mentioned in Section 5.1.1 that the validation set approach can lead to overestimates of the test error rate, since in this approach the training set used to t the statistical learning method contains only half the observations of the entire data set. Using this logic, it is not hard to see. 5.1 Cross-Validation 209 212 5. Resampling Methods 5.2 The Bootstrap The bootstrap is a widely applicable and extremely powerful statistical tool bootstrap that can be used to quantify the uncertainty associated with a given estimator or statistical learning method. As a simple example, the bootstrap can be used to estimate the standard errors of the coefficients from a linear regression t. In the specific case of linear regression, this is not particularly use up since we saw in Chapter 3 that standard statistical software such as R outputs such standard errors automatically. However, the power o the bootstrap lies in the act that it can be easily applied to a wide range o statistical learning methods, including some or which a measure o variability is"}
{"id": 500, "contributed_by": "group 6", "title": "", "section": "", "text": "otherwise di cult to obtain and is not automatically output by statistical software. In this section we illustrate the bootstrap on a toy example in which we wish to determine the best investment allocation under a simple model. In Section 5.3 we explore the use of the bootstrap to assess the variability associated with the regression coefficients in a linear model t. Suppose that we wish to invest a fixed sum of money in two financial assets that yield returns o X and Y, respectively, where X and Y are random quantities. We will invest a fraction   of our money in X, and will invest the remaining 1     in Y. Since there is variability associated with the returns on these two assets, we wish to choose   to minimize the total risk, or variance, of our investment. In other words, we want to minimize Var( X + (1    )Y ). One can show that the value that minimizes the risk is given by. Figure 5.9 illustrates this approach or estimating   on a simulated data set. In each panel, we simulated 100 pairs of returns or the investments. X and Y. We used these returns to estimate, and, which we then substituted into (5.7) in order to obtain estimates or  . The value of   resulting from each simulated data set ranges from 0.532 to 0.657. It is natural to wish to quantify the accuracy of our estimate of  . To estimate the standard deviation o  , we repeated the process o simulating"}
{"id": 501, "contributed_by": "group 6", "title": "", "section": "", "text": "100 paired observations o X and Y, and estimating   using (5.7), 1,000 times. We thereby obtained 1,000 estimates or  , which we can call  1,  2, The le t-hand panel o Figure 5.10 displays a histogram o the resulting estimates. For these simulations the parameters were set to  X2 = 1,  Y2 = 1.25, and  XY = 0.5, and so we know that the true value   is 0.6. We indicated this value using a solid vertical line on the histogram. 1 5.9. Each panel displays 100 simulated returns or investments From le t to right and top to bottom, the resulting estimates or   0.532, 0.657, and 0.651. The mean over all 1,000 estimates or   is very close to   = 0.6, and the standard deviation o the estimates is This gives us a very good idea of the accuracy of  : SE( ) = 0.083. So roughly speaking, or a random sample from the population, we would expect   to di er rom   by approximately 0.08, on average. In practice, however, the procedure or estimating SE( ) outlined above cannot be applied, because or real data we cannot generate new samples from the original population. However, the bootstrap approach allows us to use a computer to emulate the process of obtaining new sample sets, so that we can estimate the variability o   without generating additional samples. Rather than repeatedly obtaining independent data sets from the population, we instead obtain distinct data sets by repeatedly sampling observations from the original data set. This"}
{"id": 502, "contributed_by": "group 6", "title": "", "section": "", "text": "approach is illustrated in Figure 5.11 on a simple data set, which we call Z, that contains only n = 3 observations. We randomly select n observations from the data set in order to produce a bootstrap data set, 214 5. Resampling Methods FIGURE 5.10. Le t: A histogram of the estimates o   obtained by generating 1,000 simulated data sets from the true population. Center: A histogram of the estimates of   obtained from 1,000 bootstrap samples from a single data set. Right: The estimates of   displayed in the le t and center panels are shown as boxplots. In each panel, the pink line indicates the true value of  . Z 1. The sampling is performed with replacement, which means that the same observation can occur more than once in the bootstrap data set. In this example, Z 1 contains the third observation twice, the first observation once, and no instances o the second observation. Note that i an observation is contained in Z 1, then both its X and Y values are included. We can use Z 1 to produce a new bootstrap estimate or  , which we call    1. This procedure is repeated B times or some large value of B, in order to produce. B different bootstrap data sets, Z 1, Z 2, . . ., Z B, and B corresponding   estimates,  1,  2, . . .,  B. We can compute the standard error of these bootstrap estimates using the formula. This serves as an estimate of the standard error of   estimated from the original"}
{"id": 503, "contributed_by": "group 6", "title": "", "section": "", "text": "data set. The bootstrap approach is illustrated in the center panel of Figure 5.10, which displays a histogram of 1,000 bootstrap estimates o  , each computed using a distinct bootstrap data set. This panel was constructed on the basis of a single data set, and hence could be created using real data. Note that the histogram looks very similar to the le t-hand panel, which displays the idealized histogram o the estimates of   obtained by generating 1,000 simulated data sets from the true population. In particular the bootstrap estimate SE( ) rom (5.8) is 0.087, very close to the estimate of 0.083 obtained using 1,000 simulated data sets. The right-hand panel displays the information in the center and le t panels in a different way, via boxplots o the estimates or   obtained by generating 1,000 simulated data sets from the true population and using the bootstrap approach. Again, the boxplots have similar spreads, indicating that the bootstrap approach can be used to effectively estimate the variability associated with  . with replacement 5.3 Lab: Cross-Validation and the Bootstrap 215 FIGURE 5.11. A graphical illustration of the bootstrap approach on a small sample containing n = 3 observations. Each bootstrap data set contains n observations, sampled with replacement from the original data set. Each bootstrap data set is used to obtain an estimate of  . 5.3 Lab: Cross-Validation and the Bootstrap In [1]: In this lab, we explore the resampling techniques covered in this chapter. Some of the commands in this lab may take a while to"}
{"id": 504, "contributed_by": "group 6", "title": "", "section": "", "text": "run on your computer. We again begin by placing most of our imports at this top level. import numpy as np import statsmodels .api as sm from ISLP import load_data from ISLP.models import ( ModelSpec as MS , summarize , poly) from sklearn . model_selection import train_test_split In [2]: There are several new imports needed or this lab. from functools import partial from sklearn . model_selection import \\ ( cross_validate , KFold , ShuffleSplit ) from sklearn .base import clone from ISLP.models import sklearn_sm 216 5. Resampling Methods 5.3.1 The Validation Set Approach We explore the use of the validation set approach in order to estimate the test error rates that result from fitting various linear models on the Auto data set. We use the unction train_test_split() to split the data into training and validation sets. As there are 392 observations, we split into two equal sets of size 196 using the argument test_size=196. It is generally a good idea to set a random seed when performing operations like this that contain an element of randomness, so that the results obtained can be reproduced precisely at a later time. We set the random seed on the splitter with the argument random_state=0. In [3]: Auto = load_data ('Auto ') Auto_train , Auto_valid = train_test_split (Auto , test_size =196 , random_state =0) Now we can t a linear regression using only the observations corre-sponding to the training set Auto_train. In [4]: hp_mm = MS(['horsepower ']) X_train = hp_mm. fit_transform ( Auto_train ) y_train = Auto_train ['mpg '] model"}
{"id": 505, "contributed_by": "group 6", "title": "", "section": "", "text": "= sm.OLS(y_train , X_train ) results = model.fit () We now use the predict() method of results evaluated on the model ma-trix or this model created using the validation data set. We also calculate the validation MSE of our model. In [5]: X_valid = hp_mm. transform ( Auto_valid ) y_valid = Auto_valid ['mpg '] valid_pred = results . predict ( X_valid ) np.mean (( y_valid - valid_pred )**2) Out[5]: 23.6166 Hence our estimate or the validation MSE of the linear regression t is 23.62. We can also estimate the validation error or higher-degree polynomial regressions. We rst provide a unction evalMSE() that takes a model string as well as a training and test set and returns the MSE on the test set. In [6]: def evalMSE (terms , response , train , test): mm = MS(terms) X_train = mm. fit_transform (train) y_train = train[ response ] X_test = mm. transform (test) y_test = test[ response ] train_test_ split() 5.3 Lab: Cross-Validation and the Bootstrap 217 results = sm.OLS(y_train , X_train ).fit () test_pred = results . predict ( X_test) return np.mean (( y_test - test_pred )**2) In [7]: Out[7]: Let s use this function to estimate the validation MSE using linear, quadratic and cubic ts. We use the enumerate() unction here, which gives enumerate() both the values and indices of objects as one iterates over a or loop. MSE = np.zeros (3) for idx , degree in enumerate (range (1, 4)): MSE[idx] = evalMSE ([ poly('horsepower ', degree )], 'mpg ', Auto_train , Auto_valid ) MSE array"}
{"id": 506, "contributed_by": "group 6", "title": "", "section": "", "text": "([23.62 , 18.76 , 18.80]) These error rates are 23.62, 18.76, and 18.80, respectively. I we choose a di erent training/validation split instead, then we can expect somewhat di erent errors on the validation set. In [8]: Out[8]: Auto_train , Auto_valid = train_test_split (Auto , test_size =196 , random_state =3) MSE = np.zeros (3) for idx , degree in enumerate (range (1, 4)): MSE[idx] = evalMSE ([ poly('horsepower ', degree )], 'mpg ', Auto_train , Auto_valid ) MSE array ([20.76 , 16.95 , 16.97]) Using this split of the observations into a training set and a validation set, we find that the validation set error rates or the models with linear, quadratic, and cubic terms are 20.76, 16.95, and 16.97, respectively. These results are consistent with our previous findings: a model that predicts mpg using a quadratic unction o horsepower performs better than a model that involves only a linear unction o horsepower, and there is no evidence o an improvement in using a cubic unction o horsepower. 5.3.2 Cross-Validation In theory, the cross-validation estimate can be computed or any generalized linear model. In practice, however, the simplest way to cross-validate in Python is to use sklearn, which has a different inter ace or API than stats models, the code we have been using to t GLMs. This is a problem which o ten confronts data scientists:  I have a unction to do task A, and need to feed it into something that performs task B, so that I can compute B(A(D)), where D is my"}
{"id": 507, "contributed_by": "group 6", "title": "", "section": "", "text": "data.  When A and B don t naturally speak to each other, this requires the use of a wrapper. In the ISLP wrapper cross_ validate() 218 5. Resampling Methods package, we provide a wrapper, sklearn_sm(), that enables us to easily use the cross-validation tools o sklearn with models t by statsmodels. sklearn_sm() The class sklearn_sm() has as its rst argument a model rom statsmodels. It can take two additional optional arguments: model_str which can be used to specify a formula, and model_args which should be a dictionary o additional arguments used when fitting the model. For example, to t a logistic regression model we have to specify a family argument. This is passed as model_args={'family':sm.families.Binomial()}. Here is our wrapper in action: In [9]: Out[9]: hp_model = sklearn_sm (sm.OLS , MS(['horsepower '])) X, Y = Auto. drop( columns =['mpg ']), Auto['mpg '] cv_results = cross_validate (hp_model , X, Y, cv=Auto.shape [0]) cv_err = np.mean( cv_results ['test_score ']) cv_err 24.2315 The arguments to cross_validate() are as ollows: an object with the ap-propriate fit(), predict(), and score() methods, an array of features X and a response Y. We also included an additional argument cv to cross_validate(); speci ying an integer K results in K- old cross-validation. We have provided a value corresponding to the total number of observations, which results in leave-one-out cross-validation (LOOCV). The cross_validate() function produces a dictionary with several components; we simply want the cross-validated test score here (MSE), which is estimated to be 24.23. We can repeat this procedure"}
{"id": 508, "contributed_by": "group 6", "title": "", "section": "", "text": "the process, we again use a or loop which iteratively ts polynomial regressions of degree 1 to 5, computes the associated cross-validation error, and stores it in the ith element of the vector cv_error. The variable d in the or loop corresponds to the degree of the polynomial. We begin by initializing the vector. This command may take a couple of seconds to run. In [10]: Out[10]: cv_error = np.zeros (5) H = np.array(Auto['horsepower ']) M = sklearn_sm (sm.OLS) for i, d in enumerate (range (1 ,6)): X = np.power.outer(H, np.arange (d+1)) M_CV = cross_validate (M, X, Y, cv=Auto.shape [0]) cv_error [i] = np.mean(M_CV['test_score ']) cv_error array ([24.2315 , 19.2482 , 19.3350 , 19.4244 , 19.0332]) As in Figure 5.4, we see a sharp drop in the estimated test MSE between the linear and quadratic ts, but then no clear improvement from using higher-degree polynomials. 5.3 Lab: Cross-Validation and the Bootstrap 219 Above we introduced the outer() method of the np.power() function. The outer() method is applied to an operation that has two arguments, such as add(), min() , or power(). It has two arrays as arguments, and then forms a larger array where the operation is applied to each pair of elements of the two arrays. In [11]: A = np.array ([3, 5, 9]) B = np.array ([2, 4]) np.add.outer(A, B) Out[11]: array ([[ 5, 7], [ 7, 9], [11, 13]]) In the CV example above, we used K = n, but of course we can also use n. The code is very similar to"}
{"id": 509, "contributed_by": "group 6", "title": "", "section": "", "text": "the above (and is significantly aster). Here we use KFold() to partition the data into K = 10 random groups. We use random_state to set a random seed and initialize a vector cv_error in which we will store the CV errors corresponding to the polynomial fits of degrees one to five. In [12]: cv_error = np.zeros (5) cv = KFold( n_splits =10, shuffle =True , random_state =0) # use same splits for each degree for i, d in enumerate (range (1 ,6)): X = np.power.outer(H, np.arange (d+1)) M_CV = cross_validate (M, X, Y, cv=cv) cv_error [i] = np.mean(M_CV['test_score ']) cv_error Out[12]: array ([24.2077 , 19.1853 , 19.2763 , 19.4785 , 19.1372]) Notice that the computation time is much shorter than that of LOOCV. (In principle, the computation time or LOOCV or at least squares linear model should be faster than or K- old CV, due to the availability of the formula ( 5.2) or LOOCV; however, the generic cross_ validate() function does not make use of this formula.) We still see little evidence that using cubic or higher-degree polynomial terms leads to a lower test error than simply using a quadratic t. The cross_validate() function is flexible and can take different splitting mechanisms as an argument. For instance, one can use the ShuffleSplit() funtion to implement the validation set approach just as easily as K- old cross-validation. In [13]: validation = ShuffleSplit ( n_splits =1, test_size =196 , random_state =0) results = cross_validate (hp_model , Auto.drop (['mpg '], axis =1) , Auto['mpg '], cv= validation );"}
{"id": 510, "contributed_by": "group 6", "title": "", "section": "", "text": "results ['test_score '] .outer() np.power() KFold() Shuffle Split() 220 5. Resampling Methods Out[13]: array ([23.6166]) One can estimate the variability in the test error by running the ollowing: In [14]: Out[14]: validation = ShuffleSplit ( n_splits =10, test_size =196 , random_state =0) results = cross_validate (hp_model , Auto.drop (['mpg '], axis =1) , Auto['mpg '], cv= validation ) results ['test_score ']. mean (), results ['test_score ']. std () (23.8022, 1.4218) Note that this standard deviation is not a valid estimate of the sampling variability of the mean test score or the individual scores, since the randomly-selected training samples overlap and hence introduce correlations. But it does give an idea of the Monte Carlo variation incurred by picking different random olds. In [15]: 5.3.3 The Bootstrap We illustrate the use of the bootstrap in the simple example of Section 5.2, as well as on an example involving estimating the accuracy of the linear regression model on the Auto data set. Estimating the Accuracy of a Statistic o Interest One of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. While there are several implementations of the bootstrap in Python, its use or estimating standard error is simple enough that we write our own function below or the case when our data is stored in a data frame. To illustrate the bootstrap, we start with a simple example. The Portfolio data set in the ISLP package is described in Section 5.2. The goal is"}
{"id": 511, "contributed_by": "group 6", "title": "", "section": "", "text": "to estimate the sampling variance of the parameter   given in formula (5.7). We will create a unction alpha_func(), which takes as input a data frame D assumed to have columns X and Y, as well as a vector idx indicating which observations should be used to estimate  . The unction then outputs the estimate or   based on the selected observations. Portfolio = load_data ('Portfolio ') def alpha_func (D, idx): cov_ = np.cov(D[['X','Y']]. loc[idx], rowvar=False) return (( cov_ [1 ,1] - cov_ [0 ,1]) / (cov_ [0 ,0]+ cov_ [1 ,1] -2* cov_ [0 ,1])) This unction returns an estimate or   based on applying the minimum variance formula (5.7) to the observations indexed by the argument idx. For instance, the following command estimates   using all 100 observations. In [16]: alpha_func (Portfolio , range (100)) 5.3 Lab: Cross-Validation and the Bootstrap 221 Out[16]: 0.5758 Next we randomly select 100 observations rom range(100) , with replacement. This is equivalent to constructing a new bootstrap data set and recomputing   based on the new data set. In [17]: Out[17]: rng = np. random. default_rng (0) alpha_func (Portfolio , rng. choice (100 , 100, replace =True)) 0.6074 In [18]: This process can be generalized to create a simple unction boot_SE() or computing the bootstrap standard error or arbitrary functions that take only a data frame as an argument. def boot_SE (func , D, n=None , B=1000, seed =0): rng = np. random. default_rng (seed) first_ , second_ = 0, 0 n = n or D.shape [0] for"}
{"id": 512, "contributed_by": "group 6", "title": "", "section": "", "text": "_ in range(B): idx = rng. choice(D.index , n, replace =True) value = func(D, idx) first_ += value second_ += value **2 return np.sqrt( second_ / B - ( first_ / B)**2) Notice the use of as a loop variable in for _ in range(B). This is o ten used i the value of the counter is unimportant and simply makes sure the loop is executed B times. Let s use our unction to evaluate the accuracy of our estimate o   using B = 1,000 bootstrap replications. In [19]: Out[19]: alpha_SE = boot_SE (alpha_func , Portfolio , B=1000, seed =0) alpha_SE 0.0912 The nal output shows that the bootstrap estimate or SE(  ) is 0.0912. Estimating the Accuracy of a Linear Regression Model The bootstrap approach can be used to assess the variability of the coefficient estimates and predictions from a statistical learning method. Here we use the bootstrap approach in order to assess the variability of the 222 5. Resampling Methods In [20]: estimates or  0 and  1, the intercept and slope terms or the linear regres-sion model that uses horsepower to predict mpg in the Auto data set. We will compare the estimates obtained using the bootstrap to those obtained using the formulas or SE( 0) and SE( 1) described in Section 3.1.2.     To use our boot_SE() unction, we must write a unction (its first argument) that takes a data frame D and indices idx as its only arguments. But here we want to bootstrap a specific regression model, specified by a model formula"}
{"id": 513, "contributed_by": "group 6", "title": "", "section": "", "text": "and data. We show how to do this in a few simple steps. We start by writing a generic function boot_OLS() or bootstrapping a regression model that takes a formula to de ne the corresponding regression. We use the clone() unction to make a copy of the formula that can clone() be re t to the new data rame. This means that any derived features such as those defined by poly() (which we will see shortly), will be re- t on the resampled data frame. def boot_OLS (model_matrix , response , D, idx): D_ = D.loc[idx] Y_ = D_[ response ] X_ = clone( model_matrix ). fit_transform (D_) return sm.OLS(Y_ , X_).fit (). params This is not quite what is needed as the first argument to boot_SE(). The first two arguments which specify the model will not change in the bootstrap process, and we would like to freeze them. The unction partial() from the functions module does precisely this: it takes a unction as an argument, partial() and freezes some of its arguments, starting from the le t. We use it to freeze the first two model- formula arguments o boot_OLS(). In [21]: hp_func = partial (boot_OLS , MS(['horsepower ']), 'mpg ') Typing hp_func? will show that it has two arguments D and idx   it is a version o boot_OLS() with the rst two arguments frozen   and hence is ideal as the first argument or boot_SE(). The hp _func() unction can now be used in order to create bootstrap estimates or the intercept and"}
{"id": 514, "contributed_by": "group 6", "title": "", "section": "", "text": "slope terms by randomly sampling rom among the observations with replacement. We first demonstrate its utility on 10 bootstrap samples. In [22]: Out[22]: rng = np. random. default_rng (0) np.array ([ hp_func (Auto , rng. choice (392 , 392, replace =True)) for _ in range (10) ]) array ([[39.8806 , -0.1568] , [38.733 , -0.147 ], [38.3173, -0.1444], [39.9145, -0.1578], [39.4335, -0.1507], [40.3663, -0.1591], [39.6233, -0.1545], [39.0581, -0.1495], [38.6669, -0.1452], [39.6428, -0.1556]]) 5.3 Lab: Cross-Validation and the Bootstrap 223 Next, we use the boot_SE() function to compute the standard errors o 1,000 bootstrap estimates or the intercept and slope terms. In [23]: Out[23]: hp_se = boot_SE (hp_func , Auto , B=1000, seed =10) hp_se intercept 0.8488 horsepower 0.0074 dtype: float64 This indicates that the bootstrap estimate or   is 0.85, and that SE( 0) the bootstrap estimate or   is 0.0074. As discussed in Section 3.1.2, SE( 1) standard formulas can be used to compute the standard errors or the regression coefficients in a linear model. These can be obtained using the summarize() unction rom ISLP.sm. In [24]: Out[24]: hp_model .fit(Auto , Auto['mpg ']) model_se = summarize ( hp_model . results_ )['std err '] model_se intercept 0.717 horsepower 0.006 Name: std err , dtype: float64 In [25]: The standard error estimates or   and   obtained using the formula  0  1 rom Section 3.1.2 are 0.717 or the intercept and 0.006 or the slope. Interestingly, these are somewhat different from the estimates obtained using the bootstrap. Does this indicate a problem with the bootstrap? In act, it suggests"}
{"id": 515, "contributed_by": "group 6", "title": "", "section": "", "text": "the opposite. Recall that the standard formulas given in Equation 3.8 on page 75 rely on certain assumptions. For example, they depend on the unknown parameter  2, the noise variance. We then estimate  2 using the RSS. Now although the formula or the standard errors do not rely on the linear model being correct, the estimate or  2 does. We see in Figure 3.8 on page 99 that there is a non-linear relationship in the data, and so the residuals from a linear t will be inflated, and so will  2. Secondly, the standard formulas assume (somewhat unrealistically) that the xi are fixed, and all the variability comes from the variation in the errors i. The bootstrap approach does not rely on any o these assumptions, and so it is likely giving a more accurate estimate o the standard errors of    0 and  1 than the results from sm.OLS. Below we compute the bootstrap standard error estimates and the standard linear regression estimates that result from fitting the quadratic model to the data. Since this model provides a good t to the data (Figure 3.8), there is now a better correspondence between the bootstrap estimates and the standard estimates o   ,   and   . SE( 0) SE( 1) SE( 2) quad_model = MS([ poly('horsepower ', 2, raw=True)]) quad_func = partial (boot_OLS , quad_model , 'mpg ') boot_SE (quad_func , Auto , B=1000) 224 5. Resampling Methods Out[25]: intercept 2.067840 poly(horsepower , 2, raw=True)[0] 0.033019 poly(horsepower , 2, raw=True)[1] 0.000120 dtype: float64 In [26]: We compare the"}
{"id": 516, "contributed_by": "group 6", "title": "", "section": "", "text": "results to the standard errors computed using sm.OLS(). M = sm.OLS(Auto['mpg '], quad_model . fit_transform (Auto)) summarize (M.fit ())['std err '] Out[26]: intercept 1.800 poly(horsepower , 2, raw=True)[0] 0.031 poly(horsepower , 2, raw=True)[1] 0.000 Name: std err , dtype: float64 5.4 Exercises Conceptual 1. Using basic statistical properties o the variance, as well as single-variable calculus, derive (5.6). In other words, prove that   given by (5.6) does indeed minimize Var( X + (1    )Y ). 2. We will now derive the probability that a given observation is part of a bootstrap sample. Suppose that we obtain a bootstrap sample from a set of n observations. (a) What is the probability that the first bootstrap observation is not the jth observation from the original sample? Justi y your answer. (b) What is the probability that the second bootstrap observation is not the jth observation rom the original sample? (c) Argue that the probability that the jth observation is not in the bootstrap sample is (1   1/n)n. (d) When n = 5, what is the probability that the jth observation is in the bootstrap sample? (e) When n = 100, what is the probability that the jth observation is in the bootstrap sample? ( ) When n = 10, 000, what is the probability that the jth observation is in the bootstrap sample? (g) Create a plot that displays, or each integer value on from 1 to 100, 000, the probability that the jth observation is in the bootstrap sample. Comment on what you observe. (h)"}
{"id": 517, "contributed_by": "group 6", "title": "", "section": "", "text": "We will now investigate numerically the probability that a boot-strap sample o size n = 100 contains the jth observation. Here j = 4. We first create an array store with values that will subsequently be overwritten using the unction np.empty(). We then np.empty() 5.4 Exercises 225 repeatedly create bootstrap samples, and each time we record whether or not the th observation is contained in the bootstrap sample. rng = np. random. default_rng (10) store = np.empty (10000) for i in range (10000) : store[i] = np.sum(rng.choice (100 , replace =True) == 4) > 0 np.mean(store) Comment on the results obtained. 3. We now review k- old cross-validation. (a) Explain how k- old cross-validation is implemented. (b) What are the advantages and disadvantages o k- old cross-validation relative to: i. The validation set approach? ii. LOOCV? 4. Suppose that we use some statistical learning method to make a pre-diction or the response Y or a particular value of the predictor X. Carefully describe how we might estimate the standard deviation o our prediction. Applied 5. In Chapter 4, we used logistic regression to predict the probability of default using income and balance on the Default data set. We will now estimate the test error of this logistic regression model using the validation set approach. Do not forget to set a random seed be ore beginning your analysis. (a) Fit a logistic regression model that uses income and balance to predict default. (b) Using the validation set approach, estimate the test error of this model. In order"}
{"id": 518, "contributed_by": "group 6", "title": "", "section": "", "text": "to do this, you must perform the following steps: i. Split the sample set into a training set and a validation set. ii. Fit a multiple logistic regression model using only the training observations. iii. Obtain a prediction of default status or each individual in the validation set by computing the posterior probability of default or that individual, and classifying the individual to the default category i the posterior probability is greater than 0.5. iv. Compute the validation set error, which is the fraction of the observations in the validation set that are misclassified. (c) Repeat the process in (b) three times, using three different splits of the observations into a training set and a validation set. Comment on the results obtained. 226 5. Resampling Methods (d) Now consider a logistic regression model that predicts the probability of default using income, balance, and a dummy variable or student. Estimate the test error or this model using the validation set approach. Comment on whether or not including a dummy variable or student leads to a reduction in the test error rate. 6. We continue to consider the use of a logistic regression model to predict the probability of default using income and balance on the Default data set. In particular, we will now compute estimates or the standard errors o the income and balance logistic regression coefficients in two different ways: (1) using the bootstrap, and (2) using the standard formula or computing the standard errors in the sm.GLM() unction. Do not forget to set a random"}
{"id": 519, "contributed_by": "group 6", "title": "", "section": "", "text": "seed be ore beginning your analysis. (a) Using the summarize() and sm.GLM() functions, determine the estimated standard errors or the coefficients associated with income and balance in a multiple logistic regression model that uses both predictors. (b) Write a unction, boot_fn(), that takes as input the Default data set as well as an index o the observations, and that outputs the coefficient estimates or income and balance in the multiple logistic regression model. (c) Following the bootstrap example in the lab, use your boot_fn() function to estimate the standard errors of the logistic regression coefficient or income and balance. (d) Comment on the estimated standard errors obtained using the sm.GLM() function and using the bootstrap. 7. In Sections 5.1.2 and 5.1.3, we saw that the cross_validate() function can be used in order to compute the LOOCV test error estimate. Alternatively, one could compute those quantities using just sm.GLM() and the predict() method of the fitted model within a or loop. You will now take this approach in order to compute the LOOCV error or a simple logistic regression model on the Weekly data set. Recall that in the context of classification problems, the LOOCV error is given in (5.4). (a) Fit a logistic regression model that predicts Direction using Lag1 and Lag2. (b) Fit a logistic regression model that predicts Direction using Lag1 and Lag2 using all but the rst observation. (c) Use the model rom (b) to predict the direction of the first observation. You can do this by predicting that the first observation will"}
{"id": 520, "contributed_by": "group 6", "title": "", "section": "", "text": "go up i P (Direction = \"Up\"|Lag1, Lag2) > 0.5. Was this observation correctly classified? (d) Write a or loop rom i = 1 to i = n, where n is the number o observations in the data set, that performs each of the following steps: 5.4 Exercises 227 i. Fit a logistic regression model using all but the ith observation to predict Direction using Lag1 and Lag2. ii. Compute the posterior probability of the market moving up or the ith observation. iii. Use the posterior probability or the ith observation in order to predict whether or not the market moves up. iv. Determine whether or not an error was made in predicting the direction or the ith observation. I an error was made, then indicate this as a 1, and otherwise indicate it as a 0. (e) Take the average of the n numbers obtained in (d)iv in order to obtain the LOOCV estimate or the test error. Comment on the results. 8. We will now perform cross-validation on a simulated data set. (a) Generate a simulated data set as follows: rng = np. random. default_rng (1) x = rng.normal (size =100) y = x - 2 * x**2 + rng.normal (size =100) In this data set, what is n and what is p? Write out the model used to generate the data in equation form. (b) Create a scatterplot of X against Y. Comment on what you find. (c) Set a random seed, and then compute the LOOCV errors that result from fitting the"}
{"id": 521, "contributed_by": "group 6", "title": "", "section": "", "text": "following our models using least squares: i. Y = 0+ 1X+ ii. Y = 0+ 1X+ 2X2+ iii. Y = 0+ 1X+ 2X2+ 3X3+ iv. Y = 0+ 1X+ 2X2+ 3X3+ 4X4. Note you may find it helpful to use the data.frame() function to create a single data set containing both X and Y . (d) Repeat (c) using another random seed, and report your results. Are your results the same as what you got in (c)? Why? (e) Which of the models in (c) had the smallest LOOCV error? Is this what you expected? Explain your answer. ( ) Comment on the statistical significance of the coefficient estimates that results from fitting each o the models in (c) using least squares. Do these results agree with the conclusions drawn based on the cross-validation results? 9. We will now consider the Boston housing data set, from the ISLP library. (a) Based on this data set, provide an estimate or the population mean o medv. Call this estimate  . 228 5. Resampling Methods (b) Provide an estimate of the standard error o  . Interpret this result. Hint: We can compute the standard error of the sample mean by dividing the sample standard deviation by the square root or the number of observations. (c) Now estimate the standard error o   using the bootstrap. How does this compare to your answer from (b)? (d) Based on your bootstrap estimate rom (c), provide a 95 % confidence interval or the mean o medv. Compare it to the results obtained by using Boston['medv'].std() and the two standard error rule (3.9). Hint: You can approximate"}
{"id": 522, "contributed_by": "group 6", "title": "", "section": "", "text": "a 95 % confidence interval using the formula [    2SE( ),   + 2SE( )]. (e) Based on this data set, provide an estimate,  med, or the median value of medv in the population. ( ) We now would like to estimate the standard error o  med. Unfortunately, there is no simple formula or computing the standard error of the median. Instead, estimate the standard error o the median using the bootstrap. Comment on your findings. (g) Based on this data set, provide an estimate or the tenth per-centile of medv in Boston census tracts. Call this quantity  0.1. (You can use the np.percentile() function.) (h) Use the bootstrap to estimate the standard error o  0.1. Comment on your findings. np. percentile()"}
{"id": 523, "contributed_by": "group 6", "title": "", "section": "", "text": "When the number of features is significantly larger than the number of observations.In such scenarios, the dataset contains a substantial number of variables or features relative to the number of data points or observations available. This high-dimensional setting can pose various challenges for machine learning models, such as overfitting, increased computational complexity, and difficulty in finding meaningful patterns. It's important to employ dimensionality reduction techniques or feature selection methods to handle high-dimensional data effectively."}
{"id": 524, "contributed_by": "group 6", "title": "", "section": "", "text": "Hybrid approaches in variable selection aim to combine the best aspects of both forward and backward stepwise selection. These methods seek to strike a balance between the advantages of progressively adding variables (forward selection) and iteratively removing variables (backward selection) to create a more effective and efficient variable selection process. By doing so, they intend to reduce the computational complexity associated with variable selection, making it more manageable and insightful for the analysis. This approach allows for the identification of a subset of relevant variables while minimizing the risk of overfitting, ultimately enhancing the quality of statistical models."}
{"id": 525, "contributed_by": "group 6", "title": "", "section": "", "text": "Selecting the best model in a high-dimensional setting, it is essential to understand the limitations of using RSS and R2. The main issue with employing RSS and R2 for model selection in such scenarios is that they tend to lead to the selection of models that include all available variables. This can be problematic because high-dimensional data often involves numerous variables, many of which may not contribute significantly to the model's predictive power. Therefore, RSS and R2, in the context of high-dimensional data, can be misleading, as they favor models that incorporate all variables, potentially resulting in overfitting. It's crucial to consider alternative model selection criteria that are better suited for high-dimensional settings to avoid this issue."}
{"id": 526, "contributed_by": "group 6", "title": "", "section": "", "text": "An important principle is highlighted when dealing with high-dimensional data. It emphasizes that the quality of the fitted model can deteriorate when adding noise features. This means that in high-dimensional data analysis, introducing irrelevant or noisy features can have a negative impact on the performance and accuracy of the model."}
{"id": 527, "contributed_by": "group 6", "title": "", "section": "", "text": "In linear regression, the commonly used model to describe the relationship between a response variable Y and a set of predictor variables X1, X2, ..., Xp is the Standard linear model. This model assumes a linear relationship between the response variable and the predictors, with the goal of finding the best-fitting line (or hyperplane in the case of multiple predictors) that minimizes the sum of squared differences between the observed and predicted values of Y. Linear regression is widely employed for tasks such as predicting numerical outcomes, modeling dependencies, and understanding the impact of predictor variables on the response variable. It is an essential tool in statistics and data analysis, offering insights into the relationships between variables in a simple and interpretable manner."}
{"id": 528, "contributed_by": "group 6", "title": "", "section": "", "text": "In linear regression modeling, one might consider using an alternative fitting procedure instead of least squares for various reasons. The primary motivation for exploring alternative methods is that they can enhance both prediction accuracy and model interpretability. While least squares is a widely used and well-established method, it may not always provide the best fit for the data or the most interpretable results. Alternative methods can offer advantages in situations where the assumptions of least squares are not met, and they may better capture the underlying relationships in the data. These methods can offer more flexibility and may lead to improved model performance. Therefore, considering alternative fitting procedures is a common practice in the field of linear regression modeling, with the goal of enhancing the overall quality of the model."}
{"id": 529, "contributed_by": "group 6", "title": "", "section": "", "text": "When the number of observations (n) is not much larger than the number of predictor variables (p) in linear regression modeling using least squares, it results in overfitting, leading to poor predictions on future observations. This is because the model lacks sufficient data to generalize well and instead becomes overly sensitive to noise in the training data. This situation can lead to a situation where the model fits the training data very closely but fails to generalize to new, unseen data, causing a decrease in predictive performance. In such cases, the model is more likely to have high variance, and it may struggle to make accurate predictions beyond the training dataset. This condition can be particularly problematic when the number of predictor variables is close to or exceeds the number of observations. Overfitting can be mitigated through techniques such as regularization or by increasing the size of the training dataset."}
{"id": 530, "contributed_by": "group 6", "title": "", "section": "", "text": "The primary advantage of using shrinkage methods in linear regression is that they reduce the variance of coefficient estimates. This reduction in variance is achieved by adding a penalty term to the linear regression objective function, which shrinks the estimated coefficients towards zero. By doing so, shrinkage methods help prevent overfitting, making the model more robust and better suited for making predictions on new, unseen data. Shrinkage methods do not necessarily make the model more complex or always yield exactly zero coefficient estimates. While they do improve model interpretability to some extent by reducing the influence of irrelevant variables, their primary benefit lies in their ability to enhance the stability and generalizability of linear regression models."}
{"id": 531, "contributed_by": "group 6", "title": "", "section": "", "text": "Dimension reduction in linear regression modeling involves projecting predictors into a lower-dimensional subspace. This technique aims to reduce the number of predictor variables while retaining the relevant information needed to make accurate predictions. It is not about fitting a model with all predictors or identifying a subset of predictors  The approach of selecting variables with the least squares method is related to variable selection rather than dimension reduction. Dimension reduction techniques like principal component analysis (PCA) and feature selection methods are commonly employed to streamline the modeling process and enhance model efficiency."}
{"id": 532, "contributed_by": "group 6", "title": "", "section": "", "text": "Linear regression, the primary goal of best subset selection is to identify the subset of predictors that results in the lowest test error. This technique aims to carefully choose a subset of predictor variables from the available options to create a model that can provide accurate predictions on unseen data. The goal is not to include all possible predictor variables, as that can lead to overfitting, nor is it to estimate test mean squared error (MSE) directly or to minimize the training error. Instead, the focus is on achieving the lowest test error by selecting the most relevant subset of predictors."}
{"id": 533, "contributed_by": "group 6", "title": "", "section": "", "text": "In the realm of statistical model selection, the statistic that introduces a penalty to the training Residual Sum of Squares (RSS) to account for the inherent tendency of training error to underestimate test error is known as Cp, or Mallow's Cp. Cp is a widely-used criterion for model selection and is designed to strike a balance between model complexity and goodness of fit. It helps in preventing overfitting by penalizing the inclusion of excessive variables in a model. Other criteria like BIC (Bayesian Information Criterion), AIC (Akaike Information Criterion), and Adjusted R^2 are also commonly employed for model selection, each with its unique approach to addressing the trade-off between model complexity and fit."}
{"id": 534, "contributed_by": "group 6", "title": "", "section": "", "text": "The primary advantage of forward stepwise selection over best subset selection is that it can be applied even when the number of predictors is very large. Unlike best subset selection, which considers all possible subsets of predictors and can become computationally infeasible when dealing with a large number of predictors, forward stepwise selection starts with an empty model and sequentially adds predictors that provide the most improvement in model fit. This approach makes it more scalable and suitable for situations where you have a large number of potential predictors. While it doesn't guarantee the selection of the absolute best model (as option C suggests), it efficiently narrows down the predictor pool, making it a practical and effective feature selection method for high-dimensional datasets. It is not, however, guaranteed to yield the smallest model, as it may stop adding predictors when it deems the model fit satisfactory."}
{"id": 535, "contributed_by": "group 6", "title": "", "section": "", "text": "When dealing with a situation where the number of predictor variables (p) substantially exceeds the number of observations (n), one of the most appropriate methods to consider is Cross-validation. Cross-validation is particularly valuable in this scenario as it helps assess the model's performance by splitting the available data into subsets, often using techniques like k-fold cross-validation. This approach enables us to mitigate issues related to overfitting and evaluate the model's generalization capabilities. The other options, such as Best subset selection, Forward stepwise selection, and Backward stepwise selection, are also methods used for variable selection and model building, but they may not be as suitable when dealing with a high-dimensional dataset where p >> n. Therefore, in such cases, Cross-validation is a valuable technique to ensure robust model performance."}
{"id": 536, "contributed_by": "group 6", "title": "", "section": "", "text": "When it comes to selecting the optimal model from a set of models with different numbers of predictors, several measures are commonly used to assess their performance. These measures play a crucial role in the model selection process. One of the primary measures used is BIC (Bayesian Information Criterion), denoted as option A. BIC is a statistical criterion that considers the balance between model fit and model complexity, making it an important tool for model selection. Another vital measure is Cross-validation. Cross-validation involves partitioning the dataset into training and testing sets to evaluate a model's generalization performance. It helps in identifying models that perform well on unseen data. Additionally, Cp (Mallow's Cp), represented as option D, is another valuable measure. Cp assesses the adequacy of a model by considering its predictive accuracy and complexity. However, option C, R2 (Coefficient of Determination), is not typically used as a measure for selecting the optimal model. R2 is more commonly used as a goodness-of-fit measure, providing insights into the proportion of variance explained by the model. Therefore, R2 is not a preferred choice when it comes to model selection. In summary, among the given options, option C (R2) is NOT a measure for selecting the optimal model from a set of models with different numbers of predictors."}
{"id": 537, "contributed_by": "group 6", "title": "", "section": "", "text": "Linear regression, the primary goal of ridge regression is not to eliminate all predictors with weak correlations to the response variable or to fit a model with the fewest possible predictors. Instead, ridge regression aims to reduce the variance of coefficient estimates while including all predictors. This regularization technique helps prevent overfitting by adding a penalty term to the linear regression cost function, which forces the coefficients to be smaller. By doing so, ridge regression strikes a balance between the need to fit the data well and the need to prevent the model from becoming too sensitive to individual data points. Consequently, it maximizes the prediction accuracy by shrinking the coefficients but does not set all coefficients to zero."}
{"id": 538, "contributed_by": "group 6", "title": "", "section": "", "text": "In ridge regression, the tuning parameter \u03bb plays a crucial role. It controls the impact of the shrinkage penalty on the coefficients of the model. This means that \u03bb determines the degree to which the coefficient estimates are pushed towards zero, effectively reducing their magnitudes. This regularization technique is used to prevent overfitting by adding a penalty term to the linear regression cost function. The larger the value of \u03bb, the stronger the penalty, and the more the coefficients are shrunk."}
{"id": 539, "contributed_by": "group 6", "title": "", "section": "", "text": "Ridge regression, when contrasted with least squares, tackles the bias-variance trade-off differently. In the case of ridge regression, it seeks to reduce both bias and variance simultaneously. This technique accomplishes this by introducing a regularization term that penalizes large coefficients in the linear regression model. By doing so, it restricts the model's complexity and helps to mitigate overfitting. Consequently, this reduction in variance leads to a smaller risk of the model fitting the training data noise and, thus, generalizes better to new, unseen data. However, it's essential to note that the regularization term also introduces some bias into the model, which is a trade-off. Still, the overall effect is a reduction in both bias and variance. This approach makes ridge regression a valuable tool in scenarios where model accuracy needs to be balanced with stability and generalizability, effectively addressing the bias-variance trade-off."}
{"id": 540, "contributed_by": "group 6", "title": "", "section": "", "text": "The lasso, a popular technique in regression modeling, aims to address the issue of overfitting in predictive models. Overfitting occurs when a model includes too many predictors or features, leading to excessive complexity. This can result in a model that performs exceptionally well on the training data but poorly on new, unseen data. The lasso mitigates this problem by introducing a penalty term that encourages the model to set some of the coefficients of predictors to zero, effectively selecting a subset of the most relevant features. This process helps prevent overfitting and results in a more parsimonious model that is better at generalizing to new data."}
{"id": 541, "contributed_by": "group 6", "title": "", "section": "", "text": "Ridge regression, the behavior of coefficient estimates is influenced by the tuning parameter \u03bb. As \u03bb increases, the coefficient estimates undergo a specific transformation. Option A, which suggests that the coefficient estimates remain the same, is not accurate in this context. The correct answer is Option C, which states that the coefficient estimates decrease in magnitude. This decrease in magnitude is a fundamental characteristic of ridge regression. Ridge regression is a regularization technique used to mitigate multicollinearity and overfitting in linear regression. It does this by adding a penalty term to the ordinary least squares (OLS) objective function. The penalty term is proportional to the L2 norm of the coefficient vector, and \u03bb controls the strength of this penalty. As \u03bb increases, the impact of the penalty term on the coefficient estimates becomes more pronounced, leading to a decrease in the absolute values of the coefficients. This means that, in ridge regression, the coefficients tend to be smaller as \u03bb increases, effectively shrinking them towards zero."}
{"id": 542, "contributed_by": "group 6", "title": "", "section": "", "text": "The key difference between the ridge regression penalty and the lasso penalty lies in their regularization techniques. Ridge regression, represented by option A, employs an L2 penalty, which adds the sum of squared coefficients to the cost function. This results in all coefficient values being shrunk towards zero, although none are exactly zero. On the other hand, the lasso penalty, as described in option B, utilizes an L1 penalty. In the lasso, some coefficients can be precisely shrunk to zero, effectively performing feature selection."}
{"id": 543, "contributed_by": "group 6", "title": "", "section": "", "text": "The lasso, when applied to a linear model, has specific expectations regarding the coefficients. It assumes that most of the coefficients are exactly zero. This key characteristic sets the lasso apart from other regularization techniques. Unlike the ridge regression, which expects coefficients to be small but doesn't enforce them to be exactly zero, the lasso enforces a sparsity constraint, making it a useful tool for feature selection. The lasso operates under the assumption that many features are irrelevant or redundant for predicting the target variable. By pushing a substantial number of coefficients to zero, it effectively selects a subset of the most important features, simplifying the model. This makes the lasso a valuable method for preventing overfitting and improving the interpretability of linear models, particularly when dealing with high-dimensional datasets."}
{"id": 544, "contributed_by": "group 6", "title": "", "section": "", "text": "Ridge regression involves the use of a Bayesian framework to regularize linear regression models. In this context, the prior distribution for the coefficient values plays a crucial role. The Bayesian distribution that corresponds to ridge regression in terms of the prior for coefficient values is option A, which is a Gaussian distribution with mean zero and a standard deviation that is inversely proportional to the tuning parameter \u03bb."}
{"id": 545, "contributed_by": "group 6", "title": "", "section": "", "text": "Ridge regression, the tuning parameter (\u03bb) is selected using cross-validation. The process involves evaluating different values of \u03bb to determine the one that minimizes the cross-validation error. Cross-validation is a technique used to assess the model's performance by splitting the data into training and validation sets multiple times. For each \u03bb value, the model is trained on the training set, and its performance is measured on the validation set."}
{"id": 546, "contributed_by": "group 6", "title": "", "section": "", "text": "The lasso, a critical property is demonstrated when the cross-validation error corresponds to a set of coefficient estimates with only some variables being non-zero. This property is known as Feature selection. The Lasso (Least Absolute Shrinkage and Selection Operator) is a linear regression technique that introduces regularization by adding a penalty term to the linear regression cost function. This penalty term encourages sparsity in the coefficient estimates, which means that it promotes a situation where some of the coefficients are exactly zero. The goal of the Lasso is to select a subset of the most important features while reducing the impact of less relevant features. When the cross-validation error leads to a set of non-zero coefficients for only some variables, it indicates that the Lasso has successfully identified and selected the most significant features, effectively performing feature selection. This is crucial for avoiding overfitting, which occurs when the model is too complex and fits the noise in the data, as well as for addressing multicollinearity, where highly correlated predictors can cause problems in regression."}
{"id": 547, "contributed_by": "group 6", "title": "", "section": "", "text": "Dimension reduction methods are primarily used for variance control. These techniques aim to reduce the dimensionality of a dataset while retaining the most essential information, which is crucial for various data analysis tasks. They are not typically employed for feature selection as their primary goal is not to choose a subset of features but to transform the data to a lower-dimensional space. Nor are they primarily for model simplification, although in some cases, reducing dimensionality can make models more interpretable. Additionally, dimension reduction methods are not focused on coefficient optimization as they do not directly optimize model parameters. The primary objective of dimension reduction methods is to address issues related to high-dimensional data, where excessive features can lead to overfitting and computational inefficiency. By reducing dimensionality, these methods help in managing the trade-off between data complexity and computational feasibility, making it easier to extract meaningful patterns and reduce noise in the data. This, in turn, aids in better understanding and analysis of the dataset, enabling improved decision-making and predictive modeling."}
{"id": 548, "contributed_by": "group 6", "title": "", "section": "", "text": "The term 'dimension reduction' specifically pertains to the process of reducing the number of predictor variables. It aims to streamline the complexity of a dataset by identifying and retaining the most relevant predictors while discarding less informative ones. This reduction in predictor variables has various advantages, including simplifying the statistical analysis, reducing computational complexity, and often improving the model's interpretability and performance. It is not about reducing the number of observations, response variables, or coefficients. Rather, it focuses on selecting the most significant predictors that contribute to the overall understanding and accuracy of a statistical or machine learning model."}
{"id": 549, "contributed_by": "group 6", "title": "", "section": "", "text": "rincipal Components Regression (PCR) is a powerful technique in statistics and machine learning that combines aspects of both principal component analysis (PCA) and linear regression. One crucial aspect of PCR is selecting the number of principal components to use in the regression model. This choice significantly impacts the model's performance. PCR typically determines the number of principal components through cross-validation. Cross-validation is a robust method that assesses model performance by splitting the dataset into training and validation sets multiple times. For each split, it calculates the model's performance metrics, such as mean squared error, and then averages them. This process is repeated for various numbers of principal components, helping to identify the optimal number that minimizes prediction errors."}
{"id": 550, "contributed_by": "group 6", "title": "", "section": "", "text": "Principal Components Regression (PCR) is a technique used in statistics and data analysis. The key idea behind PCR is to leverage the power of principal components, which are linear combinations of the original predictor variables, to build a regression model. Instead of using all the original predictors, PCR focuses on using only the first few principal components to explain the variance in the data and make predictions. This reduces the dimensionality of the dataset, which can be particularly beneficial when dealing with high-dimensional data. PCR differs from other regression methods in that it doesn't involve feature selection or fitting a model using all the original predictors. Instead, it captures the most critical information in the data by using the first few principal components. This approach helps in dealing with multicollinearity and can improve the model's interpretability by reducing the complexity introduced by numerous predictors."}
{"id": 551, "contributed_by": "group 6", "title": "", "section": "", "text": "A high-dimensional data set is characterized by a number of features (p) that exceeds the number of observations (n). This is represented as p > n. In such a scenario, the data is said to be sparse, meaning that there are more features than data points to support them. This can lead to challenges in data analysis and modeling, as traditional methods may not be well-suited for handling such high-dimensionality."}
{"id": 552, "contributed_by": "group 6", "title": "", "section": "", "text": "In regression analysis, when the number of features (p) is as large as, or larger than, the number of observations (n), the least squares method yields a perfect fit to the data. However, this often leads to overfitting, where the model captures the noise in the training data rather than the underlying relationship between the features and the target variable. As a result, the model may not perform well on an independent test set. In other words, when there are more features than observations, the least squares method is able to find a solution that perfectly fits the training data, even if the relationship between the features and the target variable is not actually linear. This can lead to the model picking up on random noise in the data, which can then be used to make inaccurate predictions on new data."}
{"id": 553, "contributed_by": "group 6", "title": "", "section": "", "text": "Traditional approaches like Cp, AIC, and BIC are not appropriate in the high-dimensional setting when adjusting for the number of variables because estimating sigma square, the variance of the error term, is problematic in high dimensions. In high dimensions, the number of parameters to be estimated is often much larger than the number of observations. This can lead to overfitting, where the model is too complex and fits the noise in the data rather than the underlying patterns. As a result, the estimated value of sigma square can be biased downwards. This can lead to the underestimation of the model complexity, which can result in the selection of too many variables."}
{"id": 554, "contributed_by": "group 6", "title": "", "section": "", "text": "In the high-dimensional setting, extreme multicollinearity among variables occurs when any variable can be expressed as a linear combination of all other variables. This phenomenon poses a significant challenge to regression analysis as it makes it difficult to determine the truly predictive variables. When extreme multicollinearity is present, the estimated regression coefficients become unstable and unreliable. This is because small changes in the data can lead to large changes in the estimated coefficients. As a result, it becomes difficult to draw meaningful conclusions about the relationships between the variables. In addition, extreme multicollinearity can make it difficult to identify the best model for the data. This is because the estimated coefficients are so sensitive to the choice of variables included in the model. As a result, it is possible to obtain different models with different sets of significant variables, even when the data is the same."}
{"id": 555, "contributed_by": "group 6", "title": "", "section": "", "text": "Traditional measures of model fit, such as the sum of squared errors (SSE) and R2 statistics, can be misleading in the high-dimensional setting. This is because these measures are based on the assumption that the number of features is small relative to the number of observations. However, in the high-dimensional setting, the number of features can be much larger than the number of observations. This can lead to a phenomenon known as the curse of dimensionality. The curse of dimensionality refers to the fact that as the number of features increases, the volume of the feature space increases exponentially. This can make it difficult to find a model that generalizes well to unseen data. In particular, traditional measures of model fit can be inflated in the high-dimensional setting, even if the model does not actually fit the data well."}
{"id": 556, "contributed_by": "group 6", "title": "", "section": "", "text": "Best subset selection is a method of feature selection that aims to identify the optimal subset of predictors for a given model. This is done by evaluating all possible subsets of predictors and selecting the subset that produces the best model performance. For low-dimensional data, the number of possible subsets of predictors is relatively small. As the number of possible subsets of predictors increases, the computational cost of evaluating all possible subsets increases exponentially. This is because each subset of predictors must be evaluated using a model selection criterion."}
{"id": 557, "contributed_by": "group 6", "title": "", "section": "", "text": "So far in this book, we have mostly focused on linear models. Linear models are relatively simple to describe and implement, and have advantages over other approaches in terms of interpretation and inference. However, standard linear regression can have significant limitations in terms of predictive power. This is because the linearity assumption is almost always an approximation, and sometimes a poor one."}
{"id": 558, "contributed_by": "group 6", "title": "", "section": "", "text": "In Chapter 6 we see that we can improve upon least squares using ridge regression, the lasso, principal components regression, and other techniques. In that setting, the improvement is obtained by reducing the complexity of the linear model, and hence the variance of the estimates."}
{"id": 559, "contributed_by": "group 6", "title": "", "section": "", "text": "Polynomial regression extends the linear model by adding extra predictors, obtained by raising each of the original predictors to a power. For example, a cubic regression uses three variables, X, X2, and X3, as predictors. This approach provides a simple way to provide a nonlinear fit to data."}
{"id": 560, "contributed_by": "group 6", "title": "", "section": "", "text": "Regression splines are more flexible than polynomials and step functions, and in fact are an extension of the two. They involve dividing the range of X into K distinct regions. Within each region, a polynomial function is fit to the data. However, these polynomials are constrained so that they join smoothly at the region boundaries, or knots."}
{"id": 561, "contributed_by": "group 6", "title": "", "section": "", "text": "Smoothing splines are similar to regression splines, but arise in a slightly different situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty."}
{"id": 562, "contributed_by": "group 6", "title": "", "section": "", "text": "Generalized additive models allow us to extend the methods above to deal with multiple predictors. In Sections 7.1\u20137.6, we present a number of approaches for modeling the relationship between a response Y and a single predictor X in a flexible way. In Section 7.7, we show that these approaches can be seamlessly integrated in order to model a response Y as a function of several predictors X1,...,Xp."}
{"id": 563, "contributed_by": "group 6", "title": "", "section": "", "text": "Using polynomial functions of the features as predictors in a linear model imposes a global structure on the non-linear function of X. We can instead use step functions in order to avoid imposing such a global structure. Here we break the range of X into bins, and fit a different constant in each bin."}
{"id": 564, "contributed_by": "group 6", "title": "", "section": "", "text": "In greater detail, we create cutpoints c1, c2,...,cK in the range of X, and then construct K + 1 new variables... For a given value of X, at most one of C1, C2,...,CK can be non-zero."}
{"id": 565, "contributed_by": "group 6", "title": "", "section": "", "text": "where I(\u00b7) is an indicator function that returns a 1 if the condition is true, and returns a 0 otherwise. For example, I(cK \u2264 X) equals 1 if cK \u2264 X, and equals 0 otherwise. These are sometimes called dummy variables."}
{"id": 566, "contributed_by": "group 6", "title": "", "section": "", "text": "Nevertheless, step function approaches are very popular in biostatistics and epidemiology, among other disciplines. For example, 5-year age groups are often used to define the bins."}
{"id": 567, "contributed_by": "group 6", "title": "", "section": "", "text": "Unfortunately, unless there are natural breakpoints in the predictors, piecewise-constant functions can miss the action. For example, in the left-hand panel of Figure 7.2, the first bin clearly misses the increasing trend of wage with age."}
{"id": 568, "contributed_by": "group 6", "title": "", "section": "", "text": "If we don\u2019t put any constraints on g(xi), then we can always make RSS zero simply by choosing g such that it interpolates all of the yi. Such a function would woefully overfit the data\u2014it would be far too flexible."}
{"id": 569, "contributed_by": "group 6", "title": "", "section": "", "text": "We see that \u03bb controls the bias-variance trade-off of the smoothing spline."}
{"id": 570, "contributed_by": "group 6", "title": "", "section": "", "text": "When \u03bb = 0, then the penalty term in (7.11) has no effect, and so the function g will be very jumpy and will exactly interpolate the training observations."}
{"id": 571, "contributed_by": "group 6", "title": "", "section": "", "text": "The notation g$$(t) indicates the second derivative of the function g. The first derivative g$(t) measures the slope of a function at t, and the second derivative corresponds to the amount by which the slope is changing. Hence, broadly speaking, the second derivative of a function is a measure of its roughness: it is large in absolute value if g(t) is very wiggly near t, and it is close to zero otherwise."}
{"id": 572, "contributed_by": "group 6", "title": "", "section": "", "text": "The function g(x) that minimizes (7.11) can be shown to have some special properties: it is a piecewise cubic polynomial with knots at the unique values of x1,...,xn, and continuous first and second derivatives at each knot. Furthermore, it is linear in the region outside of the extreme knots."}
{"id": 573, "contributed_by": "group 6", "title": "", "section": "", "text": "When \u03bb \u2192 \u221e, g will be perfectly smooth\u2014it will just be a straight line that passes as closely as possible to the training points. In fact, in this case, g will be the linear least squares line, since the loss function in (7.11) amounts to minimizing the residual sum of squares."}
{"id": 574, "contributed_by": "group 6", "title": "", "section": "", "text": "Local regression is a diferent approach for ftting fexible non-linear func- local regression tions, which involves computing the ft at a target point x0 using only the nearby training observations."}
{"id": 575, "contributed_by": "group 6", "title": "", "section": "", "text": "The span plays a role like that of the tuning parameter \u03bb in smooth- ing splines: it controls the fexibility of the non-linear ft. The smaller the value of s, the more local and wiggly will be our ft; alternatively, a very large value of s will lead to a global ft to the data using all of the training observations."}
{"id": 576, "contributed_by": "group 6", "title": "", "section": "", "text": "Local regression is sometimes referred to as a memory-based procedure, because like nearest-neighbors, we need all the training data each time we wish to compute a prediction."}
{"id": 577, "contributed_by": "group 6", "title": "", "section": "", "text": "However, local regression can perform poorly if p is much larger than about 3 or 4 because there will generally be very few training observations close to x0."}
{"id": 578, "contributed_by": "group 6", "title": "", "section": "", "text": "In order to perform local regression, there are a number of choices to be made, such as how to defne the weighting function K, and whether to ft a linear, constant, or quadratic regression in Step 3."}
{"id": 579, "contributed_by": "group 6", "title": "", "section": "", "text": "In a setting with multiple features X1, X2,...,Xp, one very useful generalization involves ftting a multiple linear regression model that is global in some variables, but local in another, such as time."}
{"id": 580, "contributed_by": "group 6", "title": "", "section": "", "text": "GAMs allow us to ft a non-linear fj to each Xj , so that we can automatically model non-linear relationships that standard linear regression will miss. This means that we do not need to manually try out many diferent transformations on each variable individually."}
{"id": 581, "contributed_by": "group 6", "title": "", "section": "", "text": "The non-linear fts can potentially make more accurate predictions for the response Y ."}
{"id": 582, "contributed_by": "group 6", "title": "", "section": "", "text": "Because the model is additive, we can examine the efect of each Xj on Y individually while holding all of the other variables fxed."}
{"id": 583, "contributed_by": "group 6", "title": "", "section": "", "text": "The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the form Xj \u00d7 Xk."}
{"id": 584, "contributed_by": "group 6", "title": "", "section": "", "text": "In addition we can add low-dimensional interaction functions of the form fjk(Xj , Xk) into the model; such terms can be ft using two-dimensional smoothers such as local regression, or two-dimensional splines (not covered here)."}
{"id": 585, "contributed_by": "group 6", "title": "", "section": "", "text": "For fully general models, we have to look for even more fexible approaches such as random forests and boosting, described in Chapter 8. GAMs provide a useful compromise between linear and fully nonparametric models."}
{"id": 586, "contributed_by": "group 6", "title": "", "section": "", "text": "A natural way to extend the multiple linear regression model yi = \u03b20 + \u03b21xi1 + \u03b22xi2 + \u00b7\u00b7\u00b7 + \u03b2pxip + \"i in order to allow for non-linear relationships between each feature and the response is to replace each linear component \u03b2jxij with a (smooth) nonlinear function fj (xij ). We would then write the model as yi = \u03b20 +0p j=1 fj (xij ) + \"i = \u03b20 + f1(xi1) + f2(xi2) + \u00b7\u00b7\u00b7 + fp(xip) + \"i. (7.15) This is an example of a GAM. It is called an additive model because we calculate a separate fj for each Xj , and then add together all of their contributions."}
{"id": 587, "contributed_by": "group 6", "title": "", "section": "", "text": "This is an example of a GAM. It is called an additive model because we calculate a separate fj for each Xj , and then add together all of their contributions."}
{"id": 588, "contributed_by": "group 6", "title": "", "section": "", "text": "In Sections 7.1\u20137.6, we discuss many methods for ftting functions to a single variable. The beauty of GAMs is that we can use these methods as building blocks for ftting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of ftting the model wage = \u03b20 + f1(year) + f2(age) + f3(education) + \" (7.16) on the Wage data."}
{"id": 589, "contributed_by": "group 6", "title": "", "section": "", "text": "The ftted functions in Figures 7.11 and 7.12 look rather similar. In most situations, the diferences in the GAMs obtained using smoothing splines versus natural splines are small."}
{"id": 590, "contributed_by": "group 6", "title": "", "section": "", "text": "The beauty of GAMs is that we can use these methods as building blocks for ftting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of ftting the model wage = \u03b20 + f1(year) + f2(age) + f3(education) + \" (7.16) on the Wage data."}
{"id": 591, "contributed_by": "group 7", "title": "", "section": "", "text": "In this chapter, we describe tree-based methods for regression and classification. These involve stratifying or segmenting the predictor space into a number of simple regions."}
{"id": 592, "contributed_by": "group 7", "title": "", "section": "", "text": "Decision trees can be applied to both regression and classification problems."}
{"id": 593, "contributed_by": "group 7", "title": "", "section": "", "text": "Bayesian additive regression trees (BART) is another ensemble method that uses decision trees as its building blocks. Each tree is constructed in a random manner as in bagging and random forests, and each tree tries to capture signal not yet accounted for by the current model, as in boosting."}
{"id": 594, "contributed_by": "group 7", "title": "", "section": "", "text": "In boosting, because the growth of a particular tree takes into account the other trees that have already been grown, smaller trees are typically sufficient. Using smaller trees can aid in interpretability as well; for instance, using stumps leads to an additive model."}
{"id": 595, "contributed_by": "group 7", "title": "", "section": "", "text": "Boosting has three tuning parameters: The number of trees B, the shrinkage parameter \u03bb, and the number d of splits in each tree. Unlike bagging and random forests, boosting can overfit if B is too large."}
{"id": 596, "contributed_by": "group 7", "title": "", "section": "", "text": "Classification trees are very similar to regression trees. The main difference is that the response variable is qualitative rather than quantitative."}
{"id": 597, "contributed_by": "group 7", "title": "", "section": "", "text": "Linear models like linear regression make certain assumptions about the functional form of f. Trees do not make such assumptions and are more flexible."}
{"id": 598, "contributed_by": "group 7", "title": "", "section": "", "text": "Trees are simple to understand and interpret, and the process of growing a tree can be easily visualized."}
{"id": 599, "contributed_by": "group 7", "title": "", "section": "", "text": "Trees generally do not have the same level of predictive accuracy as some of the other regression and classification approaches."}
{"id": 600, "contributed_by": "group 7", "title": "", "section": "", "text": "Boosting involves creating multiple copies of the original training data set using the bootstrap, fitting a separate decision tree to each copy, and then combining all of the trees in order to create a single predictive model. Each tree is grown using information from previously grown trees."}
{"id": 601, "contributed_by": "group 7", "title": "", "section": "", "text": "Random forests overcome this problem by forcing each split to consider only a subset of the predictors. Therefore, on average (p - m)/p of the splits will not even consider the strong predictor, and so other predictors will have more of a chance."}
{"id": 602, "contributed_by": "group 7", "title": "", "section": "", "text": "An ensemble method is an approach that combines many simple \u201cbuilding block\u201d models in order to obtain a single and potentially very powerful model. These simple building block models are sometimes known as weak learners."}
{"id": 603, "contributed_by": "group 7", "title": "", "section": "", "text": "Bagging involves creating multiple copies of the original training data set using the bootstrap, fitting a separate decision tree to each copy, and then combining all of the trees in order to create a single predictive model."}
{"id": 604, "contributed_by": "group 7", "title": "", "section": "", "text": "It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. This is referred to as the out-of-bag (OOB) observations."}
{"id": 605, "contributed_by": "group 7", "title": "", "section": "", "text": "Random forests provide an improvement over bagged trees by way of a small tweak that decorrelates the trees. Each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors."}
{"id": 606, "contributed_by": "group 7", "title": "", "section": "", "text": "Trees can easily handle qualitative predictors without the need to create dummy variables. Unfortunately, trees generally do not have the same level of predictive accuracy as some of the other regression and classification approaches seen in this book."}
{"id": 607, "contributed_by": "group 7", "title": "", "section": "", "text": "An ensemble method is an approach that combines many simple \u201cbuilding block\u201d models in order to obtain a single and potentially very powerful model. These simple building block models are sometimes known as weak learners, since they may lead to mediocre predictions on their own."}
{"id": 608, "contributed_by": "group 7", "title": "", "section": "", "text": "The decision trees discussed in Section 8.1 suffer from high variance. This means that if we split the training data into two parts at random, and fit a decision tree to both halves, the results that we get could be quite different."}
{"id": 609, "contributed_by": "group 7", "title": "", "section": "", "text": "Bootstrap aggregation, or bagging, is a general-purpose procedure for reducing the variance of a statistical learning method; we introduce it here because it is particularly useful and frequently used in the context of decision trees."}
{"id": 610, "contributed_by": "group 7", "title": "", "section": "", "text": "Boosting involves combining a large number of decision trees. Each tree is grown using information from previously grown trees. Boosting does not involve bootstrap sampling; instead each tree is fit on a modified version of the original data set."}
{"id": 611, "contributed_by": "group 7", "title": "", "section": "", "text": "In subsequent iterations, BART updates each of the K trees, one at a time. In the bth iteration, to update the kth tree, we subtract from each response value the predictions from all but the kth tree, in order to obtain a partial residual."}
{"id": 612, "contributed_by": "group 7", "title": "", "section": "", "text": "Rather than fitting a fresh tree to this partial residual, BART randomly chooses a perturbation to the tree from the previous iteration from a set of possible perturbations, favoring ones that improve the fit to the partial residual."}
{"id": 613, "contributed_by": "group 7", "title": "", "section": "", "text": "Random forests provide an improvement over bagged trees by way of a small tweak that decorrelates the trees. As in bagging, we build a number of decision trees on bootstrapped training samples. But when building these decision trees, each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors."}
{"id": 614, "contributed_by": "group 7", "title": "", "section": "", "text": "The output of BART is a collection of prediction models, for b=1,2,...,B."}
{"id": 615, "contributed_by": "group 7", "title": "", "section": "", "text": "We typically throw away the first few of these prediction models, since models obtained in the earlier iterations \u2014 known as the burn-in period \u2014 tend not to provide very good results."}
{"id": 616, "contributed_by": "group 7", "title": "", "section": "", "text": "In this chapter, we discuss the support vector machine (SVM), an approach for classification that was developed in the computer science community in the 1990s and that has grown in popularity since then. SVMs have been shown to perform well in a variety of settings, and are often considered one of the best 'out of the box' classifiers."}
{"id": 617, "contributed_by": "group 7", "title": "", "section": "", "text": "The support vector machine is a generalization of a simple and intuitive classifier called the maximal margin classifier, which we introduce in Section 9.1. Though it is elegant and simple, we will see that this classifier unfortunately cannot be applied to most data sets, since it requires that the classes be separable by a linear boundary."}
{"id": 618, "contributed_by": "group 7", "title": "", "section": "", "text": "In a p-dimensional space, a hyperplane is a flat affine subspace of dimension p-1. For instance, in two dimensions, a hyperplane is a flat one-dimensional subspace\u2014in other words, a line. In three dimensions, a hyperplane is a flat two-dimensional subspace\u2014that is, a plane."}
{"id": 619, "contributed_by": "group 7", "title": "", "section": "", "text": "The mathematical definition of a hyperplane is quite simple. In two dimensions, a hyperplane is defined by the equation \u03b20 + \u03b21X1 + \u03b22X2 = 0 for parameters \u03b20, \u03b21, and \u03b22. When we say that this equation 'defines' the hyperplane, we mean that any point for which this equation holds is a point on the hyperplane."}
{"id": 620, "contributed_by": "group 7", "title": "", "section": "", "text": "An alternative to the Gini index is entropy, given by a measure that takes on a value near zero if the p are all near zero or near one. Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure."}
{"id": 621, "contributed_by": "group 7", "title": "", "section": "", "text": "The Gini index is defined by a measure of total variance across the K classes. It is not hard to see that the Gini index takes on a small value if all of the p are close to zero or one. For this reason the Gini index is referred to as a measure of node purity\u2014a small value indicates that a node contains predominantly observations from a single class."}
{"id": 622, "contributed_by": "group 7", "title": "", "section": "", "text": "Equivalently, a separating hyperplane has the property that y (\u03b20 + \u03b21 x1 + \u03b22 x2 + ... + \u03b2p xp) > 0 for all i=1,...,n. If a separating hyperplane exists, we can use it to construct a very natural classifier: a test observation is assigned a class depending on which side of the hyperplane it is located."}
{"id": 623, "contributed_by": "group 7", "title": "", "section": "", "text": "In general, if our data can be perfectly separated using a hyperplane, then there will in fact exist an infinite number of such hyperplanes. This is because a given separating hyperplane can usually be shifted a tiny bit up or down, or rotated, without coming into contact with any of the observations."}
{"id": 624, "contributed_by": "group 7", "title": "", "section": "", "text": "A natural choice is the maximal margin hyperplane (also known as the optimal separating hyperplane), which is the separating hyperplane that is farthest from the training observations. That is, we can compute the (perpendicular) distance from each training observation to a given separating hyperplane; the smallest such distance is the minimal distance from the observations to the hyperplane, and is known as the margin."}
{"id": 625, "contributed_by": "group 7", "title": "", "section": "", "text": "The maximal margin hyperplane is the separating hyperplane for which the margin is largest\u2014that is, it is the hyperplane that has the farthest minimum distance to the training observations. We can then classify a test observation based on which side of the maximal margin hyperplane it lies."}
{"id": 626, "contributed_by": "group 7", "title": "", "section": "", "text": "The maximal margin classifier is a very natural way to perform classification, if a separating hyperplane exists. However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal margin classifier."}
{"id": 627, "contributed_by": "group 7", "title": "", "section": "", "text": "The support vector classifier, sometimes called a soft margin classifier, does exactly this. Rather than seeking the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane."}
{"id": 628, "contributed_by": "group 7", "title": "", "section": "", "text": "An observation can be not only on the wrong side of the margin, but also on the wrong side of the hyperplane. In fact, when there is no separating hyperplane, such a situation is inevitable. Observations on the wrong side of the hyperplane correspond to training observations that are misclassified by the support vector classifier."}
{"id": 629, "contributed_by": "group 7", "title": "", "section": "", "text": "The support vector classifier classifies a test observation depending on which side of a hyperplane it lies. The hyperplane is chosen to correctly separate most of the training observations into the two classes, but may misclassify a few observations."}
{"id": 630, "contributed_by": "group 7", "title": "", "section": "", "text": "That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations. The support vector classifier, sometimes called a soft margin classifier, does exactly this."}
{"id": 631, "contributed_by": "group 7", "title": "", "section": "", "text": "A classification tree is very similar to a regression tree, except that it is used to predict a qualitative response rather than a quantitative one. In interpreting the results of a classification tree, we are often interested not only in the class prediction corresponding to a particular terminal node region, but also in the class proportions among the training observations that fall into that region."}
{"id": 632, "contributed_by": "group 7", "title": "", "section": "", "text": "In practice, C is treated as a tuning parameter that is generally chosen via cross-validation. C controls the bias-variance trade-off of the statistical learning technique. When C is small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance."}
{"id": 633, "contributed_by": "group 7", "title": "", "section": "", "text": "The support vector machine (SVM) is an extension of the support vector classifier that results from enlarging the feature space in a specific way, using kernels. The kernel approach is simply an efficient computational approach for enacting this idea."}
{"id": 634, "contributed_by": "group 7", "title": "", "section": "", "text": "A kernel is a function that quantifies the similarity of two observations. For instance, we could simply take K(x ,x )= x x , which would just give us back the support vector classifier. This is known as a linear kernel because the support vector classifier is linear in the features."}
{"id": 635, "contributed_by": "group 7", "title": "", "section": "", "text": "Using such a kernel with d > 1, instead of the standard linear kernel, in the support vector classifier algorithm leads to a much more flexible decision boundary. It essentially amounts to fitting a support vector classifier using 2p features."}
{"id": 636, "contributed_by": "group 7", "title": "", "section": "", "text": "The support vector machine (SVM) is an extension of the support vector classifier that results from enlarging the feature space in a specific way, using kernels. The kernel approach is simply an efficient computational approach for enacting this idea."}
{"id": 637, "contributed_by": "group 7", "title": "", "section": "", "text": "Therefore, a better strategy is to grow a very large tree T, and then prune it back in order to obtain a subtree. How do we determine the best way to prune the tree? Intuitively, our goal is to select a subtree that leads to the lowest test error rate."}
{"id": 638, "contributed_by": "group 7", "title": "", "section": "", "text": "One possible alternative to the process described above is to build the tree only so long as the decrease in the RSS due to each split exceeds some (high) threshold. This strategy will result in smaller trees, but is too short-sighted since a seemingly worthless split early on in the tree might be followed by a very good split\u2014that is, a split that leads to a large reduction in RSS later on."}
{"id": 639, "contributed_by": "group 7", "title": "", "section": "", "text": "What is the advantage of using a kernel rather than simply enlarging the feature space using functions of the original features? One advantage is computational, and it amounts to the fact that using kernels, one need only compute K(x ,x ) for all n distinct pairs i, i . This can be done without explicitly working in the enlarged feature space."}
{"id": 640, "contributed_by": "group 7", "title": "", "section": "", "text": "It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one and one-versus-all approaches."}
{"id": 641, "contributed_by": "group 7", "title": "", "section": "", "text": "When SVMs were first introduced in the mid-1990s, they made quite a splash in the statistical and machine learning communities. This was due in part to their good performance, good marketing, and also to the fact that the underlying approach seemed both novel and mysterious."}
{"id": 642, "contributed_by": "group 7", "title": "", "section": "", "text": "However, it turns out that the hinge loss function is closely related to the loss function used in logistic regression, also shown in Figure 9.12."}
{"id": 643, "contributed_by": "group 7", "title": "", "section": "", "text": "Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is \u201cno\u201d. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels."}
{"id": 644, "contributed_by": "group 7", "title": "", "section": "", "text": "The SVM and logistic regression loss functions are compared, as a function of yi is greater than 1, then the SVM loss is zero, since this corresponds to an observation that is on the correct side of the margin."}
{"id": 645, "contributed_by": "group 7", "title": "", "section": "", "text": "When the classes are well separated, SVMs tend to behave better than logistic regression; in more overlapping regimes, logistic regression is often preferred."}
{"id": 646, "contributed_by": "group 7", "title": "", "section": "", "text": "Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualitative response), called support vector regression. In Chapter 3, we saw that least squares regression seeks coefficients \u03b20, \u03b21,..., \u03b2p such that the sum of squared residuals is as small as possible."}
{"id": 647, "contributed_by": "group 7", "title": "", "section": "", "text": "Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualitative response), called support vector regression."}
{"id": 648, "contributed_by": "group 7", "title": "", "section": "", "text": "Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen in Chapter 7. However, for historical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods."}
{"id": 649, "contributed_by": "group 7", "title": "", "section": "", "text": "In this lab, we use the sklearn.svm library to demonstrate the support vector classifier and the support vector machine. We import some of our usual libraries."}
{"id": 650, "contributed_by": "group 7", "title": "", "section": "", "text": "We now use the SupportVectorClassifier() function (abbreviated SVC()) from sklearn to fit the support vector classifier for a given value of the parameter C. The C argument allows us to specify the cost of a violation to the margin."}
{"id": 651, "contributed_by": "group 7", "title": "", "section": "", "text": "In order to fit an SVM using a non-linear kernel, we once again use the SVC() estimator. However, now we use a different value of the parameter kernel. We first generate some data with a non-linear class boundary."}
{"id": 652, "contributed_by": "group 7", "title": "", "section": "", "text": "SVMs and support vector classifiers output class labels for each observation. However, it is also possible to obtain fitted values for each observation, which are the numerical scores used to obtain the class labels."}
{"id": 653, "contributed_by": "group 7", "title": "", "section": "", "text": "If the response is a factor containing more than two levels, then the SVC() function will perform multi-class classification using either the one-versus-one approach or one-versus-rest. We explore that setting briefly here by generating a third class of observations."}
{"id": 654, "contributed_by": "group 7", "title": "", "section": "", "text": "The data is randomly split into training and testing groups. We then fit the training data using the SVC() estimator with a radial kernel. The plot shows that the resulting SVM has a decidedly non-linear boundary."}
{"id": 655, "contributed_by": "group 7", "title": "", "section": "", "text": "In this example, the SVM appears to provide accurate predictions. By increasing gamma, we can produce a more flexible fit and generate further improvements in accuracy."}
{"id": 656, "contributed_by": "group 7", "title": "", "section": "", "text": "However, these ROC curves are all on the training data. We are really more interested in the level of prediction accuracy on the test data. When we compute the ROC curves on the test data,  appears to provide the most accurate results."}
{"id": 657, "contributed_by": "group 7", "title": "", "section": "", "text": "We now examine the Khan data set, which consists of a number of tissue samples corresponding to four distinct types of small round blue cell tumors. For each tissue sample, gene expression measurements are available. The data set consists of training data, xtrain and ytrain, and testing data, xtest and ytest."}
{"id": 658, "contributed_by": "group 7", "title": "", "section": "", "text": "Writing (2020), deep learning is a very active area of research in the machine learning and artificial intelligence communities. The cornerstone of deep learning is the neural network. Neural networks rose to fame in the late 1980s."}
{"id": 659, "contributed_by": "group 7", "title": "", "section": "", "text": "Neural networks were the impetus for the popular Neural Information Processing Systems meetings (NeurIPS, formerly NIPS) held every year. This was followed by a synthesis stage, where the properties of neural networks were analyzed and the methodology stabilized."}
{"id": 660, "contributed_by": "group 7", "title": "", "section": "", "text": "Then came SVMs, boosting, and random forests, and neural networks fell somewhat from favor. Part of the reason was that neural networks required a lot of tinkering, while the new methods were more automatic."}
{"id": 661, "contributed_by": "group 7", "title": "", "section": "", "text": "Neural networks resurfaced after 2010 with the new name deep learning, with new architectures, and a string of success stories on niche problems like image and video classification, speech and text modeling."}
{"id": 662, "contributed_by": "group 7", "title": "", "section": "", "text": "Many in the field believe that the major reason for these successes is the availability of ever-larger training datasets, made possible by the wide-scale use of digitization in science and industry."}
{"id": 663, "contributed_by": "group 7", "title": "", "section": "", "text": "In this chapter, basics of neural networks and deep learning are discussed. Specializations for specific problems, such as convolutional neural networks (CNNs) for image classification, and recurrent neural networks (RNNs) for time series are also covered."}
{"id": 664, "contributed_by": "group 7", "title": "", "section": "", "text": "A neural network takes an input vector of p variables and builds a nonlinear function to predict the response Y. Neural networks differ from other methods due to the particular structure of the model."}
{"id": 665, "contributed_by": "group 7", "title": "", "section": "", "text": "Figure 10.1 shows a simple feed-forward neural network for modeling a quantitative response using p = 4 predictors. In neural network terminology, the features make up the units in the input layer."}
{"id": 666, "contributed_by": "group 7", "title": "", "section": "", "text": "The functions in the hidden layer are not fixed in advance but are learned during the training of the network. The sigmoid or ReLU activations do not have a limitation on their usage."}
{"id": 667, "contributed_by": "group 7", "title": "", "section": "", "text": "Fitting a neural network requires estimating the unknown parameters. For a quantitative response, typically squared-error loss is used. The parameters are chosen to minimize the difference between the predicted and actual values."}
{"id": 668, "contributed_by": "group 7", "title": "", "section": "", "text": "Modern neural networks typically have more than one hidden layer. A single hidden layer with a large number of units can approximate most functions. However, with multiple layers, the learning task is easier."}
{"id": 669, "contributed_by": "group 7", "title": "", "section": "", "text": "A large dense network on the famous MNIST handwritten digit dataset is illustrated. Every image in the dataset has p = 28 x 28 = 784 pixels, representing the grayscale value of the written digit in that square."}
{"id": 670, "contributed_by": "group 7", "title": "", "section": "", "text": "The output is the class label, represented by a vector of 10 dummy variables. In the machine learning community, this representation is known as one-hot encoding."}
{"id": 671, "contributed_by": "group 7", "title": "", "section": "", "text": "Neural networks rebounded around 2010 with big successes in image classification. Massive databases of labeled images were accumulated, leading to the development of convolutional neural networks (CNNs) for classifying such images."}
{"id": 672, "contributed_by": "group 7", "title": "", "section": "", "text": "CNNs recognize specific features or patterns in the image. They combine convolution layers and pooling layers. Convolution layers search for instances of small patterns in the image, while pooling layers downsample these patterns."}
{"id": 673, "contributed_by": "group 7", "title": "", "section": "", "text": "A convolution layer is made up of convolution filters. Each filter is a template determining whether a particular local feature is present in an image. Convolution essentially involves multiplying matrix elements and summing the results."}
{"id": 674, "contributed_by": "group 7", "title": "", "section": "", "text": "When a filter is convolved with an image, areas of the image resembling the filter are given large values. Thus, the convolved image highlights regions resembling the convolution filter."}
{"id": 675, "contributed_by": "group 7", "title": "", "section": "", "text": "In a convolution layer, we use a whole bank of filters to pick out a variety of differently-oriented edges and shapes in the image. Using predefined filters in this way is standard practice in image processing. With CNNs the filters are learned for the specific classification task."}
{"id": 676, "contributed_by": "group 7", "title": "", "section": "", "text": "Since the input image is in color, it has three channels represented by a three-dimensional feature map. Each channel is a two-dimensional feature map \u2014 one for red, one for green, and one for blue. A single convolution filter will also have three channels, one per color, each of dimension 3\u00d73, with potentially different filter weights."}
{"id": 677, "contributed_by": "group 7", "title": "", "section": "", "text": "A pooling layer provides a way to condense a large image into a smaller summary image. The max pooling operation summarizes each non-overlapping 2 \u00d7 2 block of pixels in an image using the maximum value in the block. This reduces the size of the image by a factor of two in each direction."}
{"id": 678, "contributed_by": "group 7", "title": "", "section": "", "text": "Deep CNNs have many layers. At the input layer, we see the three-dimensional feature map of a color image. Each convolution filter produces a new channel at the first hidden layer. This is followed by a max-pool layer, which reduces the size of the feature map in each channel by a factor of four: two in each dimension."}
{"id": 679, "contributed_by": "group 7", "title": "", "section": "", "text": "Data augmentation involves replicating each training image many times, with each replicate randomly distorted in a natural way. Typical distortions are zoom, horizontal and vertical shift, shear, small rotations, and horizontal flips. This kind of fattening of the data is similar in spirit to ridge regularization."}
{"id": 680, "contributed_by": "group 7", "title": "", "section": "", "text": "IMDb ratings are short documents where viewers have written critiques of movies. The response is the sentiment of the review, which can be positive or negative. The bag-of-words model summarizes a document by the words present and ignores their context."}
{"id": 681, "contributed_by": "group 7", "title": "", "section": "", "text": "The bag-of-n-grams model, for example, a bag of 2-grams records the consecutive co-occurrence of every distinct pair of words. This model takes into account the context of the words in the document."}
{"id": 682, "contributed_by": "group 7", "title": "", "section": "", "text": "There are models that treat the document as a sequence, taking into account all the words in the context of those that preceded and those that follow. This approach has applications in weather forecasting, speech recognition, and language translation among others."}
{"id": 683, "contributed_by": "group 7", "title": "", "section": "", "text": "RNNs, or Recurrent Neural Networks, are designed to handle sequences. These sequences can range from time series data to textual data like book reviews. One of the advantages of RNNs is their ability to maintain context through the sequence, which is essential in understanding the data's narrative and theme."}
{"id": 684, "contributed_by": "group 7", "title": "", "section": "", "text": "Embedding layers in RNNs can transform one-hot encoded vectors into a lower-dimensional space. This transformation is useful when dealing with large dictionaries of words. Pretrained embeddings like word2vec and GloVe are examples of embedding matrices that can be used."}
{"id": 685, "contributed_by": "group 7", "title": "", "section": "", "text": "In time series forecasting, using RNNs can be quite effective. For instance, in predicting stock prices, RNNs can utilize historical data to forecast future prices. The model can be trained on past data and then used to predict future data points."}
{"id": 686, "contributed_by": "group 7", "title": "", "section": "", "text": "LSTM, which stands for Long Short-Term Memory, is an advanced form of RNN. It has the ability to remember patterns over long sequences and is particularly effective for tasks that require understanding over extended periods of context."}
{"id": 687, "contributed_by": "group 7", "title": "", "section": "", "text": "The concept of weight sharing in RNNs allows the model to use the same weights across different elements in a sequence. This is similar to the use of filters in convolutional neural networks, ensuring consistency and reducing the number of parameters."}
{"id": 688, "contributed_by": "group 7", "title": "", "section": "", "text": "Autoregression models can predict a value based on its past values. They differ from RNNs in their approach but can be quite effective in time series forecasting. The choice between an autoregression model and an RNN often depends on the specific application."}
{"id": 689, "contributed_by": "group 7", "title": "", "section": "", "text": "In the realm of sentiment analysis, RNNs have shown significant potential. For instance, when analyzing movie reviews, an RNN can process the sequence of words in a review and predict the sentiment of the entire document."}
{"id": 690, "contributed_by": "group 7", "title": "", "section": "", "text": "One-dimensional convolutional neural networks can be used to treat the sequence of vectors as an image. By sliding along the sequence, the convolution filter can effectively learn specific phrases or patterns relevant to the learning task."}
{"id": 691, "contributed_by": "group 8", "title": "Survival and Censoring Times", "section": "11.1", "text": "For each individual, we suppose that there is a true survival time, T, as well as a true censoring time, C. (The survival time is also known as the failure time or the event time.) The survival time represents the time at which the event of interest occurs: for instance, the time at which the patient dies, or the customer cancels his or her subscription. By contrast, the censoring time is the time at which censoring occurs: for example, the time at which the patient drops out of the study or the study ends. We observe either the survival time T or else the censoring time C."}
{"id": 692, "contributed_by": "group 8", "title": "A Closer Look at Censoring", "section": "11.2", "text": "In order to analyze survival data, we need to make some assumptions about why censoring has occurred. For instance, suppose that a number of patients drop out of a cancer study early because they are very sick. An analysis that does not take into consideration the reason why the patients dropped out will likely overestimate the true average survival time."}
{"id": 693, "contributed_by": "group 8", "title": "A Closer Look at Censoring", "section": "11.2", "text": "Typically, it is not possible to determine from the data itself whether the censoring mechanism is independent. Instead, one has to carefully consider the data collection process in order to determine whether independent censoring is a reasonable assumption. In the remainder of this chapter, we will assume that the censoring mechanism is independent."}
{"id": 694, "contributed_by": "group 8", "title": "A Closer Look at Censoring", "section": "11.2", "text": "More generally, interval censoring refers to the setting in which we do not know the exact event time, but we know that it falls in some interval. For instance, this setting arises if we survey patients once per week in order to determine whether the event has occurred."}
{"id": 695, "contributed_by": "group 8", "title": "The Kaplan Meier Survival Curve", "section": "11.3", "text": "The survival curve, or survival function function quantifies the probability of surviving past time t. For example, suppose that a company is interested in modeling customer churn. Let T represent the time that a customer cancels a subscription to the companys service. Then S(t) represents the probability that a customer cancels later than time t. The larger the value of S(t), the less likely that the customer will cancel before time t."}
{"id": 696, "contributed_by": "group 8", "title": "The Log-Rank Test", "section": "11.4", "text": "When the sample size is large, the log-rank test statistic W has approximately a standard normal distribution; this can be used to compute a p-value for the null hypothesis that there is no difference between the survival curves in the two groups."}
{"id": 697, "contributed_by": "group 8", "title": "The Log-Rank Test", "section": "11.4", "text": "Comparing the survival times of females and males on the BrainCancer data gives a log-rank test statistic of W equal to 1.2, which corresponds to a two-sided p-value of 0.2 using the theoretical null distribution, and a p-value of 0.25 using the permutation null distribution with 1,000 permutations. Thus, we cannot reject the null hypothesis of no difference in survival curves between females and males."}
{"id": 698, "contributed_by": "group 8", "title": "Regression Models With a Survival Response", "section": "11.5", "text": "Since the observed quantity Y is positive and may have a long right tail, we might be tempted to fit a linear regression of log(Y) on X. But as the reader will surely guess, censoring again creates a problem since we are actually interested in predicting T and not Y. To overcome this difficulty, we instead make use of a sequential construction, similar to the constructions of the Kaplan Meier survival curve and the log-rank test."}
{"id": 699, "contributed_by": "group 8", "title": "The Proportional Hazards Assumption", "section": "11.5.2", "text": "Basically, we make no assumptions about the functional form of the baseline hazard function h0(t). We allow the instantaneous probability of death at time t, given that one has survived at least until time t, to take any form. This means that the hazard function is very flexible and can model a wide range of relationships between the covariates and survival time. An illustration of the proportional hazards assumption given in a simple setting with a single binary covariate. In the top row, the proportional hazards assumption holds. Thus, the hazard functions of the two groups are a constant multiple of each other, so that on the log scale, the gap between them is constant. Furthermore, the survival curves never cross, and in fact the gap between the survival curves tends to (initially) increase over time. By contrast, in the bottom row,  does not hold. We see that the log hazard functions for the two groups cross, as do the survival curves."}
{"id": 700, "contributed_by": "group 8", "title": "The Proportional Hazards Assumption", "section": "11.5.2", "text": "When examining the proportional hazards assumption, two scenarios can be observed. In the first scenario, which corresponds to the top row, the assumption holds true. This means that the hazard functions for both groups maintain a constant ratio, leading to a consistent difference on the log scale. Consequently, their survival curves remain distinct without intersecting, with the gap between them likely growing initially. In contrast, the second scenario, representing the bottom row, depicts the failure of this assumption. Here, the log hazard functions of the groups intersect, and so do their survival curves."}
{"id": 701, "contributed_by": "group 8", "title": "Connection With The Log-Rank Test", "section": "11.5.2", "text": "We make use of the same \u201csequential in time\u201d logic that we used to derive the Kaplan Meier survival curve and the log-rank test. For simplicity, assume that there are no ties among the failure, or death, times i.e. each failure occurs at a distinct time."}
{"id": 702, "contributed_by": "group 8", "title": "Example Brain Cancer Data", "section": "11.5.3", "text": "We also see that each one unit increase in the Karnofsky index corresponds to a multiplier of 0.95 in the instantaneous chance of dying. In other words, the higher the Karnofsky index, the lower the chance of dying at any given point in time. This effect is highly significant, with a p-value of 0.0027."}
{"id": 703, "contributed_by": "group 8", "title": "Example Publication Data", "section": "11.5.4", "text": "Studies with a clinical endpoint are more likely to be published at any given point in time than those with a non-clinical endpoint. The funding mechanism did not appear to be significantly associated with time until publication."}
{"id": 704, "contributed_by": "group 8", "title": "Example Publication Data", "section": "11.5.4", "text": "Result shows the Kaplan Meier curves for the time until publication, stratified by whether or not the study produced a positive result. We see slight evidence that time until publication is lower for studies with a positive result. However, the log-rank test yields a very unimpressive p-value of 0.36. We now consider a more careful analysis that makes use of all of the available predictors. According to the results of fitting Coxs proportional hazards model using all of the available features, we find that the chance of publication of a study with a positive result is 1.74 times higher than the chance of publication of a study with a negative result at any point in time, holding all other covariates fixed. The very small p-value associated with posres indicates that this result is highly significant."}
{"id": 705, "contributed_by": "group 8", "title": "Shrinkage for the Cox Model", "section": "11.6", "text": "We apply the lasso-penalized Cox model to the Publication data. We first randomly split the 244 trials into equally sized training and test sets. From the cross-validation results from the training set, the partial likelihood deviance, shown on the y-axis, is twice the cross-validated negative log partial likelihood, it plays the role of the cross-validation error. Note the U-shape of the partial likelihood deviance. The cross-validation error is minimized for an intermediate level of model complexity. Specifically, this occurs when just two predictors, budget and impact, have non-zero estimated coefficients."}
{"id": 706, "contributed_by": "group 8", "title": "Area Under the Curve for Survival Analysis", "section": "12.7.1", "text": "In other words, the high-risk group consists of the trials that are likely to be published sooner. On the Publication data, we stratify the observations into tertiles of low, medium, and high risk. From the resulting survival curves for each of the three strata, we see that there is clear separation between the three strata, and that the strata are correctly ordered in terms of low, medium, and high risk of publication."}
{"id": 707, "contributed_by": "group 8", "title": "Area Under the Curve for Survival Analysis", "section": "12.7.1", "text": "The area under the ROC curve often referred to as the AUC as a way to quantify the performance of a two-class classifier. It turns out that if we consider all pairs consisting of one observation in Class 1 and one observation in Class 2, then the AUC is the fraction of pairs for which the score for the observation in Class 1 exceeds the score for the observation in Class 2."}
{"id": 708, "contributed_by": "group 8", "title": "Area Under the Curve for Survival Analysis", "section": "12.7.1", "text": "We fit a Cox proportional hazards model on the training set of the Publication data, and computed the C index on the test set. This yielded C equal to 0.733. Roughly speaking, given two random papers from the test set, the model can predict with 73.3 percent accuracy which will be published first."}
{"id": 709, "contributed_by": "group 8", "title": "Choice of Time Scale", "section": "11.7.2", "text": "When examining the association between risk factors and disease occurrence in an epidemiological study, one might use the age of patient to define time, so that time zero is the patients date of birth. With this choice, the association between age and survival cannot be measured; however, there is no need to adjust for age in the analysis. When examining covariates associated with disease-free survival (i.e. the amount of time elapsed between treatment and disease recurrence), one might use the date of treatment as time zero."}
{"id": 710, "contributed_by": "group 8", "title": "Time-Dependent Covariates", "section": "11.7.3", "text": "A powerful feature of the proportional hazards model is its ability to handle time-dependent covariates, predictors whose value may change over time. For example, suppose we measure a patients blood pressure every week over the course of a medical study."}
{"id": 711, "contributed_by": "group 8", "title": "Time-Dependent Covariates", "section": "14.4", "text": "Because the partial likelihood in (11.16) is constructed sequentially in time, dealing with time-dependent covariates is straightforward. By contrast, time-dependent covariates would pose a much greater challenge within the context of a traditional parametric approach."}
{"id": 712, "contributed_by": "group 8", "title": "Survival Trees", "section": "11.7.4", "text": "We have seen that the Cox proportional hazards model relies on the proportional hazards assumption. While results from the Cox model tend to be fairly robust to violations of this assumption, it is still a good idea to check whether it holds. In the case of a qualitative feature, we can plot the log hazard function for each level of the feature. If the proportional hazards assumption holds, then the log hazard functions should just differ by a constant. In the case of a quantitative feature, we can take a similar approach by stratifying the feature."}
{"id": 713, "contributed_by": "group 8", "title": "Survival Trees", "section": "11.7.5", "text": "we discussed flexible and adaptive learning procedures such as trees, random forests, and boosting, which we applied in both the regression and classification settings. Most of these approaches can be generalized to the survival analysis setting. For example, survival trees are a modification of classification and regression trees that use a split criterion that maximizes the difference between the survival curves in the resulting daughter nodes. Survival trees can then be used to create random survival forests."}
{"id": 714, "contributed_by": "group 8", "title": "Brain Cancer Data", "section": "11.8.1", "text": "Before beginning an analysis, it is important to know how the status variable has been coded. Most software uses the convention that a status of 1 indicates an uncensored observation (often death), and a status of 0 indicates a censored observation. But some scientists might use the opposite coding. For the BrainCancer data set 35 patients died before the end of the study, so we are using the conventional coding."}
{"id": 715, "contributed_by": "group 8", "title": "Brain Cancer Data", "section": "11.8.1", "text": "The Cox model does not include an intercept, which is why we used the intercept equal to False argument to ModelSpexsc above. The summary() method delivers many columns, we chose to abbreviate its output here. It is possible to obtain the likelihood ratio test comparing this model to the one with no features."}
{"id": 716, "contributed_by": "group 8", "title": "Brain Cancer Data", "section": "11.8.1", "text": "The results indicate that the risk associated with HG glioma is more than eight times (i.e. 8.62) the risk associated with meningioma. In other words, after adjusting for the other predictors, patients with HG glioma have much worse survival compared to those with meningioma. In addition, larger values of the Karnofsky index, are associated with lower risk, i.e. longer survival."}
{"id": 717, "contributed_by": "group 8", "title": "Brain Cancer Data", "section": "11.8.1", "text": "Finally, we plot estimated survival curves for each diagnosis category, adjusting for the other predictors. To make these plots, we set the values of the other predictors equal to the mean for quantitative variables and equal to the mode for categorical. To do this, we use the apply() method across rows (i.e. axis equal to 0) with a function representative that checks if a column is categorical or not."}
{"id": 718, "contributed_by": "group 8", "title": "Call Center Data", "section": "11.8.3", "text": "the use of lambda for creating short functions on the fly. We use the function sim-time() from the ISLP.survival package. This function uses the relationship between the survival function and sim time() cumulative hazard and the specific form of the cumulative hazard function in the Cox model to simulate data based on values of the linear predictor true linpred and the cumulative hazard."}
{"id": 719, "contributed_by": "group 8", "title": "Call Center Data", "section": "11.8.3", "text": "It seems that calls at Call Center B take longer to be answered than calls at Centers A and C. Similarly, it appears that wait times are longest in the morning and shortest in the evening hours. We can use a log-rank test to determine whether these differences are statistically significant using the function multivariate log-rank test."}
{"id": 720, "contributed_by": "group 8", "title": "Call Center Data", "section": "11.8.3", "text": "We are now ready to generate data under the Cox proportional hazards model. We truncate the maximum time to 1000 seconds to keep simulated wait times reasonable. The function sim time() takes a linear predictor, a cumulative hazard function and a random number generator."}
{"id": 721, "contributed_by": "group 8", "title": "What Are Principal Components?", "section": "12.2.1", "text": "PCA provides a tool to find a low dimensional representation of a data set that captures as much as possible of the variation. The idea is that each of the n observations lives in p-dimensional space, but not all of these dimensions are equally interesting. PCA seeks a small number of dimensions that are as interesting as possible, where the concept of interesting is measured by the amount that the observations vary along each dimension. In that sense the goal of Principal Component Analysis is to reduce dimensionality"}
{"id": 722, "contributed_by": "group 8", "title": "Clustering Methods", "section": "12.4", "text": "Clustering refers to a very broad set of techniques for finding subgroups, or clusters, in a data set. When we cluster the observations of a data set, we seek to partition them into distinct groups so that the observations within each group are quite similar to each other, while observations in different groups are quite different from each other."}
{"id": 723, "contributed_by": "group 8", "title": "Clustering Methods", "section": "12.4", "text": "Both PCA and clustering seek to simplify the data via a small number of summaries, but their mechanisms are different. PCA looks to find a low-dimensional representation of the observations that explain a good fraction of the variance. Clustering looks to find homogeneous subgroups among the observations"}
{"id": 724, "contributed_by": "group 8", "title": "Clustering Methods", "section": "12.4", "text": "Another application of clustering arises in marketing.Our goal is to perform market segmentation. The task of performing market segmentation amounts to clustering the people in the data set."}
{"id": 725, "contributed_by": "group 8", "title": "KMeans Clustering", "section": "12.4.1", "text": "The Kmeans clustering procedure results from a simple and intuitive mathematical problem.To perform Kmeans clustering, we must first specify the desired number of clusters K.The initial step required to perform KMeans clustering is to specify the desired number of clusters, denoted as K. KMeans clustering is a partitioning method that groups data points into K distinct clusters, where K is a user-defined parameter. This step, referred to as determining the number of clusters, is crucial because it directly affects the outcome of the clustering process."}
{"id": 726, "contributed_by": "group 8", "title": "KMeans Clustering", "section": "12.4.1", "text": "The Kmeans algorithm will assign each observation to exactly one of the K clusters. A simulated data set with 150 observations in two-dimensional space is shown in the figure. Panels show the results of applying Kmeans clustering with different values of K, the number of clusters. The color of each observation indicates the cluster to which it was assigned using the Kmeans clustering algorithm.The fundamental principle of KMeans is that every data point belongs exclusively to a single cluster, and this property distinguishes KMeans from other clustering algorithms that may allow overlapping or fuzzy membership."}
{"id": 727, "contributed_by": "group 8", "title": "KMeans Clustering", "section": "12.4.1", "text": "As the KMeans algorithm is run, the clustering obtained will continually improve until the result no longer changes.Because the Kmeans algorithm finds a local rather than a global optimum, the results obtained will depend on the initial (random) cluster assignment of each observation. It can yield different outcomes with each run. In summary, K-means clustering is not deterministic, and the results obtained can vary from run to run due to its sensitivity to initial conditions."}
{"id": 728, "contributed_by": "group 8", "title": "Hierarchical Clustering", "section": "12.4.2", "text": "Hierarchical clustering is an alternative approach which does not require that we commit to a particular choice of K.Hierarchical clustering has an added advantage over Kmeans clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram.A dendrogram is a hierarchical tree-like diagram that represents the arrangement and relationships among objects or data points in a hierarchical clustering analysis. It is a common visualization tool used in hierarchical clustering to help understand how data points or items are grouped into clusters based on their similarities or dissimilarities. "}
{"id": 729, "contributed_by": "group 8", "title": "The Hierarchical Clustering Algorithm", "section": "12.4.2", "text": "Single linkage in hierarchical clustering involves Minimal intercluster dissimilarity. Single Linkages computes all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the smallest of these dissimilarities. Single linkage can result in extended, trailing clusters in which single observations are fused one at a time."}
{"id": 730, "contributed_by": "group 8", "title": "The Hierarchical Clustering Algorithm", "section": "12.4.2", "text": "Centroid linkage in hierarchical clustering involves Dissimilarity between the centroid for cluster A and the centroid for cluster B. Centroid linkage can result in undesirable inversions."}
{"id": 731, "contributed_by": "group 8", "title": "The Hierarchical Clustering Algorithm", "section": "12.4.2", "text": "Complete linkage in hierarchical clustering involves Maximal intercluster dissimilarity. Complete linkage compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the largest of these dissimilarities."}
{"id": 732, "contributed_by": "group 8", "title": "The Hierarchical Clustering Algorithm", "section": "12.4.2", "text": "Average linkage in hierarchical clustering involves Mean intercluster dissimilarity. Average linkage compute all pairwise dissimilarities between the observations in cluster A and the observations in cluster B, and record the average of these dissimilarities."}
{"id": 733, "contributed_by": "group 8", "title": "The Challenge of Unsupervised Learning", "section": "12.1", "text": "Supervised learning is a well-understood area.For instance, if you are asked to predict a binary outcome from a data set, you have a very well-developed set of algorithms for supervised learning at your disposal such as logistic regression, linear discriminant analysis, classification trees, support vector machines, and more as well as a clear understanding of how to assess the quality of the results obtained."}
{"id": 734, "contributed_by": "group 8", "title": "The Challenge of Unsupervised Learning", "section": "12.1", "text": "Unsupervised learning is often much more challenging. The exercise tends to be more subjective, and there is no simple goal for the analysis, such as prediction of a response. Furthermore, it can be hard to assess the results obtained from unsupervised learning methods. since there is no universally accepted mechanism for performing cross-validation or validating results on an independent data set."}
{"id": 735, "contributed_by": "group 8", "title": "Principal Components Analysis", "section": "12.2", "text": "When faced with a large set of correlated variables, principal components allow us to summarize this set with a smaller number of representative variables that collectively explain most of the variability in the original set. The principal component directions are directions in feature space along which the original data are highly variable. These directions also define lines and subspaces that are as close as possible to the data cloud."}
{"id": 736, "contributed_by": "group 8", "title": "Principal Components Analysis", "section": "12.2", "text": "To perform principal components regression, we simply use principal components as predictors in a regression model in place of the original larger set of variables.Principal components analysis (PCA) refers to the process by which principal components analysis components are computed. Principal components in principal component regression serve as a reduced and orthogonal set of predictors derived from the original variables using PCA. Their key roles are dimensionality reduction, mitigation of multicollinearity, and providing a more interpretable and potentially more effective regression model for data analysis and prediction."}
{"id": 737, "contributed_by": "group 8", "title": "What Are Principal Components", "section": "12.2.1", "text": "Suppose that we wish to visualize n observations with measurements on a set of p features. We could do this by examining two-dimensional scatterplots of the data. In a scatterplot, each data point is represented as a single point on a two-dimensional plane, with one dimension (feature) plotted on the x-axis and the other dimension (feature) plotted on the y-axis.If p is large, then it will certainly not be possible to look at all of them; moreover, most likely none of them will be informative since they each contain just a small fraction of the total information present in the data set."}
{"id": 738, "contributed_by": "group 8", "title": "What Are Principal Components", "section": "12.2.1", "text": "Clearly, a better method is required to visualize the n observations when p is large. In particular, we would like to find a low-dimensional representation of the data that captures as much of the information as possible. For instance, if we can obtain a two-dimensional representation of the data that captures most of the information, then we can plot the observations in this low dimensional space."}
{"id": 739, "contributed_by": "group 8", "title": "Another Interpretation of Principal Components", "section": "12.2.2", "text": "Principal components provide low dimensional linear surfaces that are closest to the observations. The first principal component loading vector has a very special property.It is the line in p dimensional space that is closest to the n observations. We seek a single dimension of the data that lies as close as possible to all of the data points since such a line will likely provide a good summary of the data. Together the first M principal component score vectors and the first M principal component loading vectors provide the best M dimensional approximation (in terms of Euclidean distance) to each observation"}
{"id": 740, "contributed_by": "group 8", "title": "The Proportion of Variance Explained", "section": "12.2.3", "text": "We can now ask a natural question. How much of the information in a given data set is lost by projecting the observations onto the first few principal components? That is, how much of the variance in the data is not contained in the first few principal components? More generally, we are interested in knowing the Proportion of Variance Explained or PVE by each principal component. It is represents the fraction of the total variance in the data that is accounted for by a particular principal component or a set of components. It measures the extent to which the variance in the data can be attributed to these components. "}
{"id": 741, "contributed_by": "group 8", "title": "More on PCA", "section": "12.2.4", "text": "While in theory, the principal components need not be unique, in almost all practical settings they are (up to sign flips). This means that two different software packages will yield the same principal component loading vectors, although the signs of those loading vectors may differ. The signs may differ because each principal component loading vector specifies a direction in p-dimensional space. Flipping the sign has no effect as the direction does not change"}
{"id": 742, "contributed_by": "group 8", "title": "More on PCA", "section": "12.2.4", "text": "We typically decide on the number of principal components required to visualize the data by examining a scree plot We choose the smallest number of principal components that are required in order to explain a sizable amount of the variation in the data. This is done by eyeballing the scree plot and looking for a point at which the proportion of variance explained by each subsequent principal component drops off. This drop is often referred to as an elbow in the scree plot."}
{"id": 743, "contributed_by": "group 8", "title": "Lab: Unsupervised Learning", "section": "12.5", "text": "Having scaled the data, we can then perform principal components analysis using the PCA() transform from the sklearn.decomposition package.By default, the PCA() transform centers the variables to have mean zero though it does not scale them"}
{"id": 744, "contributed_by": "group 8", "title": "Lab: Unsupervised Learning", "section": "12.5", "text": "The AgglomerativeClustering() class from the sklearn.clustering package implements hierarchical clustering.As its name is long, we use the short-hand HClust for hierarchical clustering. Note that this will not change the return type when using this method, so instances will still be of class AgglomerativeClustering. While using AgglomerativeClustering() method for hierarchical clustering n_clusters specifies the desired number of clusters, linkage specifies the method for merging clusters and affinity specifies the distance metric."}
{"id": 745, "contributed_by": "group 8", "title": "Hierarchical Clustering", "section": "12.4.2", "text": "We have a concept of the dissimilarity between pairs of observations, but how do we define the dissimilarity between two clusters if one or both of the clusters contains multiple observations? The concept of dissimilarity between a pair of observations needs to be extended to a pair of groups of observations. This extension is achieved by developing the notion of linkage, which defines the dissimilarity between two groups of observations."}
{"id": 746, "contributed_by": "group 8", "title": "Hierarchical Clustering", "section": "12.4.2", "text": "Thus far, the examples in this chapter have used Euclidean distance as the dissimilarity measure. But sometimes other dissimilarity measures might be preferred. For example, correlation-based distance considers two observations to be similar if their features are highly correlated, even though the observed values may be far apart in terms of Euclidean distance."}
{"id": 747, "contributed_by": "group 8", "title": "Hierarchical Clustering", "section": "12.4.2", "text": "The term hierarchical refers to the fact that clusters obtained by cutting the dendrogram at a given height are necessarily nested within the clusters obtained by cutting the dendrogram at any greater height. However, on an arbitrary data set, this assumption of hierarchical structure might be unrealistic. For instance, suppose that our observations correspond to a group of men and women, evenly split among Americans, Japanese, and French. We can imagine a scenario in which the best division into two groups might split these people by gender, and the best division into three groups might split them by nationality. In this case, the true clusters are not nested or they are non-hierachical, in the sense that the best division into three groups does not result from taking the best division into two groups and splitting up one of those groups. Consequently, this situation could not be well represented by hierarchical clustering. Due to situations such as this one, hierarchical clustering can sometimes yield worse results than Kmeans clustering for a given number of clusters."}
{"id": 748, "contributed_by": "group 8", "title": "KMeans Clustering", "section": "12.4.1", "text": "Kmeans clustering is a simple and elegant approach for partitioning a data set into K distinct, non-overlapping clusters.The idea behind Kmeans clustering is that a good clustering is one for which the within-cluster variation is as small as possible.Thus the primary objective of K-means clustering is to find the most suitable cluster assignments and centroids that minimize the within-cluster variation, making the clusters as compact and homogeneous as possible."}
{"id": 749, "contributed_by": "group 8", "title": "Principal Components Analysis", "section": "12.5.1", "text": "In the USArrests data, the first principal component explains 62.0 percentage of the variance in the data, and the next principal component explains 24.7 percentage of the variance. Together, the first two principal components explain 86.7 percent of the variance in the data, and the last two principal components explain only about 13 percent of the variance."}
{"id": 750, "contributed_by": "group 8", "title": "Missing Values and Matrix Completion", "section": "12.3", "text": "In this section we show how principal components can be used to impute the missing values, through a process known as matrix completion. The completed matrix can then be used in a statistical learning method, such as linear regression or LDA. This approach for imputing missing data is appropriate if the missingness is random. For example, it is suitable if a patient's weight is missing because the battery of the electronic scale was flat at the time of his exam. By contrast, if the weight is missing because the patient was too heavy to climb on the scale, then this is not missing at random. The missingness is  informative, and the approach described here for handling missing data is not suitable."}
{"id": 751, "contributed_by": "group 8", "title": "Clustering", "section": "12.5.3", "text": "The estimator sklearn.cluster.KMeans() performs Kmeans clustering in Python. In KMeans() you can specify the number of clusters based on your problem and data. After fitting the model to your data, you can access the cluster labels for each data point and the cluster centroids.Using KMeans() is a is a common and convenient way to perform KMeans clustering in Python."}
{"id": 752, "contributed_by": "group 8", "title": "Testing a Hypothesis", "section": "13.1.1", "text": "Conducting a hypothesis test typically proceeds in four steps. First, we define the null and alternative hypotheses. Next, we construct a test statistic that summarizes the strength of evidence against the null hypothesis. We then compute a p-value that quantifies the probability of having obtained"}
{"id": 753, "contributed_by": "group 8", "title": "Null and Alternative Hypotheses", "section": "13.1.1", "text": "It is important to note that the treatment of H0 and Ha is asymmetric.H0 is treated as the default state of the world, and we focus on using data to reject H0. If we reject H0, then this provides evidence in favor of Ha. We can think of rejecting H0 as making a discovery about our data: namely, we are discovering that H0 does not hold. By contrast, if we fail to reject H0, then our findings are more nebulous: we will not know whether we failed to reject H0 because our sample size was too small (in which case testing H0 again on a larger or higher-quality dataset might lead to rejection), or whether we failed to reject H0 because H0 really holds."}
{"id": 754, "contributed_by": "group 8", "title": "P-value", "section": "13.1.1", "text": "The notion of a p-value provides us with a way to formalize as well as p-value answer this question. The p-value is defined as the probability of observing a test statistic equal to or more extreme than the observed statistic, under the assumption that H0 is in fact true. Therefore, a small p-value provides evidence against H0."}
{"id": 755, "contributed_by": "group 8", "title": "Null Distribution", "section": "13.1.1", "text": "The distribution of the test statistic under H0 (also known as the test statistics null distribution) will depend on the details of what type of null hypothesis is being tested, and what type of test statistic is used. In general, most commonly used test statistics follow a well-known statistical distribution under the null hypothesis \u2014 such as a normal distribution, a t-distribution, a \u03c72-distribution, or an F-distribution \u2014 provided that the sample size is sufficiently large and that some other assumptions hold. Typically, the R function that is used to compute a test statistic will make use of this null distribution in order to output a p-value. In Section 13.5, we will see an approach to estimate the null distribution of a test statistic using re-sampling; in many contemporary settings, this is a very attractive option, as it exploits the availability of fast computers in order to avoid having to make potentially problematic assumptions about the data."}
{"id": 756, "contributed_by": "group 8", "title": "Misinterpretation of P-Values", "section": "13.1.1", "text": "The p-value is perhaps one of the most used and abused notions in all of statistics. In particular, it is sometimes said that the p-value is the probability that H0 holds, i.e., that the null hypothesis is true. This is not correct. The one and only correct interpretation of the p-value is as the fraction of the time that we would expect to see such an extreme value of the test statistic8 if we repeated the experiment many many times, provided H0 holds."}
{"id": 757, "contributed_by": "group 8", "title": "Test statistic", "section": "13.1.1", "text": "Next, we wish to use our data in order to find evidence for or against the null hypothesis. In order to do this, we must compute a test statistic, a test statistic denoted T, which summarizes the extent to which our data are consistent with H0. The way in which we construct T depends on the nature of the null hypothesis that we are testing."}
{"id": 758, "contributed_by": "group 8", "title": "Null Hypothesis and P-value", "section": "13.1.1", "text": "Once we have computed a p-value corresponding to null hypothesis H0, it remains for us to decide whether or not to reject null hypothesis H0. (We do not usually talk about\u201caccepting\u201d null hypothesis H0: instead, we talk about \u201cfailing to reject\u201d null hypothesis H0.) A small p-value indicates that such a large value of the test statistic is unlikely to occur under H0, and thereby provides evidence against H0. If the p-value is sufficiently small, then we will want to reject H0 (and, therefore, make a \u201cdiscovery\u201d). But how small is small enough to reject H0? It turns out that the answer to this question is very much in the eyes of the beholder, or more specifically, the data analyst. The smaller the p-value, the stronger the evidence against null hypothesis H0. In some fields, it is typical to reject null hypothesis H0 if the p-value is below 0.05; this means that, if null hypothesis H0 holds, we would expect to see such a small p-value"}
{"id": 759, "contributed_by": "group 8", "title": "True and False Null Hypotheses", "section": "13.1.2", "text": "If the null hypothesis holds, then we say that it is a true null hypothesis. otherwise, it is a false null hypothesis. For instance, if we test H0: \u03bct is equal to \u03bcc as in Section 13.1.1, and there is indeed no difference in the population mean blood pressure for mice in the treatment group and mice in the control group, then H0 is true; otherwise, it is false. Of course, we do not know a priori whether H0 is true or whether it is false, this is why we need to conduct a hypothesis test."}
{"id": 760, "contributed_by": "group 8", "title": "Power of hypothesis test", "section": "13.1.2", "text": "The Type I error rate is defined as the probability of making a Type I error given that H0 holds, i.e., the probability of incorrectly rejecting H0. Alternatively, if we do not reject H0 when H0 is in fact false, then we have committed a Type II error. The power of the hypothesis test is defined as the probability of not making a Type II error given that Ha holds, i.e., the probability of correctly rejecting H0"}
{"id": 761, "contributed_by": "group 8", "title": "Type I and Type II Errors", "section": "13.1.2", "text": "Ideally we would like both the Type I and Type II error rates to be small. But in practice, this is hard to achieve. There typically is a trade-off: we can make the Type I error small by only rejecting H0 if we are quite sure that it does not hold; however, this will result in an increase in the Type II error. Alternatively, we can make the Type II error small by rejecting H0 in the presence of even modest evidence that it does not hold, but this will cause the Type I error to be large. In practice, we typically view Type I errors as more \u201cserious\u201d than Type II errors, because the former involves declaring a scientific finding that is not correct. Hence, when we perform hypothesis testing, we typically require a low Type I error rate \u2014 e.g., at most alpha equal to 0.05 \u2014 while trying to make the Type II error small (or, equivalently, the power large)."}
{"id": 762, "contributed_by": "group 8", "title": "P-Value Threshold and Type I Error Rate", "section": "13.1.2", "text": "It turns out that there is a direct correspondence between the p-value threshold that causes us to reject H0, and the Type I error rate. By only rejecting H0 when the p-value is below alpha, we ensure that the Type I error rate will be less than or equal to alpha."}
{"id": 763, "contributed_by": "group 8", "title": "Multiple Testing", "section": "13.2", "text": "These examples illustrate the main challenge of multiple testing: when multiple testing a huge number of null hypotheses, we are bound to get some very small p-values by chance. If we make a decision about whether to reject each null hypothesis without accounting for the fact that we have performed a very large number of tests, then we may end up rejecting a great number of true null hypotheses \u2014 that is, making a large number of Type I errors."}
{"id": 764, "contributed_by": "group 8", "title": "Family-wise Error Rate", "section": "13.3.1", "text": "Recall that the Type I error rate is the probability of rejecting H0 if H0 is true. The family-wise error rate (FWER) generalizes this notion to the set family-wise error rate ting of m null hypotheses, H01,..., H0m, and is defined as the probability of making at least one Type I error. To state this idea more formally, consider Table 13.2, which summarizes the possible outcomes when performing m hypothesis tests. Here, V represents the number of Type I errors (also known as false positives or false discoveries), S the number of true positives, U the number of true negatives, and W the number of Type II errors (also known as false negatives)."}
{"id": 765, "contributed_by": "group 8", "title": "Methods for Controlling Family-Wise Error Rate", "section": "13.3.2", "text": "We first present the Bonferroni method and Holms step-down procedure, which are very general-purpose approaches for controlling the FWER that can be applied whenever m p-values have been computed, regardless of the form of the null hypotheses, the choice of test statistics, or the (in)dependence of the p-values. We then briefly discuss the Tukeys method and Schefes method in order to illustrate the fact that, in certain situations, more specialized approaches for controlling the FWER may be preferable."}
{"id": 766, "contributed_by": "group 8", "title": "Bonferroni Correction", "section": "13.3.2", "text": "The Bonferroni correction is by far the best-known and most commonly-used multiplicity correction in all of statistics. Its ubiquity is due in large part to the fact that it is very easy to understand and simple to implement, and also from the fact that it successfully controls Type I error regardless of whether the m hypothesis tests are independent. However, as we will see, it is typically neither the most powerful nor the best approach for multiple testing correction. In particular, the Bonferroni correction can be quite conservative, in the sense that the true FWER is often quite a bit lower than the nominal (or target) FWER; this results from the inequality in (13.6). By contrast, a less conservative procedure might allow us to control the FWER while rejecting more null hypotheses, and therefore making fewer Type II errors."}
{"id": 767, "contributed_by": "group 8", "title": "Holms Method in Multiple Hypothesis Testing", "section": "13.3.2", "text": "Holms method, also known as Holms step-down procedure or the Holm Holms method Bonferroni method, is an alternative to the Bonferroni procedure. Holms method controls the FWER, but it is less conservative than Bonferroni, in the sense that it will reject more null hypotheses, typically resulting in fewer Type II errors and hence greater power. The procedure is summarized in Algorithm 13.1. The proof that this method controls the FWER is similar to, but slightly more complicated than, the argument in (13.6) that the Bonferroni method controls the FWER. It is worth noting that in the Holms procedure, the threshold that we use to reject each null hypothesis p(L) in Step 5 actually depends on the values of all m of the p-values. (See the definition of L in (13.7).) This is in contrast to the Bonferroni procedure, in which to control the FWER at level alpha, we reject any null hypotheses for which the p-value is below alpha divided by m, regardless of the other p-values. Holms method makes no independence assumptions about the m hypothesis tests, and is uniformly more powerful than the Bonferroni method."}
{"id": 768, "contributed_by": "group 8", "title": "Tukeys Method and Schaffer Method", "section": "13.3.2", "text": "Bonferronis method and Holms method can be used in virtually any setting in which we wish to control the FWER for m null hypotheses: they make no assumptions about the nature of the null hypotheses, the type of test statistic used, or the (in)dependence of the p-values. However, in certain very specific settings, we can achieve higher power by controlling the FWER using approaches that are more tailored to the task at hand. Tukey's method and Schefes's method provide two such examples."}
{"id": 769, "contributed_by": "group 8", "title": "Advanced Procedures in Multiple Testing Correction", "section": "13.3.2", "text": "To summarize, Holms procedure and Bonferronis procedure are very general approaches for multiple testing correction that can be applied under all circumstances. However, in certain special cases, more powerful procedures for multiple testing correction may be available, in order to control the FWER while achieving higher power (i.e. committing fewer Type II errors) than would be possible using Holm or Bonferroni. In this section, we have illustrated two such examples."}
{"id": 770, "contributed_by": "group 8", "title": "Power and FWER Trade-off", "section": "13.3.3", "text": "In general, there is a trade-off between the FWER threshold that we choose, and our power to reject the null hypotheses. Recall that power is defined as the number of false null hypotheses that we reject divided by the total number of false null hypotheses,  using the notation of Table 13.2. This illustrates the results of a simulation setting involving m null hypotheses, of which 90 percent are true and the remaining 10 percent are false, power is displayed as a function of the FWER. In this particular simulation setting, when m is equal to 10, an FWER of 0.05 corresponds to the power of approximately 60 percent. However, as m increases, the power decreases. With m equal to 500, the power is below 0.2 at an FWER of 0.05, so that we successfully reject only 20 percent  of the false null hypotheses."}
{"id": 771, "contributed_by": "group 8", "title": "False Discovery Proportion ", "section": "13.4.1", "text": "As we just discussed, when m is large, then trying to prevent any false positives (as in FWER control) is simply too stringent. Instead, we might try to make sure that the ratio of false positives to total positives is sufficiently low so that most of the rejected null hypotheses are not false positives. The ratio of false positives to total positives is known as the false discovery proportion."}
{"id": 772, "contributed_by": "group 8", "title": "Nature of FDR Thresholds Compared to p-values", "section": "13.4.1", "text": "It is worth noting that unlike p-values, for which a threshold of 0.05 is typically viewed as the minimum standard of evidence for a \u201cpositive\u201d result, and a threshold of 0.01 or even 0.001 is viewed as much more compelling, there is no standard accepted threshold for FDR control. Instead, the choice of FDR threshold is typically context-dependent, or even dataset-dependent."}
{"id": 773, "contributed_by": "group 8", "title": "False Discovery Rate with Data Collection", "section": "13.4.1", "text": "Thus far, we have motivated the use of the FDR from a pragmatic perspective, by arguing that when m is large, controlling the FWER is simply too stringent, and will not lead to \u201cenough\u201d discoveries. An additional motivation for the use of the FDR is that it aligns well with the way that data are often collected in contemporary applications. As datasets continue to grow in size across a variety of fields, it is increasingly common to conduct a huge number of hypothesis tests for exploratory, rather than confirmatory, purposes."}
{"id": 774, "contributed_by": "group 8", "title": "Benjamini Hochberg procedure", "section": "13.4.2", "text": "In other words, this procedure ensures that, on average, no more than a fraction q of the rejected null hypotheses are false positives. Remarkably, this holds regardless of how many null hypotheses are true, and regardless of the distribution of the p-values for the null hypotheses that are false. Therefore, the Benjamini Hochberg procedure gives us a very easy way to determine, given a set of m p-values, which null hypotheses to reject in order to control the FDR at any pre-specified level q."}
{"id": 775, "contributed_by": "group 8", "title": "Difference between Bonferroni and Benjamini Hochberg procedures", "section": "13.4.2", "text": "There is a fundamental difference between the Bonferroni procedure of Section 13.3.2 and the Benjamini Hochberg procedure. In the Bonferroni procedure, in order to control the FWER for m null hypotheses at level alpha, we must simply reject null hypotheses for which the p-value is below alpha divided by m. This threshold of alpha divided by m does not depend on anything about the data (beyond the value of m) and certainly does not depend on the p-values themselves. By contrast, the rejection threshold used in the Benjamini-Hochberg procedure is more complicated: we reject all null hypotheses for which the p-value is less than or equal to the Lth smallest p-value, where L is itself a function of all m p-values, as in (13.10). Therefore, when conducting the Benjamini\u2013Hochberg procedure, we cannot plan out in advance what threshold we will use to reject p-values; we need to first see our data. For instance, in the abstract, there is no way to know whether we will reject a null hypothesis corresponding to a p-value of 0.01 when using an FDR threshold of 0.1 with m equal to 100; the answer depends on the values of the other m - 1 p-value. This property of the Benjamini\u2013Hochberg procedure is shared by the Holm procedure, which also involves a data-dependent p-value threshold."}
{"id": 776, "contributed_by": "group 8", "title": "Theoretical null distribution", "section": "13.5", "text": "Thus far, the discussion in this chapter has assumed that we are interested in testing a particular null hypothesis H0 using a test statistic T, which has some known (or assumed) distribution under H0, such as a normal distribution, a t-distribution, an x2-distribution, or an F-distribution. This is referred to as the theoretical null distribution. We typically rely upon the availability of a theoretical null distribution in order to obtain a p-value associated with our test statistic. Indeed, for most of the types of null hypotheses that we might be interested in testing, a theoretical null distribution is available, provided that we are willing to make stringent assumptions about our data."}
{"id": 777, "contributed_by": "group 8", "title": "Challenges in Using Theoretical Null Distributions", "section": "13.5", "text": "However, if our null hypothesis H0 or test statistic T is somewhat unusual, then it may be the case that no theoretical null distribution is available. Alternatively, even if a theoretical null distribution exists, then we may be wary of relying upon it, perhaps because some assumption that is required for it to hold is violated. For instance, maybe the sample size is too small."}
{"id": 778, "contributed_by": "group 8", "title": "Re-sampling and Theoretical p-values", "section": "13.5.1", "text": "In general, in settings with a smaller sample size or a more skewed data distribution (so that the theoretical null distribution is less accurate), the difference between the re-sampling and theoretical p-values will tend to be more pronounced. In fact, the substantial difference between the resampling and theoretical null distributions in Figure 13.8 is due to the fact that a single observation in the 877th gene is very far from the other observations, leading to a very skewed distribution."}
{"id": 779, "contributed_by": "group 8", "title": "Re-sampling approaches", "section": "13.5.3", "text": "In general, there are two settings in which a re-sampling approach is particularly useful, Perhaps no theoretical null distribution is available. This may be the case if you are testing an unusual null hypothesis H0, or using an unusual test statistic T. Perhaps a theoretical null distribution is available, but the assumptions required for its validity do not hold. For instance, the two-sample t-statistic in (13.11) follows a tnX plus nY and the second one is a distribution only if the observations are normally distributed. Furthermore, it follows a N(0, 1) distribution only if nX and nY are quite large. If the data are non-normal and nX and nY are small, then p-values that make use of the theoretical null distribution will not be valid (i.e. they will not properly control the Type I error)."}
{"id": 780, "contributed_by": "group 9", "title": "", "section": "", "text": "Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y. Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application."}
{"id": 781, "contributed_by": "group 9", "title": "", "section": "", "text": "What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y, in the sense that larger values of the predictor are associated with larger values of Y. Other predictors may have the opposite relationship. Depending on the complexity of f, the relationship between the response and a given predictor may also depend on the values of the other predictors."}
{"id": 782, "contributed_by": "group 9", "title": "", "section": "", "text": "Assuming a parametric form for f simplifies the problem of estimating f because it is generally much easier to estimate a set of parameters, such as \u03b20 , \u03b21 , . . . , \u03b2p in the linear model, than it is to fit an entirely arbitrary function f. The potential disadvantage of a parametric approach is that the model we choose will usually not match the true unknown form of f. If the chosen model is too far from the true f, then our estimate will be poor."}
{"id": 783, "contributed_by": "group 9", "title": "", "section": "", "text": "We can try to address this problem by choosing flexible models that can fit many different possible functional forms flexible for f. But in general, fitting a more flexible model requires estimating a greater number of parameters. These more complex models can lead to a phenomenon known as overfitting the data, which essentially means they overfitting follow the errors, or noise, too closely."}
{"id": 784, "contributed_by": "group 9", "title": "", "section": "", "text": "Of the many methods that we examine in this book, some are less flexible, or more restrictive, in the sense that they can produce just a relatively small range of shapes to estimate f. For example, linear regression is a relatively inflexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4."}
{"id": 785, "contributed_by": "group 9", "title": "", "section": "", "text": "Generalized additive models (GAMs), discussed in Chapter 7, instead extend the linear model to allow for certain non-linear relationships. Consequently, GAMs are more flexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve."}
{"id": 786, "contributed_by": "group 9", "title": "", "section": "", "text": "One statistical learning tool that we may use in this setting is cluster analysis, or clustering. The goal of cluster analysis cluster analysisis to ascertain, on the basis of x1 , . . . , xn , whether the observations fall into relatively distinct groups."}
{"id": 787, "contributed_by": "group 9", "title": "", "section": "", "text": "Many problems fall naturally into the supervised or unsupervised learning paradigms. However, sometimes the question of whether an analysis should be considered supervised or unsupervised is less clear-cut"}
{"id": 788, "contributed_by": "group 9", "title": "", "section": "", "text": "Variables can be characterized as either quantitative or qualitative (also known as categorical). Quantitative variables take on numerical values. Examples include a person\u2019s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on values in one of K different classes, or categories."}
{"id": 789, "contributed_by": "group 9", "title": "", "section": "", "text": "We tend to refer to problems with a quantitative response as regression problems, while those involving a qualitative response are often referred to as classification problems. However, the distinction is not always that crisp. "}
{"id": 790, "contributed_by": "group 9", "title": "", "section": "", "text": " That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given by <equation> where \u02c6f (x i ) is the prediction that \u02c6f gives for the ith observation."}
{"id": 791, "contributed_by": "group 9", "title": "", "section": "", "text": "This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods specifically estimate coefficients so as to minimize the training set MSE."}
{"id": 792, "contributed_by": "group 9", "title": "", "section": "", "text": "Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x 0 , can always be decomposed into the sum of three fundamental quantities: the variance of \u02c6f (x 0 ), the squared bias of \u02c6f (x 0 ) and the variance of the error terms."}
{"id": 793, "contributed_by": "group 9", "title": "", "section": "", "text": "What do we mean by the variance and bias of a statistical learning method? Variance refers to the amount by which \u02c6f would change if we estimated it using a different training data set. Since the training data are used to fit the statistical learning method, different training data sets will result in a different \u02c6f ."}
{"id": 794, "contributed_by": "group 9", "title": "", "section": "", "text": "Equation 2.8 is referred to as the training error rate because it is computed based on the data that was used to train our classifier. As in the regression setting, we are most interested in the error rates that result from applying our classifier to test observations that were not used in training. The test error rate associated with a set of test observations of the form (x0, y0)."}
{"id": 795, "contributed_by": "group 9", "title": "", "section": "", "text": "Despite the fact that it is a very simple approach, KNN can often produce classifiers that are surprisingly close to the optimal Bayes classifier. Figure 2.15 displays the KNN decision boundary, using K = 10, when applied to the larger simulated data set from Figure 2.13. Notice that even though the true distribution is not known by the KNN classifier, the KNN decision boundary is very close to that of the Bayes classifier. The test error rate using KNN is 0.1363, which is close to the Bayes error rate of 0.1304."}
{"id": 796, "contributed_by": "group 9", "title": "", "section": "", "text": "The choice of K has a drastic effect on the KNN classifier obtained. Figure 2.16 displays two KNN fits to the simulated data from Figure 2.13, using K = 1 and K = 100. When K = 1, the decision boundary is overly flexible and finds patterns in the data that don\u2019t correspond to the Bayes decision boundary. This corresponds to a classifier that has low bias but very high variance."}
{"id": 797, "contributed_by": "group 9", "title": "", "section": "", "text": "Just as in the regression setting, there is not a strong relationship between the training error rate and the test error rate. With K = 1, the KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more flexible classification methods, the training error rate will decline but the test error rate may not. "}
{"id": 798, "contributed_by": "group 9", "title": "", "section": "", "text": "In this lab, we will introduce some simple Python commands. For more resources about Python in general, readers may want to consult the tutorial at docs.python.org/3/tutorial/. Like most programming languages, Python uses functions to perform operations. To run a function called fun, we type fun(input1,input2), where the inputs (or arguments) input1 and input2 tell Python how to run the function."}
{"id": 799, "contributed_by": "group 9", "title": "", "section": "", "text": "A function can have any number of inputs. For example, the print() function outputs a text representation of all of its arguments to the console."}
{"id": 800, "contributed_by": "group 9", "title": "", "section": "", "text": "As mentioned earlier, this book makes use of functionality that is contained in the numpy library, or package. A package is a collection of modules that are not necessarily included in the base Python distribution. The name numpy is an abbreviation for numerical Python."}
{"id": 801, "contributed_by": "group 9", "title": "", "section": "", "text": "Note that if you forgot to run the import numpy as np command earlier, then you will encounter an error in calling the np.array() function in the previous line. The syntax np.array() indicates that the function be- ing called is part of the numpy package, which we have abbreviated as np."}
{"id": 802, "contributed_by": "group 9", "title": "", "section": "", "text": "For many more examples of how to make plots in Python, readers are encouraged to visit matplotlib.org/stable/gallery/. In matplotlib, a plot consists of a figure and one or more axes. You can think of the figure as the blank canvas upon which one or more plots will be displayed: it is the entire plotting window."}
{"id": 803, "contributed_by": "group 9", "title": "", "section": "", "text": "The axes contain important information about each plot, such as its x- and y-axis labels, title, and more. (Note that in matplotlib, the word axes is not the plural of axis: a plot\u2019s axes contains much more information than just the x-axis and the y-axis.)"}
{"id": 804, "contributed_by": "group 9", "title": "", "section": "", "text": "The ax.imshow() method is similar to ax.contour(), except that it produces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather forecasts. As seen above, the function np.linspace() can be used to create a sequence of numbers."}
{"id": 805, "contributed_by": "group 9", "title": "", "section": "", "text": "The function np.arange() returns a sequence of numbers spaced out by step. If step is not specified, then a default value of 1 is used. Let\u2019s create a sequence that starts at 0 and ends at 10."}
{"id": 806, "contributed_by": "group 9", "title": "", "section": "", "text": "This also explains why the earlier np.arange(0, 10) command output only the integers from 0 to 9. See the documentation slice? for useful options in creating slices. Typing A[1,2] retrieves the element corresponding to the second row and third column. (As usual, Python indexes from 0.)"}
{"id": 807, "contributed_by": "group 9", "title": "", "section": "", "text": "The first number after the open-bracket symbol [ refers to the row, and the second number refers to the column. Indexing Rows, Columns, and Submatrices To select multiple rows at a time, we can pass in a list specifying our selection. For instance, [1,3] will retrieve the second and fourth rows"}
{"id": 808, "contributed_by": "group 9", "title": "", "section": "", "text": "As another example of using a lambda, suppose that we want all cars built after 1980 that achieve greater than 30 miles per gallon. The symbol & computes an element-wise and operation. As another example, suppose that we want to retrieve all Ford and Datsun cars with displacement less than 300."}
{"id": 809, "contributed_by": "group 9", "title": "", "section": "", "text": "We check whether each name entry contains either the string ford or datsun using the str.contains() method of the index attribute of of the dataframe. Here, the symbol | computes an element-wise or operation."}
{"id": 810, "contributed_by": "group 9", "title": "", "section": "", "text": "For string and Boolean selections, use the loc[] method. For functional queries that filter rows, use the loc[] method with a function (typically a lambda) in the rows argument. A for loop is a standard tool in many languages that repeatedly evaluates some chunk of code while varying different values inside the code. For example, suppose we loop over elements of a list and compute their sum"}
{"id": 811, "contributed_by": "group 9", "title": "", "section": "", "text": "The loop ends either when the cell ends or when code is indented at the same level as the original for statement. We see that the final line above which prints the total is executed only once after the for loop has terminated. Loops can be nested by additional indentation."}
{"id": 812, "contributed_by": "group 9", "title": "", "section": "", "text": "We now consider the cylinders variable. Typing in Auto.cylinders.dtype reveals that it is being treated as a quantitative variable. However, since there is only a small number of possible values for this variable, we may wish to treat it as qualitative. Below, we replace the cylinders column with a categorical version of Auto.cylinders."}
{"id": 813, "contributed_by": "group 9", "title": "", "section": "", "text": "The function pd.Series() owes its name to the fact that pandas is often used in time series applications. Now that cylinders is qualitative, we can display it using the boxplot() method. The hist() method can be used to plot a histogram. The color of the bars and the number of bins can be changed. See Auto.hist? for more plotting options."}
{"id": 814, "contributed_by": "group 9", "title": "", "section": "", "text": "Simple linear regression assumes that there is approximately a linear relationship between X and Y. We will sometimes describe (3.1) by saying that we are regressing Y on X (or Y onto X)."}
{"id": 815, "contributed_by": "group 9", "title": "", "section": "", "text": "The model given by (3.5) defines the population regression line, which is the best linear approximation to the true relationship between X and Y."}
{"id": 816, "contributed_by": "group 9", "title": "", "section": "", "text": "The least squares regression coefficient estimates (3.4) characterize the least squares line (3.2). The left-hand panel of Figure 3.3 displays these two lines in a simple simulated example."}
{"id": 817, "contributed_by": "group 9", "title": "", "section": "", "text": "In fact, the least squares coefficient estimates given by (3.4) are unbiased, in the sense that on average, we expect them to equal the true population values."}
{"id": 818, "contributed_by": "group 9", "title": "", "section": "", "text": "We can compute the standard errors associated with the least squares coefficient estimates in order to determine how close they are likely to be to the true coefficient values."}
{"id": 819, "contributed_by": "group 9", "title": "", "section": "", "text": "If the predictions obtained using the model are very close to the true outcome values\u2014that is, if \u0177i \u2248 yi for i = 1, . . . , n\u2014then (3.15) will be small, and we can conclude that the model fits the data very well."}
{"id": 820, "contributed_by": "group 9", "title": "", "section": "", "text": "An R2 statistic that is close to 1 indicates that a large proportion of the variability in the response is explained by the regression."}
{"id": 821, "contributed_by": "group 9", "title": "", "section": "", "text": "We use a confidence interval to quantify the uncertainty surrounding the average sales over a large number of cities. For example, given that $100,000 is spent on TV and $20,000 is spent on radio advertising in each city, the 95% confidence interval is [10,985, 11,528]."}
{"id": 822, "contributed_by": "group 9", "title": "", "section": "", "text": "In contrast, a prediction interval can be used to quantify the uncertainty surrounding sales for a particular city. Given that $100,000 is spent on TV advertising and $20,000 is spent on radio advertising in that city, the 95% prediction interval is [7,930, 14,580]."}
{"id": 823, "contributed_by": "group 9", "title": "", "section": "", "text": "In the multiple regression setting with p predictors, we need to ask whether all of the regression coefficients are zero. As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis,"}
{"id": 824, "contributed_by": "group 9", "title": "", "section": "", "text": "Since collinearity reduces the accuracy of the estimates of the regression coefficients, it causes the standard error to grow."}
{"id": 825, "contributed_by": "group 9", "title": "", "section": "", "text": "As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of collinearity."}
{"id": 826, "contributed_by": "group 9", "title": "", "section": "", "text": "Inclusion of this interaction term relaxes the additive assumption. Notice that (3.31) can be rewritten as"}
{"id": 827, "contributed_by": "group 9", "title": "", "section": "", "text": "The hierarchical principle states that if we include an interaction in a model, we should also include the main effects, even if the p-values associated with their coefficients are not significant."}
{"id": 828, "contributed_by": "group 9", "title": "", "section": "", "text": "This limitation can be addressed by adding an interaction variable, created by multiplying income with the dummy variable for student."}
{"id": 829, "contributed_by": "group 9", "title": "", "section": "", "text": "In order to incorporate qualitative predictors into a regression model, we can create dummy variables that take on numerical values."}
{"id": 830, "contributed_by": "group 9", "title": "", "section": "", "text": "There will always be one fewer dummy variable than the number of levels. The level with no dummy variable\u2014East in this example\u2014is known as the baseline."}
{"id": 831, "contributed_by": "group 9", "title": "", "section": "", "text": "If the residual plot indicates that there are non-linear associations in the data, then a simple approach is to use non-linear transformations of the predictors, such as log X, \u221aX, and X2, in the regression model."}
{"id": 832, "contributed_by": "group 9", "title": "", "section": "", "text": "In the left-hand panel of Figure 3.11, the magnitude of the residuals tends to increase with the fitted values. When faced with this problem, one possible solution is to transform the response Y using a concave function such as log Y or \u221aY."}
{"id": 833, "contributed_by": "group 9", "title": "", "section": "", "text": "Outliers are observations for which the response yi is far from the value predicted by the model. In contrast, observations with high leverage have an unusual value for xi."}
{"id": 834, "contributed_by": "group 9", "title": "", "section": "", "text": "High leverage observations tend to have a sizable impact on the estimated regression line. It is cause for concern if the least squares line is heavily affected by just a couple of observations, because any problems with these points may invalidate the entire fit."}
{"id": 835, "contributed_by": "group 9", "title": "", "section": "", "text": "Parametric methods like linear regression have several advantages. They are often easy to fit, coefficients have simple interpretations, and inference is straightforward. But they assume a functional form which may be unrealistic."}
{"id": 836, "contributed_by": "group 9", "title": "", "section": "", "text": "When K=1, the KNN fit perfectly interpolates the training observations, and consequently takes the form of a step function."}
{"id": 837, "contributed_by": "group 9", "title": "", "section": "", "text": "In general, the optimal value for K will depend on the bias-variance tradeoff. A small value for K provides the most flexible fit, with low bias but high variance. Larger K values provide a smoother, less variable fit with higher bias."}
{"id": 838, "contributed_by": "group 9", "title": "", "section": "", "text": "In what setting will a parametric approach such as least squares linear regression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non-parametric approach if the parametric form that has been selected is close to the true form of f(X)."}
{"id": 839, "contributed_by": "group 9", "title": "", "section": "", "text": "This decrease in performance as the dimension increases is a common problem for KNN, and results from a phenomenon in which a given observation has no nearby neighbors\u2014this is the so-called curse of dimensionality."}
{"id": 840, "contributed_by": "group 9", "title": "", "section": "", "text": "Residual plots are a useful graphical tool for identifying violations of linear regression assumptions, such as non-linearity and non-constant variance."}
{"id": 841, "contributed_by": "group 9", "title": "", "section": "", "text": "Collinearity between predictors can pose problems in regression because it inflates the variance of the coefficient estimates."}
{"id": 842, "contributed_by": "group 9", "title": "", "section": "", "text": "We test the null hypothesis, versus the alternative Hypothesis: at least one variable is non-zero."}
{"id": 843, "contributed_by": "group 9", "title": "", "section": "", "text": "In fact, it is likely that we will observe at least one p-value below 0.05 by chance! Hence, if we use the individual t-statistics and associated p-values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a relationship."}
{"id": 844, "contributed_by": "group 9", "title": "", "section": "", "text": "There are three classical approaches for this task: forward selection, backward selection, and mixed selection."}
{"id": 845, "contributed_by": "group 9", "title": "", "section": "", "text": "Unfortunately, there are a total of 2p models that contain subsets of p variables. This means that even for moderate p, trying out every possible subset of the predictors is infeasible."}
{"id": 846, "contributed_by": "group 9", "title": "", "section": "", "text": "Various statistics can be used to judge the quality of a model. These include Mallow's Cp, Akaike information criterion (AIC), Bayesian information criterion (BIC), and adjusted R2."}
{"id": 847, "contributed_by": "group 9", "title": "", "section": "", "text": "We saw that R2 always increases when variables are added to the model, even if they are useless. Adjusted R2 imposes a penalty for unnecessary variables."}
{"id": 848, "contributed_by": "group 9", "title": "", "section": "", "text": "Prediction intervals are always wider than confidence intervals, because they incorporate both the error in the estimate for f(X) and the uncertainty as to how much an individual point will differ from the population regression plane."}
{"id": 849, "contributed_by": "group 9", "title": "", "section": "", "text": "In this case, a simple remedy is to fit our model by weighted least squares, with weights proportional to the inverse variances\u2014i.e. wi = ni in this case."}
{"id": 850, "contributed_by": "group 9", "title": "", "section": "", "text": "The second solution is to combine the collinear variables together into a single predictor. For instance, we might take the average of standardized versions of limit and rating in order to create a new variable that measures credit worthiness."}
{"id": 851, "contributed_by": "group 9", "title": "", "section": "", "text": "The VIF is the ratio of the variance when fitting the full model divided by the variance if fit on its own."}
{"id": 852, "contributed_by": "group 9", "title": "", "section": "", "text": "In Chapter 5, we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of K in KNN regression."}
{"id": 853, "contributed_by": "group 9", "title": "", "section": "", "text": "In what setting will a parametric approach such as least squares linear regression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non-parametric approach if the parametric form that has been selected is close to the true form of f(X)."}
{"id": 854, "contributed_by": "group 10", "title": "", "section": "", "text": "Such an approach may allow us to obtain information that would not be available from ftting the model only once using the original training sample"}
{"id": 855, "contributed_by": "group 10", "title": "", "section": "", "text": "They involve repeatedly drawing samples from a training set and reftting a model of interest on each sample in order to obtain additional information about the ftted model."}
{"id": 856, "contributed_by": "group 10", "title": "", "section": "", "text": "Cross-validation can be used to estimate the test error associated with a given statistical learning method in order to evaluate its performance, or to select the appropriate level of fexibility."}
{"id": 857, "contributed_by": "group 10", "title": "", "section": "", "text": "Resampling approaches can be computationally expensive, because they involve ftting the same statistical method multiple times using diferent subsets of the training data."}
{"id": 858, "contributed_by": "group 10", "title": "", "section": "", "text": "Since statistical methods tend to per-form worse when trained on fewer observations, this suggests that the validation set error rate may tend to overestimate the test error rate for the model ft on the entire data set."}
{"id": 859, "contributed_by": "group 10", "title": "", "section": "", "text": "the validation esti-mate of the test error rate can be highly variable, depending on pre-cisely which observations are included in the training set and which observations are included in the validation set."}
{"id": 860, "contributed_by": "group 10", "title": "", "section": "", "text": "LOOCV has a couple of major advantages over the validation set ap-proach. First, it has far less bias."}
{"id": 861, "contributed_by": "group 10", "title": "", "section": "", "text": "In LOOCV, we repeatedly ft the sta-tistical learning method using training sets that contain n - 1 observa-tions, almost as many as are in the entire data set. This is in contrast to the validation set approach, in which the training set is typically around half the size of the original data set."}
{"id": 862, "contributed_by": "group 10", "title": "", "section": "", "text": "This is in contrast to the validation set approach, in which the training set is typically around half the size of the original data set. Consequently, the LOOCV approach tends not to overestimate the test error rate as much as the validation set approach does."}
{"id": 863, "contributed_by": "group 10", "title": "", "section": "", "text": "Second, in contrast to the validation approach which will yield diferent results when applied repeatedly due to randomness in the training/validation set splits, performing LOOCV multiple times will always yield the same results: there is no randomness in the training/vali-dation set splits."}
{"id": 864, "contributed_by": "group 10", "title": "", "section": "", "text": "LOOCV has the potential to be expensive to implement, since the model has to be ft n times. This can be very time consuming if n is large, and if each individual model is slow to ft."}
{"id": 865, "contributed_by": "group 10", "title": "", "section": "", "text": "LOOCV is a very general method, and can be used with any kind of predictive modeling."}
{"id": 866, "contributed_by": "group 10", "title": "", "section": "", "text": "To summarize, there is a bias-variance trade-of associated with the choice of k in k-fold cross-validation."}
{"id": 867, "contributed_by": "group 10", "title": "", "section": "", "text": "Typically, given these considerations, one performs k-fold cross-validation using k = 5 or k = 10, as these values have been shown empirically to yield test error rate estimates that sufer neither from excessively high bias nor from very high variance."}
{"id": 868, "contributed_by": "group 10", "title": "", "section": "", "text": "In practice, for real data, the Bayes decision boundary and the test er-ror rates are unknown. So how might we decide between the four logistic regression models displayed"}
{"id": 869, "contributed_by": "group 10", "title": "", "section": "", "text": "In fact, using fourth-order polynomials would likely lead to good test set performance, as the true test error rate is approximately the same for third, fourth, ffth, and sixth-order polynomials."}
{"id": 870, "contributed_by": "group 10", "title": "", "section": "", "text": "Again the training error rate declines as the method becomes more fexible, and so we see that the training error rate cannot be used to select the optimal value for K."}
{"id": 871, "contributed_by": "group 10", "title": "", "section": "", "text": "The sampling is performed with replacement, which means that the with replacement same observation can occur more than once in the bootstrap data set. In  this example, Z*1 contains the third observation twice, the frst observation once, and no instances of the second observation. "}
{"id": 872, "contributed_by": "group 10", "title": "", "section": "", "text": "The model is fit on the training set, and the ftted model is used to predict the responses for the observations in the validation set.The resulting validation set error rate-typically assessed using MSE in the case of a quantitative  response-provides an estimate of the test error rate."}
{"id": 873, "contributed_by": "group 10", "title": "", "section": "", "text": "simple strategy validation set approach for this task. It involves randomly dividing the available set of observa-tions into two parts, a training set and a validation set or hold-out set."}
{"id": 874, "contributed_by": "group 10", "title": "", "section": "", "text": "The resulting validation set error rate-typically assessed using MSE in the case of a quantitative response-provides an estimate of the test error rate."}
{"id": 875, "contributed_by": "group 10", "title": "", "section": "", "text": "the validation esti-mate of the test error rate can be highly variable, depending on pre-cisely which observations are included in the training set and which observations are included in the validation set."}
{"id": 876, "contributed_by": "group 10", "title": "", "section": "", "text": "Leave-one-out cross-validation (LOOCV) is closely related to the validation leave-one-out cross-validation set approach of Section 5.1.1, but it attempts to address that method's drawbacks."}
{"id": 877, "contributed_by": "group 10", "title": "", "section": "", "text": "In the validation approach, only a subset of the observations-those that are included in the training set rather than in the validation set-are used to ft the model. Since statistical methods tend to per-form worse when trained on fewer observations,"}
{"id": 878, "contributed_by": "group 10", "title": "", "section": "", "text": "Like the validation set approach, LOOCV involves splitting the set of observations into two parts. However, instead of creating two subsets of comparable size, a single observation is used for the validation set, and the remaining observations  make up the training set."}
{"id": 879, "contributed_by": "group 10", "title": "", "section": "", "text": "Consequently, the LOOCV approach tends not to overestimate the test error rate as much as the validation set approach does. Second, in contrast to the validation approach which will yield diferent results when applied repeatedly due to randomness in the training/validation set splits,"}
{"id": 880, "contributed_by": "group 10", "title": "", "section": "", "text": "This can be very time consuming if n is large, and if each individual model is slow to ft. With least squares linear or polynomial regression, an amazing shortcut makes the cost of LOOCV the same as that of a single model ft!"}
{"id": 881, "contributed_by": "group 10", "title": "", "section": "", "text": "But even though MSE1 is unbiased for the test error, it is a poor estimate because it is highly variable, since it is based upon a single observation"}
{"id": 882, "contributed_by": "group 10", "title": "", "section": "", "text": "LOOCV has a couple of major advantages over the validation set ap-proach. First, it has far less bias. In LOOCV, we repeatedly ft the sta-tistical learning method using training sets that contain n - 1 observa-tions, almost as many as are in the entire data set."}
{"id": 883, "contributed_by": "group 10", "title": "", "section": "", "text": "We start by writing a generic function boot_OLS() for bootstrapping a regression model that takes a formula to defne the corresponding regres-sion."}
{"id": 884, "contributed_by": "group 10", "title": "", "section": "", "text": "We use the clone() function to make a copy of the formula that can clone() be refit to the new dataframe. This means that any derived features such as those defined by poly() (which we will see shortly), will be refit on the resampled data frame."}
{"id": 885, "contributed_by": "group 10", "title": "", "section": "", "text": "The cross_validate() function is fexible and can take diferent splitting mechanisms as an argument. For instance, one can use the ShuffleSplit() Shuffle Split() funtion to implement the validation set approach just as easily as K-fold cross-validation"}
{"id": 886, "contributed_by": "group 10", "title": "", "section": "", "text": "Note that this standard deviation is not a valid estimate of the sam-pling variability of the mean test score or the individual scores, since the randomly-selected training samples overlap and hence introduce correla-tions."}
{"id": 887, "contributed_by": "group 10", "title": "", "section": "", "text": "It may not be immediately obvious why such a constraint should improve the fit, but it turns out that shrinking the coefficient estimates can signifcantly reduce their variance.The two best-known techniques for shrinking the regression coefficients towards zero are ridge regression and the lasso."}
{"id": 888, "contributed_by": "group 10", "title": "", "section": "", "text": "Ridge regression is very similar to least squares, except that the coefficients ridge regression are estimated by minimizing a slightly diferent quantity. In particular, the ridge regression coefcient estimates beta^R are the values"}
{"id": 889, "contributed_by": "group 10", "title": "", "section": "", "text": "the impact of the shrinkage penalty grows, and the ridge regression coefficient estimates will approach zero. Unlike least squares, which generates only one set of co-efficient estimates, ridge regression will produce a different set of coefficient estimates,"}
{"id": 890, "contributed_by": "group 10", "title": "", "section": "", "text": "In contrast, the ridge regression coefcient estimates can change sub-stantially when multiplying a given predictor by a constant."}
{"id": 891, "contributed_by": "group 10", "title": "", "section": "", "text": "At the least squares coefficient estimates, which correspond to ridge regression with lambda = 0, the variance is high but there is no bias. But as \u03bb increases, the shrinkage of the ridge coefficient estimates leads to a substantial reduction in the variance"}
{"id": 892, "contributed_by": "group 10", "title": "", "section": "", "text": "linear, the least squares estimates will have low bias but may have high variance. This means that a small change in the training data can cause a large change in the least squares coefficient estimates."}
{"id": 893, "contributed_by": "group 10", "title": "", "section": "", "text": "for any fxed value of lambda, ridge regression only fts a single model, and the model-ftting procedure can be performed quite quickly."}
{"id": 894, "contributed_by": "group 10", "title": "", "section": "", "text": "As a result, models generated from the lasso are generally much easier to interpret than those produced by ridge regression."}
{"id": 895, "contributed_by": "group 10", "title": "", "section": "", "text": "When lambda = 0, then the lasso simply gives the least squares fit, and when lambda becomes sufficiently large, the lasso gives the null model in which all coefficient estimates equal zero."}
{"id": 896, "contributed_by": "group 10", "title": "", "section": "", "text": "When lambda = 0, then the lasso simply gives the least squares fit, and when lambda becomes sufficiently large, the lasso gives the null model in which all coefficient estimates equal zero."}
{"id": 897, "contributed_by": "group 10", "title": "", "section": "", "text": "ridge regression has a circular constraint with no sharp points, this intersection will not generally occur on an axis"}
{"id": 898, "contributed_by": "group 10", "title": "", "section": "", "text": "Unlike ridge regression, the lasso performs variable selection, and hence results in models that are easier to interpret."}
{"id": 899, "contributed_by": "group 10", "title": "", "section": "", "text": "In ridge regression, each least squares coefficient estimate is shrunken by the same proportion. In contrast, the lasso shrinks each least squares coefcient towards zero by a constant amount,"}
{"id": 900, "contributed_by": "group 10", "title": "", "section": "", "text": "The type of shrinkage performed by the lasso in this simple setting (6.15) is known as soft-thresholding. The fact that some lasso coefcients are shrunken entirely to zero explains why the lasso performs feature selection"}
{"id": 901, "contributed_by": "group 10", "title": "", "section": "", "text": "Principal components analysis (PCA) is a popular approach for deriving a low-dimensional set of features from a large set of variables."}
{"id": 902, "contributed_by": "group 10", "title": "", "section": "", "text": "There is also another interpretation of PCA: the frst principal component vector defnes the line that is as close as possible to the data"}
{"id": 903, "contributed_by": "group 10", "title": "", "section": "", "text": "The PCR approach that we just described involves identifying linear combinations, or directions, that best represent the predictors X1,...,Xp. These directions are identifed in an unsupervised way,"}
{"id": 904, "contributed_by": "group 10", "title": "", "section": "", "text": "Data sets containing more features than observations are often referred to as high-dimensional. Classical approaches such as least squares linear regression are not appropriate in this setting"}
{"id": 905, "contributed_by": "group 10", "title": "", "section": "", "text": "adding additional signal features that are truly associated with the response will improve the ftted model, in the sense of leading to a reduction in test set error. However, adding noise features that are not truly associated with the response will lead to a deterioration in the fitted model"}
{"id": 906, "contributed_by": "group 10", "title": "", "section": "", "text": "feature selection or variable selection-that is, for excluding irrelevant variables from a multiple regression model"}
{"id": 907, "contributed_by": "group 10", "title": "", "section": "", "text": "Dimension Reduction. This approach involves projecting the p predictors into an M-dimensional subspace, where M<p. This is achieved by computing M diferent linear combinations, or projections, of the variables. Then these M projections are used as predictors to fit a linear regression model by least squares."}
{"id": 908, "contributed_by": "group 10", "title": "", "section": "", "text": "To perform best subset selection, we ft a separate least squares regression for each possible combination of the p predictors. That is, we ft all p models that contain exactly one predictor, all (p/2)= p(p-1)/2 models that contain exactly two predictors, and so forth."}
{"id": 909, "contributed_by": "group 10", "title": "", "section": "", "text": "The problem is that a low RSS or a high R2 indicates a model with a low training error, whereas we wish to choose a model that has a low test error."}
{"id": 910, "contributed_by": "group 10", "title": "", "section": "", "text": "the deviance, a measure deviance that plays the role of RSS for a broader class of models. The deviance is negative two times the maximized log-likelihood; the smaller the deviance, the better the ft."}
{"id": 911, "contributed_by": "group 10", "title": "", "section": "", "text": "The larger the search space, the higher the chance of fnding models that look good on the training data, even though they might not have any predictive power on future data. Thus an enormous search space can lead to overftting and high variance of the coefcient estimates."}
{"id": 912, "contributed_by": "group 10", "title": "", "section": "", "text": "Forward stepwise selection is a computationally efcient alternative to best subset selection. While the best subset selection procedure considers all 2^p possible models containing subsets of the p predictors, forward stepwise considers a much smaller set of models."}
{"id": 913, "contributed_by": "group 10", "title": "", "section": "", "text": "Like forward stepwise selection, backward stepwise selection provides an efcient alternative to best subset selection. However, unlike forward stepwise selection, it begins with the full least squares model containing all p predictors, and then iteratively removes the least useful predictor, one-at-a-time"}
{"id": 914, "contributed_by": "group 10", "title": "", "section": "", "text": "Backward selection requires that the number of samples n is larger than the number of variables p (so that the full model can be ft). In contrast, forward stepwise can be used even when n<p, and so is the only viable subset method when p is very large"}
{"id": 915, "contributed_by": "group 10", "title": "", "section": "", "text": "The best subset, forward stepwise, and backward stepwise selection approaches generally give similar but not identical models. As another alternative, hybrid versions of forward and backward stepwise selection are available, in which variables are added to the model sequentially, in analogy to forward selection. "}
{"id": 916, "contributed_by": "group 10", "title": "", "section": "", "text": "the training error will decrease as more variables are included in the model, but the test error may not. Therefore, training set RSS and training set R2 cannot be used to select from among a set of models with diferent numbers of variables."}
{"id": 917, "contributed_by": "group 10", "title": "", "section": "", "text": "the Cp statistic tends to take on a small value for models with a low test error, so when determining which of a set of models is best, we choose the model with the lowest Cp value."}
{"id": 918, "contributed_by": "group 10", "title": "", "section": "", "text": "Like Cp, the BIC will tend to take on a small value for a model with a low test error, and so generally we select the model that has the lowest BIC value."}
{"id": 919, "contributed_by": "group 10", "title": "", "section": "", "text": "The intuition behind the adjusted R2 is that once all of the correct variables have been included in the model, adding additional noise variables will lead to only a very small decrease in RSS."}
{"id": 920, "contributed_by": "group 10", "title": "", "section": "", "text": "in theory, the model with the largest adjusted R2 will have only correct variables and no noise variables. Unlike the R2 statistic, the adjusted R2 statistic pays a price for the inclusion of unnecessary variables in the model."}
{"id": 921, "contributed_by": "group 10", "title": "", "section": "", "text": "Step functions cut the range of a variable into K distinct regions in order to produce a qualitative variable. This has the effect of fitting a piecewise constant function."}
{"id": 922, "contributed_by": "group 10", "title": "", "section": "", "text": "Smoothing splines are similar to regression splines, but arise in a slightly different situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty."}
{"id": 923, "contributed_by": "group 10", "title": "", "section": "", "text": "Regression splines are more flexible than polynomials and step functions, and in fact are an extension of the two. They involve dividing the range of X into K distinct regions."}
{"id": 924, "contributed_by": "group 10", "title": "", "section": "", "text": "The estimated pointwise standard error of f(x0) is the square-root of this variance. This computation is repeated at each reference point x0, and we plot the fitted curve, as well as twice the standard error on either side of the fitted curve."}
{"id": 925, "contributed_by": "group 10", "title": "", "section": "", "text": "The points where the coefficients change are called knots. For example, a piecewise cubic with no knots is just a standard cubic knot polynomial"}
{"id": 926, "contributed_by": "group 10", "title": "", "section": "", "text": "Using more knots leads to a more flexible piecewise polynomial. In general, if we place K different knots throughout the range of X, then we will end up fitting K +1 different cubic polynomials."}
{"id": 927, "contributed_by": "group 10", "title": "", "section": "", "text": "Polynomial and piecewise-constant regression models are in fact special cases of a basis function approach. The idea is to have at hand a family of functions or transformations that can be applied to a variable X"}
{"id": 928, "contributed_by": "group 10", "title": "", "section": "", "text": "Since each polynomial has four parameters, we are using a total of eight degrees of freedom in fitting this piecewise polynomial model."}
{"id": 929, "contributed_by": "group 10", "title": "", "section": "", "text": "Instead of fitting a high-degree polynomial over the entire range of X, piecewise polynomial regression involves fitting separate low-degree polynomials over different regions of X."}
{"id": 930, "contributed_by": "group 10", "title": "", "section": "", "text": "Regression splines often give superior results to polynomial regression. This is because unlike polynomials, which must use a high degree to produce flexible fits, splines introduce flexibility by increasing the number of knots but keeping the degree fixed."}
{"id": 931, "contributed_by": "group 10", "title": "", "section": "", "text": "Using more knots leads to a more flexible piecewise polynomial. In general, if we place K different knots throughout the range of X, then we will end up fitting K +1 different cubic polynomials."}
{"id": 932, "contributed_by": "group 10", "title": "", "section": "", "text": "Local regression also generalizes very naturally when we want to fit models that are local in a pair of variables X1 and X2, rather than one."}
{"id": 933, "contributed_by": "group 10", "title": "", "section": "", "text": "A natural spline is a regression spline with additional boundary constraints: the natural function is required to be linear at the boundary (in the region where X is spline smaller than the smallest knot, or larger than the largest knot)."}
{"id": 934, "contributed_by": "group 10", "title": "", "section": "", "text": "The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed."}
{"id": 935, "contributed_by": "group 10", "title": "", "section": "", "text": "The regression spline is most flexible in regions that contain a lot of knots, because in those regions the polynomial coefficients can change rapidly."}
{"id": 936, "contributed_by": "group 10", "title": "", "section": "", "text": "The general definition of a degree-d spline is that it is a piecewise degree-d polynomial, with continuity in derivatives up to degree d - 1 at each knot. Therefore, a linear spline is obtained by fitting a line in each region of the predictor space defined by the knots, requiring continuity at each knot."}
{"id": 937, "contributed_by": "group 10", "title": "", "section": "", "text": "Local regression is a different approach for fitting flexible non-linear functions, which involves computing the fit at a target point x0 using only the nearby training observations."}
{"id": 938, "contributed_by": "group 10", "title": "", "section": "", "text": "splines can have high variance at the outer range of the predictors that is, when X takes on either a very small or very large value."}
{"id": 939, "contributed_by": "group 10", "title": "", "section": "", "text": "Local regression is sometimes referred to as a memory-based procedure, because like nearest-neighbors, we need all the training data each time we wish to compute a prediction."}
{"id": 940, "contributed_by": "group 10", "title": "", "section": "", "text": "A feedforward network is a multilayer network in which the units are connected with no cycles; the outputs from units in each layer are passed to units in the next higher layer, and no outputs are passed back to lower layers."}
{"id": 941, "contributed_by": "group 10", "title": "", "section": "", "text": "Python package pygam can be used to fit GAMs using smoothing splines, via an approach known as backfitting. This method fits a model involving multiple predictors by repeatedly updating the fit for each predictor in turn, holding the others fixed."}
{"id": 942, "contributed_by": "group 10", "title": "", "section": "", "text": "cross-entropy loss is simply the negative log of the output probability corresponding to the correct class, and we therefore also call this the negative negative log log likelihood loss"}
{"id": 943, "contributed_by": "group 10", "title": "", "section": "", "text": "Generalized additive models (GAMs) provide a general framework for extending a standard linear model by allowing non-linear functions of each of the variables, while maintaining additivity. Just like linear models, GAMs can be applied with both quantitative and qualitative responses."}
{"id": 944, "contributed_by": "group 10", "title": "", "section": "", "text": "For logistic regression we can initialize gradient descent with all the weights and biases having the value 0. In neural networks, by contrast, we need to initialize the weights with small random numbers. It's also helpful to normalize the input values to have 0 mean and unit variance."}
{"id": 945, "contributed_by": "group 10", "title": "", "section": "", "text": "The intuition of backward differentiation is to pass gradients back from the final node to all the nodes in the graph."}
{"id": 946, "contributed_by": "group 10", "title": "", "section": "", "text": "In fitting a smoothing spline, we do not need to select the number or location of the knots there will be a knot at each training observation, x1, . . . ,xn. Instead, we have another problem: we need to choose the value of lambda. It should come as no surprise that one possible solution to this problem is cross-validation."}
{"id": 947, "contributed_by": "group 10", "title": "", "section": "", "text": "indicator function that returns a 1 if the condition is true, and returns a 0 otherwise. For example, I(cK <= X) equals 1 if cK <= X, and equals 0 otherwise. These are sometimes called dummy variables."}
{"id": 948, "contributed_by": "group 10", "title": "", "section": "", "text": "Let's walk through forward inference or decoding for neural language models. Forward inference is the task, given an input, of running a forward pass on the network to produce a probability distribution over possible outputs, in this case next words."}
{"id": 949, "contributed_by": "group 10", "title": "", "section": "", "text": "The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the form Xj * Xk"}
{"id": 950, "contributed_by": "group 10", "title": "", "section": "", "text": "The importance of the computation graph comes from the backward pass, which is used to compute the derivatives that we'll need for the weight update."}
{"id": 951, "contributed_by": "group 10", "title": "", "section": "", "text": "One option is to place more knots in places where we feel the function might vary most rapidly, and to place fewer knots where it seems more stable. While this option can work well, in practice it is common to place knots in a uniform fashion."}
{"id": 952, "contributed_by": "group 10", "title": "", "section": "", "text": "Unfortunately, splines can have high variance at the outer range of the predictors that is, when X takes on either a very small or very large value. We see that the confidence bands in the boundary region appear fairly wild. A natural spline is a regression spline with additional boundary constraints: the function is required to be linear at the boundary (in the region where X is smaller than the smallest knot, or larger than the largest knot). This additional constraint means that natural splines generally produce more stable estimates at the boundaries."}
{"id": 953, "contributed_by": "group 10", "title": "", "section": "", "text": "The span plays a role like that of the tuning parameter in smoothing splines it controls the flexibility of the non-linear fit. The smaller the value of s, the more local and wiggly will be our fit; alternatively, a very large value of s will lead to a global fit to the data using all of the training observations."}
{"id": 954, "contributed_by": "group 10", "title": "", "section": "", "text": "Thus far we have considered the use of polynomial functions and piecewise constant functions for our basis functions; however, many alternatives are possible. For instance, we can use wavelets or Fourier series to construct basis functions."}
{"id": 955, "contributed_by": "group 11", "title": "", "section": "", "text": "A classifcation tree is very similar to a regression tree, except that it is classifcation tree used to predict a qualitative response rather than a quantitative one. Recall that for a regression tree, the predicted response for an observation is given by the mean response of the training observations that belong to the same terminal node."}
{"id": 956, "contributed_by": "group 11", "title": "", "section": "", "text": "A classification tree is very similar to a regression tree, except that it is used to predict a qualitative response rather than a quantitative one. Recall that for a regression tree, the predicted response for an observation is given by the mean response of the training observations that belong to the same terminal node. "}
{"id": 957, "contributed_by": "group 11", "title": "", "section": "", "text": "In contrast, for a classification tree, we predict that each observation belongs to the most commonly occurring class of training observations in the region to which it belongs. In interpreting the results of a classification tree, we are often interested not only in the class prediction corresponding to a particular terminal node region, but also in the class proportions among the training observations that fall into that region."}
{"id": 958, "contributed_by": "group 11", "title": "", "section": "", "text": "The task of growing a classification tree is quite similar to the task of growing a regression tree. Just as in the regression setting, we use recursive binary splitting to grow a classification tree. However, in the classification setting, RSS cannot be used as a criterion for making the binary splits. "}
{"id": 959, "contributed_by": "group 11", "title": "", "section": "", "text": "The task of growing a classification tree is quite similar to the task of growing a regression tree. Just as in the regression setting, we use recursive binary splitting to grow a classification tree. However, in the classification setting, RSS cannot be used as a criterion for making the binary splits. "}
{"id": 960, "contributed_by": "group 11", "title": "", "section": "", "text": "A natural alternative to RSS is the classification error rate. Since we plan to assign an observation in a given region to the most commonly occurring class of training observations in that region, the classification error rate is simply the fraction of the training observations in that region that do not belong to the most common class"}
{"id": 961, "contributed_by": "group 11", "title": "", "section": "", "text": "However, it turns out that classification error is not sufficiently sensitive for tree-growing, and in practice two other measures are preferable. The Gini index is defined by a measure of total variance across the K classes"}
{"id": 962, "contributed_by": "group 11", "title": "", "section": "", "text": "Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure. In fact, it turns out that the Gini index and the entropy are quite similar numerically. When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. "}
{"id": 963, "contributed_by": "group 11", "title": "", "section": "", "text": "The Gini index is defined as a measure of total variance across the K classes. It's easy to understand that the Gini index has a small value when all of the pmk values are near zero or one. That's why the Gini index is often called a measure of node purity. A small value shows that a node mainly has observations from just one class."}
{"id": 964, "contributed_by": "group 11", "title": "", "section": "", "text": "There are 13 predictors including Age, Sex, Chol (a cholesterol measurement), and other heart and lung function measurements. Cross-validation results in a tree with six terminal nodes. In our discussion thus far, we have assumed that the predictor variables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables. For instance, in the Heart data, some of the predictors, such as Sex, Thal (Thallium stress test), and ChestPain, are qualitative."}
{"id": 965, "contributed_by": "group 11", "title": "", "section": "", "text": "Why, then, is the split performed at all? The split is performed because it leads to increased node purity. That is, all 9 of the observations corresponding to the right-hand leaf have a response value of Yes, whereas 7/11 of those corresponding to the left-hand leaf have a response value of Yes. Why is node purity important? Suppose that we have a test observation that belongs to the region given by that right-hand leaf. Then we can be pretty certain that its response value is Yes"}
{"id": 966, "contributed_by": "group 11", "title": "", "section": "", "text": " Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression. Some people believe that decision trees more closely mirror human decision-making than do the regression and classification approaches seen in previous chapters. Trees can be displayed graphically, and are easily interpreted even by a non-expert (especially if they are small)."}
{"id": 967, "contributed_by": "group 11", "title": "", "section": "", "text": " Additionally, trees can be very non-robust. In other words, a small change in the data can cause a large change in the final estimated tree. However, by aggregating many decision trees, using methods like bagging, random forests, and boosting, the predictive performance of trees can be substantially improved."}
{"id": 968, "contributed_by": "group 11", "title": "", "section": "", "text": "It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. Recall that the key to bagging is that trees are repeatedly fit to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations.3 The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag (OOB) observations."}
{"id": 969, "contributed_by": "group 11", "title": "", "section": "", "text": "OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous."}
{"id": 970, "contributed_by": "group 11", "title": "", "section": "", "text": "Random forests provide an improvement over bagged trees by way of a small tweak that decorrelates the trees. As in bagging, we build a number of decision trees on bootstrapped training samples. But when building these decision trees, each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors. The split is allowed to use only one of those m predictors."}
{"id": 971, "contributed_by": "group 11", "title": "", "section": "", "text": "Finally, we discuss Bayesian additive regression trees (BART), another ensemble method that uses decision trees as its building blocks. For simplicity, we present BART for regression (as opposed to classification). Recall that bagging and random forests make predictions from an average of regression trees, each of which is built using a random sample of data and predictors."}
{"id": 972, "contributed_by": "group 11", "title": "", "section": "", "text": "Trees are an attractive choice of weak learner for an ensemble method for a number of reasons, including their fexibility and ability to handle predictors of mixed types (i.e. qualitative as well as quantitative). We have now seen four approaches for ftting an ensemble of trees: bagging, random forests, boosting, and BART."}
{"id": 973, "contributed_by": "group 11", "title": "", "section": "", "text": "In random forests, the trees are once again grown independently on random samples of the observations. However, each split on each tree is performed using a random subset of the features, thereby decorrelating the trees, and leading to a more thorough exploration of model space relative to bagging."}
{"id": 974, "contributed_by": "group 11", "title": "", "section": "", "text": "The task of growing a classification tree is quite similar to the task of growing a regression tree. Just as in the regression setting, we use recursive binary splitting to grow a classification tree. However, in the classification setting, RSS cannot be used as a criterion for making the binary splits. A natural alternative to RSS is the classification error rate."}
{"id": 975, "contributed_by": "group 11", "title": "", "section": "", "text": "However, it turns out that classification error is not sufficiently sensitive for tree-growing, and in practice two other measures are preferable. The Gini index is defined by a measure of total variance across the K classes. It is not hard to see that the Gini index takes on a small value if all of the \u02c6pmk\u2019s are close to zero or one."}
{"id": 976, "contributed_by": "group 11", "title": "", "section": "", "text": "Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure. In fact, it turns out that the Gini index and the entropy are quite similar numerically. When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. Any of these three approaches might be used when pruning the tree, but the classification error rate is preferable if prediction accuracy of the final pruned tree is the goal."}
{"id": 977, "contributed_by": "group 11", "title": "", "section": "", "text": "Therefore, like the Gini index, the entropy will take on a small value if the mth node is pure. In fact, it turns out that the Gini index and the entropy are quite similar numerically. When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classification error rate. Any of these three approaches might be used when pruning the tree, but the classification error rate is preferable if prediction accuracy of the final pruned tree is the goal."}
{"id": 978, "contributed_by": "group 11", "title": "", "section": "", "text": "These data contain a binary outcome HD for 303 patients who presented with chest pain. An outcome value of Yes indicates the presence of heart disease based on an angiographic test, while No means no heart disease. There are 13 predictors including Age, Sex, Chol (a cholesterol measurement), and other heart and lung function measurements. Cross-validation results in a tree with six terminal nodes. In our discussion thus far, we have assumed that the predictor variables take on continuous values. However, decision trees can be constructed even in the presence of qualitative predictor variables. For instance, in the Heart data, some of the predictors, such as Sex, Thal (Thallium stress test), and ChestPain, are qualitative. Therefore, a split on one of these variables amounts to assigning some of the qualitative values to one branch and assigning the remaining to the other branch"}
{"id": 979, "contributed_by": "group 11", "title": "", "section": "", "text": "The text ChestPain two splits down the tree on the left indicates that the left-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. The figure has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value. For instance, consider the split RestECG is less than 1 near the bottom right of the unpruned tree."}
{"id": 980, "contributed_by": "group 11", "title": "", "section": "", "text": "The text ChestPain two splits down the tree on the left indicates that the left-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. The figure has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value. For instance, consider the split RestECG is less than 1 near the bottom right of the unpruned tree."}
{"id": 981, "contributed_by": "group 11", "title": "", "section": "", "text": "while bagging can improve predictions for many regression methods,it is particularly useful for decision trees. To apply bagging to regression trees, we simply construct B regression trees using B bootstrapped training sets, and average the resulting predictions. These trees are grown deep, and are not pruned. Hence each individual tree has high variance, but low bias. Averaging these B trees reduces the variance. Bagging has been demonstrated to give impressive improvements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression"}
{"id": 982, "contributed_by": "group 11", "title": "", "section": "", "text": "It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. Recall that the key to bagging is that trees are repeatedly fit to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations. The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag observations."}
{"id": 983, "contributed_by": "group 11", "title": "", "section": "", "text": "The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag (OOB) observations. We can predict the response for the ith observation using each of the trees in which that observation was OOB. This will yield around B/3 predictions for the ith observation. In order to obtain a single prediction for the ith observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classification is the goal). This leads to a single OOB prediction for the ith observation. An OOB prediction can be obtained in this way for each of the n observations, from which the overall OOB MSE (for a regression problem) or classification error (for a classification problem) can be computed. The resulting OOB error is a valid estimate of the test error for the bagged model, since the response for each observation is predicted using only the trees that were not fit using that observation. Figure 8.8 displays the OOB error on the Heart data. It can be shown that with B sufficiently large, OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous."}
{"id": 984, "contributed_by": "group 11", "title": "", "section": "", "text": "The remaining one-third of the observations not used to fit a given bagged tree are referred to as the out-of-bag (OOB) observations. We can predict the response for the ith observation using each of the trees in which that observation was OOB. This will yield around B/3 predictions for the ith observation. In order to obtain a single prediction for the ith observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classification is the goal). This leads to a single OOB prediction for the ith observation. An OOB prediction can be obtained in this way for each of the n observations, from which the overall OOB MSE (for a regression problem) or classification error (for a classification problem) can be computed. The resulting OOB error is a valid estimate of the test error for the bagged model, since the response for each observation is predicted using only the trees that were not fit using that observation. Figure 8.8 displays the OOB error on the Heart data. It can be shown that with B sufficiently large, OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous."}
{"id": 985, "contributed_by": "group 11", "title": "", "section": "", "text": "Random forests provide an improvement over bagged trees by way of a small tweak that decorrelates the trees. As in bagging, we build a number of decision trees on bootstrapped training samples. But when building these decision trees, each time a split in a tree is considered, a random sample of m predictors is chosen as split candidates from the full set of p predictors. The split is allowed to use only one of those m predictors."}
{"id": 986, "contributed_by": "group 11", "title": "", "section": "", "text": "Finally, we discuss Bayesian additive regression trees (BART), another ensemble method that uses decision trees as its building blocks. For simplicity, we present BART for regression (as opposed to classification). Recall that bagging and random forests make predictions from an average of regression trees, each of which is built using a random sample of data and/or predictors. Each tree is built separately from the others. By contrast, boosting uses a weighted sum of trees, each of which is constructed by fitting a tree to the residual of the current fit. Thus, each new tree attempts to capture signal that is not yet accounted for by the current set of trees. BART is related to both approaches: each tree is constructed in a random manner as in bagging and random forests, and each tree tries to capture signal not yet accounted for by the current model, as in boosting."}
{"id": 987, "contributed_by": "group 11", "title": "", "section": "", "text": "Tree Pruning The process described above may produce good predictions on the training set, but is likely to overfit the data, leading to poor test set performance. This is because the resulting tree might be too complex"}
{"id": 988, "contributed_by": "group 11", "title": "", "section": "", "text": "A natural choice is the maximal margin hyperplane (also known as the maximal margin hyperplane optimal separating hyperplane), which is the separating hyperplane that optimal separating hyperplane is farthest from the training observations. That is, we can compute the (perpendicular) distance from each training observation to a given separating hyperplane; the smallest such distance is the minimal distance from the observations to the hyperplane, and is known as the margin. The maximal margin hyperplane is the separating hyperplane for which the margin is margin largest that is, it is the hyperplane that has the farthest minimum distance to the training observations."}
{"id": 989, "contributed_by": "group 11", "title": "", "section": "", "text": "We see that three training observations are equidistant from the maximal margin hyperplane and lie along the dashed lines indicating the width of the margin. These three observations are known as support vectors, since they are vectors in p-dimensional space and they \u201csupport\u201d the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hyperplane would move as well. Interestingly, the maximal margin hyperplane depends directly on the support vectors, but not on the other observations: a movement to any of the other observations would not affect the separating hyperplane, provided that the observation\u2019s movement does not cause it to cross the boundary set by the margin. The fact that the maximal margin hyperplane depends directly on only a small subset of the observations is an important property that will arise later in this chapter when we discuss the support vector classifier and support vector machines."}
{"id": 990, "contributed_by": "group 11", "title": "", "section": "", "text": "The optimization problem has a very interesting property: it turns out that only observations that either lie on the margin or that violate the margin will affect the hyperplane, and hence the classifier obtained. In other words, an observation that lies strictly on the correct side of the margin does not affect the support vector classifier! Changing the position of that observation would not change the classifier at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors. These observations do affect the support vector classifier."}
{"id": 991, "contributed_by": "group 11", "title": "", "section": "", "text": "This is known as hinge loss, and is depicted. However, it turns out that the hinge loss function is closely related to the loss function used in logistic regression, also shown. An interesting characteristic of the support vector classifier is that only support vectors play a role in the classifier obtained; observations on the correct side of the margin do not affect it."}
{"id": 992, "contributed_by": "group 11", "title": "", "section": "", "text": "We have established that the support vector classifier is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is \u201cno\u201d. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen. However, for historical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods."}
{"id": 993, "contributed_by": "group 11", "title": "", "section": "", "text": "Though we have not addressed it here, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualitative response), called support vector regression. We saw that support vector regression least squares regression seeks coefficients such that the sum of squared residuals is as small as possible. (Recall from Chapter 3 that residuals are defined. Support vector regression instead seeks coefficients that minimize a different type of loss, where only residuals larger in absolute value than some positive constant contribute to the loss function. This is an extension of the margin used in support vector classifiers to the regression setting."}
{"id": 994, "contributed_by": "group 11", "title": "", "section": "", "text": "The fact that only support vectors affect the classifier is in line with our previous assertion that C controls the bias-variance trade-off of the support vector classifier. When the tuning parameter C is large, then the margin is wide, many observations violate the margin, and so there are many support vectors. In this case, many observations are involved in determining the hyperplane. The top left panel illustrates this setting: this classifier has low variance (since many observations are support vectors) but potentially high bias. In contrast, if C is small, then there will be fewer support vectors and hence the resulting classifier will have low bias but high variance. The bottom right panel illustrates this setting, with only eight support vectors."}
{"id": 995, "contributed_by": "group 11", "title": "", "section": "", "text": "The fact that the support vector classifier\u2019s decision rule is based only on a potentially small subset of the training observations (the support vectors) means that it is quite robust to the behavior of observations that are far away from the hyperplane. This property is distinct from some of the other classification methods that we have seen in preceding chapters, such as linear discriminant analysis. Recall that the LDA classification rule depends on the mean of all of the observations within each class, as well as the within-class covariance matrix computed using all of the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to observations far from the decision boundary. In fact, the support vector classifier and logistic regression are closely related."}
{"id": 996, "contributed_by": "group 11", "title": "", "section": "", "text": "This is known as a polynomial kernel of degree d, where d is a positive polynomial kernel integer. Using such a kernel with d greater than 1, instead of the standard linear kernel, in the support vector classifier algorithm leads to a much more flexible decision boundary. It essentially amounts to fitting a support vector classifier in a higher-dimensional space involving polynomials of degree d, rather than in the original feature space. When the support vector classifier is combined with a non-linear kernel, the resulting classifier is known as a support vector machine."}
{"id": 997, "contributed_by": "group 11", "title": "", "section": "", "text": "In the right-hand panel, the SVM using gamma, which showed the best results on the training data, produces the worst estimates on the test data. This is once again evidence that while a more flexible method will often produce lower training error rates, this does not necessarily lead to improved performance on test data."}
{"id": 998, "contributed_by": "group 11", "title": "", "section": "", "text": "So far, our discussion has been limited to the case of binary classification: that is, classification in the two-class setting. How can we extend SVMs to the more general case where we have some arbitrary number of classes? It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one and one-versus-all approaches. We briefly discuss those two approaches here."}
{"id": 999, "contributed_by": "group 11", "title": "", "section": "", "text": "So far, our discussion has been limited to the case of binary classification: that is, classification in the two-class setting. How can we extend SVMs to the more general case where we have some arbitrary number of classes? It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one and one-versus-all approaches. We briefly discuss those two approaches here."}
{"id": 1000, "contributed_by": "group 11", "title": "", "section": "", "text": "In a p-dimensional space, a hyperplane is a fat affine subspace of hyperplane dimension. For instance, in two dimensions, a hyperplane is a fat one-dimensional subspace, in other words, a line. In three dimensions, a hyperplane is a fat two-dimensional subspace, that is, a plane. In dimensions, it can be hard to visualize a hyperplane, but the notion of a dimensional fat subspace still applies. The mathematical definition of a hyperplane is quite simple. Note that it is simply the equation of a line, since indeed in two dimensions a hyperplane is a line. The equation can be easily extended to the p-dimensional setting. Then this tells us that X lies to one side of the hyperplane. So we can think of the hyperplane as dividing p-dimensional space into two halves. One can easily determine on which side of the hyperplane a point lies by simply calculating the sign of the left-hand side."}
{"id": 1001, "contributed_by": "group 11", "title": "", "section": "", "text": "The support vector machine (SVM) is an extension of the support vector support vector machine classifier that results from enlarging the feature space in a specific way, using kernels. We will now discuss this extension, the details of which are somewhat complex and beyond the scope of this book. However, the main kernel idea is described. we may want to enlarge our feature space in order to accommodate a non-linear boundary between the classes. The kernel approach that we describe here is simply an efficient computational approach for enacting this idea."}
{"id": 1002, "contributed_by": "group 11", "title": "", "section": "", "text": "The maximal margin classifier is a very natural way to perform classification, if a separating hyperplane exists. However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal margin classifier. In this case, we cannot exactly separate the two classes. However, as we will see in the next section, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almost separates the classes, using a so-called soft margin. The generalization of the maximal margin classifier to the non-separable case is known as the support vector classifier."}
{"id": 1003, "contributed_by": "group 11", "title": "", "section": "", "text": "Recall that the LDA classification rule depends on the mean of all of the observations within each class, as well as the within-class covariance matrix computed using all of the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to observations far from the decision boundary. In fact, we will see that the support vector classifier and logistic regression are closely related."}
{"id": 1004, "contributed_by": "group 11", "title": "", "section": "", "text": "In a p-dimensional space, a hyperplane is a fat affine subspace of hyperplane dimension p minus 1. For instance, in two dimensions, a hyperplane is a fat one-dimensional subspace, in other words, a line. In three dimensions, a hyperplane is a fat two-dimensional subspace, that is, a plane. In p greater than 3 dimensions, it can be hard to visualize a hyperplane, but the notion of a p minus 1 dimensional fat subspace still applies."}
{"id": 1005, "contributed_by": "group 11", "title": "", "section": "", "text": "The support vector classifier, sometimes called a soft margin classifier, does exactly this. Rather than seeking the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. (The margin is soft because it can be violated by some of the training observations.) An example is shown in the left-hand panel of Most of the observations are on the correct side of the margin. However, a small subset of the observations are on the wrong side of the margin."}
{"id": 1006, "contributed_by": "group 11", "title": "", "section": "", "text": "We have established that the support vector classifier is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is \u201cno\u201d. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen. However, for historical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods."}
{"id": 1007, "contributed_by": "group 11", "title": "", "section": "", "text": "Another popular choice is the radial kernel. The right-hand panel shows an example of an SVM with a radial kernel on this non-linear data; it also does a good job in separating the two classes."}
{"id": 1008, "contributed_by": "group 11", "title": "", "section": "", "text": "We have established that the support vector classifier is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is \u201cno\u201d. We could just as well perform logistic regression or many of the other classification methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen. However, for historical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods."}
{"id": 1009, "contributed_by": "group 11", "title": "", "section": "", "text": "SVMs and support vector classifiers output class labels for each observation. However, it is also possible to obtain fitted values for each observation, which are the numerical scores used to obtain the class labels. For instance, in the case of a support vector classifier, the fitted value for an observation. For an SVM with a non-linear kernel, the equation that yields the fitted value is given. The sign of the fitted value determines on which side of the decision boundary the observation lies. Therefore, the relationship between the fitted value and the class prediction for a given observation is simple: if the fitted value exceeds zero then the observation is assigned to one class, and if it is less than zero then it is assigned to the other. By changing this threshold from zero to some positive value, we skew the classifications in favor of one class versus the other. By considering a range of these thresholds, positive and negative, we produce the ingredients for a ROC plot. We can access these values by calling the function."}
{"id": 1010, "contributed_by": "group 11", "title": "", "section": "", "text": "In this example, the SVM appears to provide accurate predictions. By increasing gamma we can produce a more flexible ft and generate further improvements in accuracy."}
{"id": 1011, "contributed_by": "group 11", "title": "", "section": "", "text": "This data set consists of expression measurements for 2,308 genes. The training and test sets consist of 63 and 20 observations, respectively. We will use a support vector approach to predict cancer subtype using gene expression measurements. In this data set, there is a very large number of features relative to the number of observations. This suggests that we should use a linear kernel because the additional flexibility that will result from using a polynomial or radial kernel is unnecessary. We see that there are no training errors. In fact, this is not surprising, because the large number of variables relative to the number of observations implies that it is easy to find hyperplanes that fully separate the classes."}
{"id": 1012, "contributed_by": "group 11", "title": "", "section": "", "text": "The optimization problem has a very interesting property: it turns out that only observations that either lie on the margin or that violate the margin will affect the hyperplane, and hence the classifier obtained. In other words, an observation that lies strictly on the correct side of the margin does not affect the support vector classifier! Changing the position of that observation would not change the classifier at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors. These observations do affect the support vector classifier."}
{"id": 1013, "contributed_by": "group 11", "title": "", "section": "", "text": "where \u03bb is a nonnegative tuning parameter. When \u03bb is large then \u03b21,..., \u03b2p are small, more violations to the margin are tolerated, and a low-variance but high-bias classifier will result. When \u03bb is small then few violations to the margin will occur; this amounts to a high-variance but low-bias Relationship to Logistic Regression classifier. Thus, a small value of \u03bb in amounts to a small value of C. Note that the \u03bb term is the ridge penalty term from Section and plays a similar role in controlling the bias-variance trade-off for the support vector classifier. It takes the \u201cLoss + Penalty\u201d form that we have seen repeatedly throughout this book."}
{"id": 1014, "contributed_by": "group 11", "title": "", "section": "", "text": "Why does this lead to a non-linear decision boundary? In the enlarged feature space, the decision boundary that results is in fact linear. But in the original feature space, its solutions are generally non-linear. One might additionally want to enlarge the feature space with higher-order polynomial terms, or with interaction terms. Alternatively, other functions of the predictors could be considered rather than polynomials. It is not hard to see that there are many possible ways to enlarge the feature space, and that unless we are careful, we could end up with a huge number of features. Then computations would become unmanageable. The support vector machine, which we present next, allows us to enlarge the feature space used by the support vector classifier in a way that leads to efficient computations."}
{"id": 1015, "contributed_by": "group 11", "title": "", "section": "", "text": "LDA and the support vector classifier both perform well, though there is a suggestion that the support vector classifier may be slightly superior. The right-hand panel displays ROC curves for SVMs using a radial kernel, with various values of \u03b3. As \u03b3 increases and the ft becomes more non-linear, the ROC curves improve. Using \u03b3 = 10^\u22121 appears to give an almost perfect ROC curve. However, these curves represent training error rates, which can be misleading in terms of performance on new test data. It displays ROC curves computed on the 90 test observations. We observe some differences from the training ROC curves. In the left-hand panel, the support vector classifier appears to have a small advantage over LDA. In the right-hand panel, the SVM using \u03b3 = 10^\u22121, which showed the best results on the training data, produces the worst estimates on the test data. This is once again evidence that while a more flexible method will often produce lower training error rates, this does not necessarily lead to improved performance on test data. The SVMs with \u03b3 = 10^\u22122 and \u03b3 = 10^\u22123 perform comparably to the support vector classifier, and all three outperform the SVM with \u03b3 = 10^\u22121."}
{"id": 1016, "contributed_by": "group 11", "title": "", "section": "", "text": "When SVMs were first introduced in the mid-1990s, they made quite a splash in the statistical and machine learning communities. This was due in part to their good performance, good marketing, and also to the fact that the underlying approach seemed both novel and mysterious. The idea of finding a hyperplane that separates the data as well as possible, while allowing some violations to this separation, seemed distinctly different from classical approaches for classification, such as logistic regression and linear discriminant analysis. Moreover, the idea of using a kernel to expand the feature space in order to accommodate non-linear class boundaries appeared to be a unique and valuable characteristic."}
{"id": 1017, "contributed_by": "group 11", "title": "", "section": "", "text": "We now use the SupportVectorClassifier() function (abbreviated SVC()) SupportVector Classifier() from sklearn to ft the support vector classifier for a given value of the parameter C. The C argument allows us to specify the cost of a violation to the margin. When the cost argument is small, then the margins will be wide and many support vectors will be on the margin or will violate the margin. When the C argument is large, then the margins will be narrow and there will be few support vectors on the margin or violating the margin. Here we demonstrate the use of SVC() on a two-dimensional example, so that we can plot the resulting decision boundary. We begin by generating the observations, which belong to two classes, and checking whether the classes are linearly separable."}
{"id": 1018, "contributed_by": "group 11", "title": "", "section": "", "text": "This property is distinct from some of the other classification methods that we have seen in preceding chapters, such as linear discriminant analysis. In contrast, logistic regression, unlike LDA, has very low sensitivity to observations far from the decision boundary."}
{"id": 1019, "contributed_by": "group 11", "title": "", "section": "", "text": "A classifier based on a separating hyperplane will necessarily perfectly classify all of the training observations; this can lead to sensitivity to individual observations."}
{"id": 1020, "contributed_by": "group 11", "title": "", "section": "", "text": "When C is small, we seek narrow margins that are rarely violated; this amounts to a classifier that is highly fit to the data, which may have low bias but high variance."}
{"id": 1021, "contributed_by": "group 11", "title": "", "section": "", "text": "Neural networks rose to fame in the late 1980s."}
{"id": 1022, "contributed_by": "group 11", "title": "", "section": "", "text": "Neural networks resurfaced after 2010 with the new name deep learning, with new architectures, additional bells and whistles, and a string of success stories on some niche problems such as image and video classification, speech and text modeling."}
{"id": 1023, "contributed_by": "group 11", "title": "", "section": "", "text": "Then along came SVMs, boosting, and random forests, and neural networks fell somewhat from favor."}
{"id": 1024, "contributed_by": "group 11", "title": "", "section": "", "text": "Part of the reason was that neural networks required a lot of tinkering, while the new methods were more automatic."}
{"id": 1025, "contributed_by": "group 11", "title": "", "section": "", "text": "A special family of convolutional neural networks (CNNs) has evolved for classifying images such as these, and has shown spectacular success on a wide range of problems."}
{"id": 1026, "contributed_by": "group 11", "title": "", "section": "", "text": "CNNs mimic to some degree how humans classify images, by recognizing specific features or patterns anywhere in the image that distinguish each particular object class."}
{"id": 1027, "contributed_by": "group 11", "title": "", "section": "", "text": "A convolution layer is made up of a large number of convolution filters, each of which is a template that determines whether a particular local feature is present in an image. A convolution filter relies on a very simple operation, called a convolution, which basically amounts to repeatedly multiplying matrix elements and then adding the results."}
{"id": 1028, "contributed_by": "group 11", "title": "", "section": "", "text": "With CNNs, the filters are learned for the specific classification task."}
{"id": 1029, "contributed_by": "group 11", "title": "", "section": "", "text": "We can think of the filter weights as the parameters going from an input layer to a hidden layer, with one hidden unit for each pixel in the convolved image."}
{"id": 1030, "contributed_by": "group 11", "title": "", "section": "", "text": "They operate on localized patches in the input image (so there are many structural zeros), and the same weights in a given filter are reused for all possible patches in the image (so the weights are constrained)."}
{"id": 1031, "contributed_by": "group 11", "title": "", "section": "", "text": "They operate on localized patches in the input image (so there are many structural zeros), and the same weights in a given filter are reused for all possible patches in the image (so the weights are constrained)."}
{"id": 1032, "contributed_by": "group 11", "title": "", "section": "", "text": "The max pooling operation summarizes each non-overlapping 2 \u00d7 2 block of pixels in an image using the maximum value in the block. This reduces the size of the image by a factor of two in each direction, and it also provides some location invariance: i.e. as long as there is a large value in one of the four pixels in the block, the whole block registers as a large value in the reduced image."}
{"id": 1033, "contributed_by": "group 11", "title": "", "section": "", "text": "A pooling layer provides a way to condense a large image into a smaller pooling summary image. While there are a number of possible ways to perform pooling, the max pooling operation summarizes each non-overlapping 2 \u00d7 2 block of pixels in an image using the maximum value in the block. This reduces the size of the image by a factor of two in each direction, and it also provides some location invariance: i.e. as long as there is a large value in one of the four pixels in the block, the whole block registers as a large value in the reduced image."}
{"id": 1034, "contributed_by": "group 11", "title": "", "section": "", "text": "The number of convolution filters in a convolution layer is akin to the number of units at a particular hidden layer in a fully-connected neural network. This number also defines the number of channels in the resulting three-dimensional feature map."}
{"id": 1035, "contributed_by": "group 11", "title": "", "section": "", "text": "After this first round of convolutions, we now have a new 'image'; a feature map with considerably more channels than the three color input channels (six in the figure, since we used six convolution filters)."}
{"id": 1036, "contributed_by": "group 11", "title": "", "section": "", "text": "The number of convolution filters in a convolution layer is akin to the number of units at a particular hidden layer in a fully-connected neural network. This number also defines the number of channels in the resulting three-dimensional feature map."}
{"id": 1037, "contributed_by": "group 11", "title": "", "section": "", "text": "After this first round of convolutions, we now have a new 'image'; a feature map with considerably more channels than the three color input channels (six in the figure, since we used six convolution filters)."}
{"id": 1038, "contributed_by": "group 11", "title": "", "section": "", "text": "This is followed by a max-pool layer, which reduces the size of the feature map in each channel by a factor of four: two in each dimension."}
{"id": 1039, "contributed_by": "group 11", "title": "", "section": "", "text": "Since the channel feature maps are reduced in size after each pool layer, we usually increase the number of filters in the next convolve layer to compensate."}
{"id": 1040, "contributed_by": "group 11", "title": "", "section": "", "text": "Each subsequent convolve layer is similar to the first. It takes as input the three-dimensional feature map from the previous layer and treats it like a single multi-channel image. Each convolution filter learned has as many channels as this feature map."}
{"id": 1041, "contributed_by": "group 11", "title": "", "section": "", "text": "Sometimes we repeat several convolve layers before a pool layer. This effectively increases the dimension of the filter."}
{"id": 1042, "contributed_by": "group 11", "title": "", "section": "", "text": "These operations are repeated until the pooling has reduced each channel feature map down to just a few pixels in each dimension. At this point the three-dimensional feature maps are fattened \u2014 the pixels are treated as separate units \u2014 and fed into one or more fully-connected layers before reaching the output layer."}
{"id": 1043, "contributed_by": "group 11", "title": "", "section": "", "text": "There are many tuning parameters to be selected in constructing such a network. Fortunately, terrific software is available, with extensive examples and vignettes that provide guidance on sensible choices for the parameters."}
{"id": 1044, "contributed_by": "group 11", "title": "", "section": "", "text": "These operations are repeated until the pooling has reduced each channel feature map down to just a few pixels in each dimension. At this point the three-dimensional feature maps are fattened \u2014 the pixels are treated as separate units \u2014 and fed into one or more fully-connected layers before reaching the output layer."}
{"id": 1045, "contributed_by": "group 11", "title": "", "section": "", "text": "The details of constructing a convolutional neural network can seem daunting. Fortunately, terrific software is available, with extensive examples and vignettes that provide guidance on sensible choices for the parameters."}
{"id": 1046, "contributed_by": "group 11", "title": "", "section": "", "text": "Essentially, each training image is replicated many times, with each replicate randomly distorted in a natural way such that human recognition is unaffected. At face value this is a way of increasing the training set considerably with somewhat different examples, and thus protects against overfitting."}
{"id": 1047, "contributed_by": "group 11", "title": "", "section": "", "text": "This kind of fattening of the data is similar in spirit to ridge regularization. We build a cloud of images around each original image, all with the same label. This kind of fattening of the data is similar in spirit to ridge regularization."}
{"id": 1048, "contributed_by": "group 11", "title": "", "section": "", "text": "Essentially, each training image is replicated many times, with each replicate randomly distorted in a natural way such that human recognition is unaffected. At face value this is a way of increasing the training set considerably with somewhat different examples, and thus protects against overfitting."}
{"id": 1049, "contributed_by": "group 11", "title": "", "section": "", "text": "This kind of fattening of the data is similar in spirit to ridge regularization. This kind of fattening of the data is similar in spirit to ridge regularization."}
{"id": 1050, "contributed_by": "group 11", "title": "", "section": "", "text": "The ResNet50 classifier is a convolutional neural network that was trained using the ImageNet dataset, which consists of millions of images that belong to an ever-growing number of categories."}
{"id": 1051, "contributed_by": "group 11", "title": "", "section": "", "text": "Much of the work in fitting a CNN is in learning the convolution filters at the hidden layers; these are the coefficients of a CNN."}
{"id": 1052, "contributed_by": "group 11", "title": "", "section": "", "text": "For models fit to massive corpora such as ImageNet with many classes, the output of these filters can serve as features for general natural-image classification problems."}
{"id": 1053, "contributed_by": "group 11", "title": "", "section": "", "text": "The CNN does a reasonable job classifying the hawk in the second image."}
{"id": 1054, "contributed_by": "group 11", "title": "", "section": "", "text": "One can use these pretrained hidden layers for new problems with much smaller training sets (a process referred to as weight freezing), and weight freezing just trains the last few layers of the network, which requires much less data."}